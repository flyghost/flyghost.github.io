###### 802.11协议精读（转自徐方鑫）

[TOC]

# 学习资料整理

## **序言**

笔者从研究生开始，一直在做有关802.11协议的相关内容。故在此将笔者学习期间收集了较好的学习资料进行整理，并记录如下。该整理按照由潜至深的顺序，可以根据个人不同的情况，进行选择。（PS：其中有的附上的下载链接均为网上搜索而言，仅为学习使用而已，有的资料可能不是最新版，所以还是购买原版书好一些)。

## **综合类**

**1.CWNP系列教材**

CWNP（[CWNP](https://link.zhihu.com/?target=https%3A//www.cwnp.com/)）是一个无线方向的认证项目，其教材是比较适合初学802.11协议的人使用的，其主要是避免了大量的数学工程，基本是从工程师应用的角度来编写。按照其官网所描述，CWNP的认证包含：CWTS，CWNA，CWSP，CWDP，CWAP，CWNE，CWNT。其中CWNA的教材最为适合初学，且也有中文的翻译版。其余CWSP，CWDP等教材适合进阶一步阅读。部分的教材（包含了CWTS，CWNA，CWSP，CWDP，CWAP）可以在【[Download Wireless Networking Study Guides](https://link.zhihu.com/?target=http%3A//srijit.com/download-wireless-networking-study-guides/)】该链接下载，我也打包了一份【[CWNP系列教材（整合版）](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477045)】。

**2.802.11权威指南（O'Reilly）**

802.11权威指南是早期的一本802.11的专著，与协议的贴合度很高（个人感觉更接近于2007版本的802.11协议），不过缺点在于对于一些当前最新的802.11协议缺乏描述，毕竟该书的初版的时候，802.11n还是处于草案阶段。整体而言，整本书的内容还是比较丰富的，而且也包含了很多细节的部分（如物理层细节），同时也避免了很多公式推导。目前收集到《802.11权威指南》的资源如下，【[802.11权威指南](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9426208)】。

**3.802.11 Survival Guide（O'Reilly）**

由于802.11权威指南中没有专门讨论过802.11n和802.11ac，所以后面O'Reilly还有两本书专门说明有关802.11n和802.11ac的内容，包含：802.11n A Survival Guide与802.11ac A Survival Guide。粗读一遍，感觉协议的很多部分（包含物理层和MAC层）还是描述的很详细的，其相应的资源整理如下，【[802.11 Survival Guide（OReilly)](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477087)】。

**4.Next Generation Wireless LANs（Cambridge）**

Cambridge的两本有关802.11的专著：Cambridge.Next Generation Wireless LANs.802.11n与Cambridge.Next Generation Wireless LANs.802.11n and 802.11ac，感觉是两本描述802.11的书籍中最为细致的两本书，也同时感觉最为权威的两本书，其中很多物理层细节与MAC层细节都只有在这本书中可以找到（尤其是802.11的物理层部分）。如果打算详细研究802.11协议的话，非常建议读下这本书，其中后者是新版（包含了802.11n和802.11ac的主要内容），所以更加推荐阅读。其相应的资源整理如下，【[Next Generation Wireless LANs (Cambridge)](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477083)】。

其实有关Cambridge.Next Generation Wireless LANs.802.11n，该书国内也存在翻译版，其资源整理如下，【[下一代无线局域网：802.11n的吞吐率、强健性和可靠性](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9502196)】。

**5.WAPI协议**

WAPI和802.11的关系有兴趣可以自行搜索。从学习的角度上而言，WAPI可以当做中文的802.11（即802.11的早期版本）。比较适合早期阅读802.11协议原版，毕竟原协议内容，写法之类都和一般书本不同，所以还是中文的资料好适应一些。其相应的资源整理如下，【[WAPI](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477102)】。

**6.802.11协议（2007版与2012版）**

802.11协议有很多个版本，包含了众所周知的是802.11a/b/g/n/ac这些，其余还有802.11r/802.11k/802.11s等等很多协议版本，以及还存在协议的演化，比如802.11ae/802.11aa这些。其中802.11的2007版和2012版算是一个协议整合版，其中802.11-2012版包含了07版以及802.11n，802.11k，802.11r等相应的内容，所以适合详细阅读802.11协议使用，不过2012版中没有包含802.11ac/ad，802.11ah，802.11ae，802.11aa等相关的内容，所以这些新协议还需要读协议的分支。其中07版和12版的相应资源整理如下，【[IEEE 802.11 2007/2012](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477127)】。

## **安全类**

**1.802.11 security（O'Reilly）**

O'Reilly也有一本关于802.11安全的专著，这本书目前还没有读完，整体感觉还是比较好的。相应资源如下，【[802.11 security（OReilly）](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9730041)】。

**2.Real 802.11 Security - Wi-Fi Protected Access and 802.11i**

这本书老早之前读过一次，总体感觉还是可以的，该书主要讨论的是802.11i的内容，不过由于出版的较早，所以有些内容有些老了。相应的资源如下，【[Real 802.11 Security - Wi-Fi Protected Access and 802.11i](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477151)】。

## **设计类**

**1.IEEE 802.11 Tutorial（Berkeley）**

这份材料是bekerly那里出的较早期的IEEE 802.11 Tutorial，实际应该放在综合类中的。不过这份资料中的很多流程图描绘的还不错，是从整个协议执行的机制上所述，且都做了一定的简化，所以也是不错的材料。相应的资源如下，【[IEEE 802.11 Tutorial (Berkeley)](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477194)】。

**2.Wi-Fi：802.11 物理层和发射机测量概述**

这份资料是泰克公司公开的资料，实际上是将802.11物理层部分加以总结出的一份文档，用来快速学习802.11物理层的有关知识是很适合的，而且其中的内容也是从测试厂家的角度而写，相比一般书本的知识，这些内容更加偏实际一些。相应的资源如下，【[Wi-Fi：802.11物理层和发射机测量概述](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477192)】。

**3.802.11物理层规范海报**

这一份泰克这份海报，非常贴切802.11协议，其中很多物理层的内容，以及信道分配，5G可用信道有哪些，都有总结，作为速查非常方便。相应的资源如下，【[802.11物理层规范海报](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9669829)】

**4.通信新读**

实际上这份资料与802.11的关系不是很大，但是该书是一本的用来学习通信知识不错的书。适合初学者学习通信的理论知识，与大话系列不同，这本书还是很注重理论知识的。该书没有完整的电子版，只收集到试读的部分（笔者不少资料还是读的纸质版），相应的资源如下，【[通信新读（试读）](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477254)】。

**5.OFDM for wireless communications systems**

这本书是一份OFDM的专题书，且内容较短且精，适合作为了解OFDM基本原理后，不断重新深入理解OFDM原理所阅读，其中有些细节还是比较不错的。相应的资源如下，【[OFDM for wireless communications systems](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9668319)】。

**6.Radio Frequency Propagation Made Easy**

802.11中的信道模型实际上描述的内容并不多，故需要一些有关射频传播模型的背景知识才好深入理解一些，上面这份教材讲的深浅适中，对于理解802.11协议中的内容是足够的了。相应的资源如下，【[Radio Frequency Propagation Made Easy](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9614718)】

## **仿真类**

**1.MIMO-OFDM Wireless Communications with MATLAB**

该书是一篇有关MIMO-OFDM理论以及仿真的综合书，书中夹杂描述了一些802.11情况下的信道模型，物理层模型之类，由于当前802.11的主流技术是基于MIMO-OFDM的，且如果需要真正学习802.11相应的通信知识，还是多接触些物理层和数学为好，该书的理论都有配以仿真，所以很适合学习。相应的资源，包含原书和源码如下，【[MIMO-OFDM Wireless Communications with MATLAB](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477191)】。

**2.NS2仿真实验-多媒体与无线网络**

柯志恒老师的书，很多学习NS2的人一开始都学习过，这里收集了下书的电子版以及源码，相应的资源如下，【[NS2仿真实验-多媒体与无线网络 ](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477217)】。

**3.The NS2 Manual**

有关NS2的资料实际上是非常多的，笔者曾经用过一段时间NS2做802.11仿真，当时顺着这份材料学习了下，所以记录下。NS2有关802.11的资料还是非常多的，每个人可以根据自己的需求寻找资料。该资源如下，【[The NS2 Manual](https://link.zhihu.com/?target=http%3A//info.iet.unipi.it/~cicconetti/aan/download/everything.pdf)】。

**4.Implementation of IEEE 802.11 Physical Layer Model in NS3**

这份材料的原题目比较长（Study and Implementation of IEEE 802.11 Physical Layer Model in YANS (Future NS-3) Network Simulator），主要是讨论如何在NS3中模拟802.11物理层的模型。该资料中，提供了很多不同种类的物理层模型，以及参数，由于笔者在做仿真的时候，需要采用一些跨层仿真的方法，从这份资料里面算是得到不少启发，故记录一下。该资料相应的资源如下，【[Implementation of IEEE 802.11 Physical Layer Model in NS3](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477260)】。

## **实现类**

**1.深入理解Android：WiFi模块 NFC和GPS卷**

这本书是朋友推荐的一本书，当时是为了学习802.11安全协议的部分。由于直接从openwrt的角度来分析802.11源码的书很少，所以这本从andriod的角度分析源码的书也是挺好的，相应的资源如下，【[深入理解Android：WiFi模块 NFC和GPS卷](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477230)】。

**2.基于XILINX FPGA的OFDM通信系统基带设计**

该书是比较完整的叙述了802.11a的基带在FPGA上实现的书，虽然调源码的时候发现可能会发现有一些错误，但是总体上而言，这本书的知识结构也是较为完整的，笔者对于802.11在FPGA实现的英语材料没有怎么阅读过，故从这本书上也算获取了不少知识，总体感觉也是不错的。该书以及其源码的资源如下，【[基于XILINX FPGA的OFDM通信系统基带设计](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9477222)】。

**3.Linux Kernel Networking**

该书主要是描述了Linux内核中网络的实现部分，其第12章具体就是对应无线模块。由于描述Linux内核中无线模块资料比较少，所以这本书也是比较推荐的，只不过对于细节部分，该书描述不是特别细致，不过总体还是不错的。该书以及其源码的资源如下，【[Linux Kernel Networking ](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9578509)】。

**4.Linux Wi-Fi open source drivers-mac 802.11**

该材料比较完整的叙述了从kernel到802.11驱动底层的一个函数调用过程，用来学习802.11具体驱动过程是一份比较好的材料。该资料的资源如下，【[Linux Wi-Fi open source drivers-mac 802.11](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9712191)】。

**5.通信IC设计**

这份本书内容感觉目前是除了MATLAB 2016a/b代码以外，对802.11物理层最为详尽描述的材料了（在该书下册）。该书也有附带的相应代码。该书目前只有纸质版，有可以自行阅读。

## **历史类**

**1. The Innovation Journey of Wi-Fi (The Road to Global Success)**

这一份是描述802.11协议诞生以来到被广泛推广这一段时间以来的大致发展历史，其第二作者Vic Hayes在1990-2000年期间作为IEEE 802.11的主席，对这一块历史了解应该是非常深入的。该资料的资源如下，【[The Innovation Journey of Wi-Fi (The Road to Global Success)](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9752224)】

# DCF与CSMA/CA

## **序言**

在初始802.11的MAC层中，分成了两种基本工作模式：

- DCF（Distributed Coordination Function）
- PCF（Point Coordination Function）

其中，由于DCF具有良好的分布式特性，从而应用更加广泛，而PCF模式则较为少用。在802.11e协议中，DCF被扩展为EDCA模式，PCF模式被扩展为HCCA模式。本文所讨论的主要内容即有关DCF模式以及其核心CSMA/CA机制。

*PS：在当前的802.11协议中，除了初始定义的DCF和PCF工作模式外，在802.11e中还定义了EDCA，HCCA，不过本文暂不展开。*

## **CSMA/CA机制**

由于无线信道只有一个冲突域的特性，所以需要设置一种随机接入机制，以避免多个节点同时访问网络所带来的冲突问题，在WiFi协议中，该随机接入机制即是CSMA/CA。CSMA/CA的全称是Carrier Sense Multiple Access with Collision Avoidance，即载波侦听多路访问／冲突避免。如果熟悉有线网络的可以知道，在集线器与中继器中也会采用一种CSMA/CD的机制，从协议设计的大思路上，两者是类似的，或者说两个都是基于CSMA机制的，而细节上，两者有很多的出入，在本文中，我们尚不细致讨论两者协议的具体差别，而仅仅叙述CSMA/CA的工作机制。

为了方便文中讨论，我们首先假定一个网络拓扑环境如下：



![img](https://pic4.zhimg.com/80/ed2e0d4d2791107140999bb15f800e63_720w.png)

在该拓扑中，存在一个AP，与两个节点（STA 1与STA 2），如果对于无线术语不是很熟悉的话，可以把AP理解成无线路由器。由于无线环境下的广播特性，若STA 1与STA 2同时向AP发送数据，那么就会在AP处发生冲突，从而两者都无法正确接收，最终传输失败。CSMA/CA就是提供一种避免冲突发生的接入规则。

接下来我们需要具体描述CSMA/CA的工作机制，为了方便理解，我们这里首先要给出四个概念：

- DIFS与SIFS：该两种都是属于Inter-frame Spacing（IFS），即帧间间隙。DIFS全称为Distributed Inter-frame Spacing，即分布式帧间间隙，SIFS称为Short inter-frame space，即短帧间间隔。在CSMA/CA中，发一个帧之前，都需要 **"等待"** 一个相应的帧间间隔，比如发送数据之前至少要等待DIFS时间，发送ACK之前需要等待SIFS时间。在802.11中还存在其他的一些帧间间隔，比如RIFS，PIFS，AIFS，EIFS，本文不再一一赘述。（注：该段落中所提到的等待，不是真正意义上节点什么都不做，具体的功能会在后文相应位置进行描述）
- Slot Time：时隙是指的一个时间片段，在CSMA/CA中，节点竞争接入信道之前需要经过相应的随机回退（backoff）过程，其中backoff过程就是由很多个时隙所组成的。
- Contention window：竞争窗口是用来让节点选择随机回退计数值（backoff counter）的范围。
- Backoff：随机回退过程是指每一个节点在竞争信道时，所经历的随机退避过程。在这一过程开始时，节点首先在竞争窗口中选择一个随机数为基准的随机回退计数值，同时每一个时隙，节点为 **"监听"** 信道是否空闲，若信道空闲，那么进行一次倒数，即计数值减1，若信道忙，则不进行相应倒数。当该随机回退计数值回退到0时，节点可以发送数据。（注：1.该段落中所提到的监听，不仅包含了物理监听，也包含了虚拟监听机制，具体功能后文相应位置进行描述。2.该文中所讨论的一些概念与有线网络中的概念会存在一些区别，我们这里并不加以细节对比，还请见谅）

接着，我们利用时序图描述CSMA/CA的具体工作机制：

![img](https://pic4.zhimg.com/80/16def232e6120952e14b1047592dead3_720w.png)

1. 当STA 1与STA 2相继存在数据，需要在竞争信道进行发送时，其首先需要 **"等待"** DIFS时间，若DIFS时间内，信道保持空闲状态，那么就可以进行backoff过程。
2. 若STA 1与STA 2进入backoff过程时，其首先需要从竞争窗口（Contention window）选择一个随机数，在802.11协议中，默认的初始竞争窗口为31，即随机回退计数值的范围即是[0,31]。在上图中，STA 1则是选择了8，而STA 2选择了2。
3. 在backoff过程中，每经过一个slot time，节点会 **"监听"** 一次信道，若信道空闲，则相应的随机回退计数器的值减1。如上图中，经过3个slot time后，STA 1的随机倒数计数器从8递减至5，而STA 2相应从2递减至0。
4. 当节点的随机倒数计数器倒数至0时，节点竞争获得信道，从而可以发送数据。如上图，STA 2获得信道后，发送PACKET A给AP。在AP接收到数据后，会采用CRC机制对数据进行校验，若校验通过，AP会在SIFS后，反馈ACK确认帧。
5. 当STA 2成功发送完数据， "**等待**" 了SIFS的时间之后，AP会向节点反馈ACK确认帧。当STA 2成功接收到ACK帧之后，这一次传输完成。
6. 当这一次传输完成后，节点需要再次 **"等待"** DIFS的时间后，重新开始backoff过程。若节点刚刚发送完数据，那么在backoff过程开始时，需要重新从竞争窗口中选择一个随机数进行倒数。若节点没有发送数据，那么直接从上一次的倒数结果继续倒数。如上图中，STA 1没有竞争到信道，那么其在第二次的backoff过程中，直接基于上次的5直接进行倒数至4。这样的设计目的是为了保证网络传输的公平性。

![img](https://pic1.zhimg.com/80/953a4645152850bc7fa9e05e5bacfec4_720w.png)

若在上述的第5步中，AP没有成功接收节点的数据，或者AP对数据进行CRC校验错误，那么其不会反馈相应的ACK给节点。节点在ACK timeout之后，则知道对方没有成功接收数据，该ACK timeout时间在理论分析时，一般与ACK接收时间相等，在具体工程设计中，可能会大一点点。那么发送错误的节点，需要等待EIFS时间才可以再次接入信道，EIFS>DIFS，这样是为了避免一些较差的节点持续争抢信道资源。比如图中STA 2即需要在等待EIFS之后，节点首先进行BEB（该机制我们后面详细讨论），然后重新开始backoff过程，而STA 1则直接在DIFS之后进行backoff。

*注1：在这里的描述中，我们所述，在介质忙时，节点通过监听信道，判断介质忙，从而挂起随机回退计数值，这也是很多学术研究中可以看到的常见描述。*

*注2：图中的EIFS起始点应为STA2中SIFS的起始点（图中错误，暂时没有做修改），即EIFS=SIFS+ACK+DIFS时间。*

*有关挂起机制，笔者还存在一些理解。我们知道在节点竞争信道的过程中，也有可能会接收数据。由于802.11协议的特殊性，节点只有在完整解调整个数据包之后，经过CRC校验后，才可以完整判断数据帧是不是自己的，从而进行丢包处理。故挂起机制实际上是一种接收机制，即无论信道中的数据帧是不是发给节点的，该节点都需要对此数据帧进行接收，进而判断是否丢弃该帧。故节点由于处于接收状态，从而无法继续进行backoff回退操作，故这里即是处于挂起的动作。*

*同时在《CWNA教材第三版》中，这里有可能会产生一种误导的理解，即利用Duration字段，即具体采用NAV机制来完成这里挂起随机回退计数值的工作。在该书中，Duration字段用来保留之后SIFS+ACK的时间，而不是用来作为NAV字段保护该数据帧传输过程中挂起其他节点的。换言之，我们前面所提到的ACK timeout的机制，即是采用数据帧中的duration字段来具体设置的。不过除了CWNA书本上的例子外，现实中笔者没有抓到过数据帧MAC头部中Duration存在填充的情况，在这种默认情况下，ACK timeout可能就是SIFS+ACK的标准时间。*

## **BEB机制**

这里BEB机制的全称为Binary Exponential Back off，即二进制指数退避算法。在CSMA/CA的机制中，还是存在发生冲突的可能性，从而为了避免在CSMA/CA机制下的再次冲突，故这里引入了BEB机制。我们举例进行说明：

![img](https://pic1.zhimg.com/80/57df82710936c7c3e11ca293a085fecc_720w.png)

与之前所述CSMA/CA过程类似，在 **"等待"** DIFS后，STA 1与STA 2从各自的竞争窗口CW中选择一个随机数，不过碰巧的是，两者随机到了一样的数值，如图中，STA 1与STA 2都是随机到了3作为随机回退计数值。在经过3个slot time之后，由于两者同时倒数至0，那么意味着两者会同时发送数据，如图中的红色虚线框表示，在AP处由于两者信号互相干扰，从而都无法正确解码，从而CRC校验错误，即发生冲突。在冲突之后，即若AP处CRC校验失败，则不会给任意节点反馈ACK数据包，故两节点在ACK timeout之后（即总共等待EIFS之后，图中EIFS因为DIFS，这里暂未做修改），准备进入下一次竞争。

而在正式进入下一次竞争之前，节点需要对竞争窗口（CW）采用BEB机制，按我们之前所述，在初始竞争时，节点的默认CW范围是[0,31]（假设初始窗口是802.11b机制下，即最大31，在802.11a这种，初始窗口就是15）。而如果在节点数较多的情况下，那么就有可能引发之前我们所述的冲突问题，从而我们需要扩大竞争窗口CW。具体在CSMA/CA中，我们则是采用二进制指数退避的方法对竞争窗口CW进行扩展，即发生一次冲突后，那么CW范围就会从[0,31]变化到[0,63]，如图中，在冲突之后，STA 1重新随机选择50，STA 2重新随机选择32。在802.11中，一共允许回退6次，第7次不倍增窗口，再次尝试重发，若再次失败，则丢包。

参考CWNA教材，有给出具体每一次回退的CW窗口大小，如下：

![img](https://pic4.zhimg.com/80/310a8cb36adfa7a32b5e65ac723e8a1f_720w.png)

## **RTS/CTS模式**

在DCF模式下，我们还需要知道存在两种子模式：Basic模式与RTS/CTS模式。在之前CSMA/CA讨论中，我们所描述的都是Basic模式，这一章我们理解RTS/CTS模式。

为了更好的理解RTS/CTS模式，我们首先要介绍无线网络中著名的隐藏终端问题（hidden terminal problem）。

![img](https://pic4.zhimg.com/80/963bf6b1ac0d5501cf81f0918a113d67_720w.png)

在上图中，还是只有一个AP和两个节点（STA 1与STA 2）。图中蓝色虚线代表STA 1的发送范围，绿色虚线代表STA 2的发送范围。

从图中，我们可以得知，由于两个节点的发送范围无法互相覆盖，从而两者在发送数据时，是无法通过物理监听的方法，探测对方是否有发送数据。从而按照我们之前所述的CSMA/CA机制，STA 1和STA 2一直会误认为信道空闲，从而不断倒数，当计时器到0时，则发送数据，如下图：

![img](https://pic3.zhimg.com/80/ec3c65081032553d2c6bc724a9ff8fa6_720w.png)

在上图中，由于STA 1与STA 2无法互相监听，即STA 2发送数据后，STA 1还继续进行backoff过程，从而继续倒数。当STA 1的随机回退计数值倒数至0时，STA 1也会发送数据。由于STA 1与STA 2的发送存在重叠区域，即也是发生了冲突，AP无法正确接收数据，即不会反馈ACK，最终这一轮传输失败。这一轮失败之后，STA 1与STA 2采用BEB算法重新选择随机数进行回退，但是由于两者没有办法互相监听，所以很容易再次出现同时传输的现象。所以在隐藏终端的情况下，网络性能最差时是无法传递数据包的，换言之，STA 1与STA 2的吞吐量都趋近于0。

为了解决这个问题，故在DCF中，引入了RTS/CTS机制。

- RTS：Request To Send，即请求发送。RTS帧是一个单播帧，没有加密，其duration字段中填充包含后续发送过程中总体所需要时间。
- CTS：Clear To Send，即信道清除帧。节点在收到CTS后，确认信道是空闲的，可以发送。CTS也是一个单播帧，没有加密，其duration字段包含除去RTS以及一个SIFS后，发送过程总体所需要时间。

接着我们采用下图解释RTS/CTS具体的工作方法：



![img](https://pic3.zhimg.com/80/a66c3f592a3bc2f7d73da17a70001d76_720w.png)

在上图中，STA 2已经倒数至0，其首先发送RTS数据帧给AP。若在AP处没有冲突，即AP成功解调出STA 2的RTS，AP会在等待SIFS之后发送CTS帧给STA 2。由于无线信道是一个广播信道，要是帧没有加密的话，那么所有节点都是可以解析其信息的，所以这里AP虽然是发送CTS给STA 2，不过STA 1也可以解析该CTS信息，这也是很多书上写，RTS/CTS都是一个广播过程的原因。

- 当STA 1接收到CTS之后，该CTS不是我所请求所获得的，或者说，该CTS不是对应发给我的CTS。从而STA 1会将CTS数据帧的duration给提出，并设置在自己本地的NAV（Network Allocation Vector）上。若NAV没有倒数到0，那么其会主动悬挂其随机回退计数值，在NAV没有倒数到0之前，其随机回退计数值不再继续倒数。
- 当STA 2接收到CTS后，其发现该其是之前发送RTS的反馈。故节点已知信道空闲，在等待SIFS后，STA 2发送数据。当数据传输完成之后，AP向STA 2反馈ACK，从而最终完成一次传输。

RTS/CTS工作机制对应的时序图如下：

![img](https://pic1.zhimg.com/80/af08da7eb6245fb0ca718462525f2f7c_720w.png)

在上图中，我们可以发现，NAV的部分和我们在CSMA/CA的流程图中的Busy medium是一样的，其区别在于一者是物理载波监听（即之前的Busy medium是由于物理载波监听所引起的），而另者是虚拟载波监听（即NAV是由虚拟载波监听所引起的），在下一节，我们会讨论物理载波监听与虚拟载波监听机制。

在实际的路由器中，RTS/CTS模式不是以开关的形式存在，而是以RTS_threshold的形式存在的。RTS/CTS另外一个思维就是 "**采用小的数据包碰撞，来避免大的数据包碰撞**" ，从而如果数据包太小，那么则不需要采用RTS/CTS机制。设置RTS_threshold的范围一般为2347，其单位是byte，即如果数据包大小如果大于2347 byte，那么才会采用RTS/CTS模式，在现实应用中，可以根据具体的情况，设置一个最适合的值。

*注：在本段中，我们所述RTS/CTS着重解决隐藏终端问题，同时RTS/CTS也是利用小数据包碰撞来避免大数据包碰撞的方法，该方法对于在没有隐藏终端，但是节点数很多的网络中，也时很有效果的。同时，本章节中，我们提到采用RTS/CTS模式来设置NAV，这里需要强调的是，RTS/CTS可以设置NAV，但是NAV不是仅仅只能用RTS/CTS来设置，只要数据帧MAC头部的duration字段有数值，那么就可以设置NAV，该机制在802.11协议中，有非常广泛的应用，比如PCF的Contention Free周期，EDCA中的TXOP机制等。*

## **物理载波监听和虚拟载波监听**

在这一章节，我们讨论物理载波监听和虚拟载波监听机制，两者是在CSMA/CA过程中同时使用的，在《CWNA第一版》一书中，对此有较好的描述：

![img](https://pic2.zhimg.com/80/1f3c731c2ce798d8f5e82c86c494629d_720w.png)

从该图中，我们可以明显看出，物理载波监听和虚拟载波监听是同时执行判断的，其中只要有一个是出于Busy状态，那么就不会触发随机回退计数值减1的过程，换言之，即是挂起了随机回退计数值。从该图中，我们可以明显得知，虚拟载波监听就是对应的NAV机制，而物理载波监听则是对应到了CCA（Clear Channel Assessment）机制。下面我们着重关注物理载波监听的CCA机制：

在CSMA/CA中，CCA由能量检测和载波检测一起完成：

- 能量检测（Energy Detection）：是直接用物理层接收的能量来判断是否有信号进行接入，若信号强度大于ED_threshold，则认为信道是忙，若小于ED_threshold，则认为信道是闲。同时该ED_threshold的设置与发送功率有关，比如发送功率大于100mW，那么ED_threhold约为-80dBm，发送功率在50mW至100mW之间，那么ED_threshold应该为-76dBm。不过至于具体的数值，需要查看其具体所对应版本的802.11协议。
- 载波侦听（Carrier Sense）：载波监听的方法指的是用来识别802.11数据帧的物理层头部（PLCP header）中的preamble部分。简单的说，802.11中的preamble部分采用特定的序列所构造，该序列对于发送方和接收方都是已知的，其用来做帧同步以及符号同步。在实际监听过程中，节点会不断采样信道信号，用其做自相关或者互相关运算，其中自相关在基于OFDM的802.11技术中常用，比如802.11a，而互相关在基于DSSS技术中常用，比如802.11b。与能量检测类似，相关计算值需要与一个阈值进行判断，若大于，则认为检测到了一个信号，若小于则没有检测到。

协议中规定，两种检测方式同时采用，且只要两者检测方式中，有一种判断信道是busy的话，那么就认为信道是busy的，只有两者都认为信道空闲时，那么再判断虚拟载波监听机制是否为0，以上条件都满足时，那么才可以进行backoff倒数。

## **DIFS，SIFS与Slot time**

最后我们浅谈下DIFS，SIFS与Slot time的具体功能。在前面的叙述中，我们使用 **"等待"** 这一词来描述节点在DIFS与SIFS过程中的动作，同时我们描述slot time内持续监听信道。在实际过程中，DIFS与SIFS不是纯粹的等待动作，而slot time也不是整个周期都是监听信道。我们首先谈谈slot time的构造，由于笔者这一部分没有详细翻阅协议，参考一篇论文《WiFi-Nano: Reclaiming WiFi Efficiency Through 800 ns Slots》，其举例一个9us的slot time的组成如下：

![img](https://pic3.zhimg.com/80/28c4c27c1e56b139ff31f6a33ed60366_720w.png)

即Slot time由电磁波传播时延（Propagation），信道检测CCA时间（Clear Channel Assessment）以及天线的发送/接收切换（Rx/Tx Hardware Turnaround）组成。故这里就明确回答了，在一个slot time内不是整个周期都在监听信道，而只有CCA时间这一部分在监听信道。而最后一个天线发送转换也好理解一些，这里我们在说CCA监听信道的过程中，除了为了之前我们所述的backoff过程，实际上节点也在利用CCA来监听，是不是有给我的数据包。如果该数据包不是给我的，那么CCA监听结果就是忙，然后等一个slot以后继续监听。如果监听该数据包是给我的，那么就直接转换到接收状态，而不是继续进行每一个slot监听的动作了。

同时，这里我们之所以将DIFS，SIFS与Slot time放在一起讨论，是由于DIFS = SIFS + 2*Slot time。SIFS的功能我们可以理解成，包含天线发送接收转换，以及上层处理数据所需要的延迟时间。而DIFS中，由于正巧包含了两倍的Slot time，所以很大程度上，在DIFS内，应该执行了两次信道监听过程，但是这两次的监听过程没有触发backoff。只有监听到连续两次信道空闲后，那么DIFS之后才会进行backoff过程，该设计思想应该是源于P坚持-CSMA的，同时，这个思路也是和我们在讨论物理载波监听和虚拟载波监听中的插图所符合的。类似的，在802.11协议中，其他的部分帧间间隔也是基于slot time和SIFS计算所得，比如PIFS = SIFS + SLOT，EIFS = ACK time + SIFS + DIFS。

笔者重新查了下协议，在协议中SIFS和Slot time的组成被定义如下：

aSIFSTime= aRXRFDelay（射频延迟）＋aRXPLCPDelay（物理层头部接收延迟）＋aMACProcessingDelay（MAC层处理延迟） + aRxTxTurnaroundTime（发送接收天线转换时间）

aSlotTime= aCCATime（CCA时间）＋aRxTxTurnaroundTime（发送接收天线转换时间）＋aAirPropagationTime（传播延迟）＋aMACProcessingDelay（MAC层处理延迟）

故基本是和我们之前的描述一样的，细节上还增加了几项，故这里标注一下。

*注：以上就是笔者对于DCF与CSMA/CA的基本理解，大部分内容都是参考笔者前一篇资料总结中所列之参考文献。上述表述中，也许存在一些错误，还请见谅，也有一些细节，并没有在这一篇中展开叙述，有空笔者再继续进行整理。同时，笔者所学有限，若文中出现了的错误的地方，还请指出，谢谢。*

# CSMA/CD与CSMA/CA

## **序言**

在前一份文档中，我们详细记录了有关802.11中DCF模式以及其核心CSMA/CA的一些内容与细节。对比无线网络，有线网络的集线器和中继器设计中，采用了CSMA/CD技术。该技术早期是用来解决有线网络中，共享介质下的多路网络接入问题，该技术仍然在当今的10M/100M半双工网络中使用。在更高的带宽情况下，比如千M网络，则采用全双工技术以代替CSMA/CD。

本文主旨是希望能理清CSMA/CD和CSMA/CA的关系与区别。接下来，我们首先会说明最基础的CSMA协议的工作机制，然后我们说明CSMA/CD的工作机制，最后，对比前一份文档，我们分析CSMA/CD和CSMA/CA的区别。

*注：本文中有关有线网络的理论很多参考自《Ethernet:The Definitive Guide》。*

## **CSMA**

CSMA的全称是Carrier Sense Multiple Access，在笔者的理解中，其更趋向于一种理论研究的随机接入协议，或者说，基于其思想诞生了比如CSMA/CD与CSMA/CA这样的具体协议。CSMA可以分成以下三种：

- 1-persistentes CSMA（1坚持-CSMA）
- 0-persistentes CSMA（0坚持-CSMA）
- p-persistentes CSMA（p坚持-CSMA）

从历史上而言，CSMA实际上是源于aloha协议，为了理清协议的设计思路的脉络关系，我们还是有必要对原始的aloha协议做一个说明。Aloha是为无线工作环境设计的一个协议，其最初的思想很简单：“**一个aloha节点只要有数据的话，该节点就可以立即发送。当该节点数据发送完之后，其需要等待接收方反馈的ACK。若成功接收到ACK之后，那么这一次传输成功。如果没有收到ACK的话，那么这一次传输失败。该aloha节点会认为网络中还存在另外一个aloha节点也在发送数据，所以造成接收方发生了冲突。最后这些冲突的节点会随机选择一个时间进行回退（backoff），以避免下一次冲突。若冲突节点回退完成，其才可以重新进行发送**"。

实际上从初始的aloha协议中，我们就可以看到现在CSMA/CA的影子，网络协议的设计都是符合KISS原则的（Keep It Simple and Stupid），所以实际中我们所应用到的网络协议，其思想都不会是特别复杂。基于aloha协议的思想，CSMA协议对其最大的改进即是引入了LBT机制（Listen Before Talk），在CSMA中的CS（Carrier Sense）即是指Listen监听机制。在LBT机制下CSMA的思想就是：**“CSMA节点在每一次发送之前先监听信道是否是空闲的，如果信道不是空闲的话，那么就不发送数据，等待一会再进行尝试。只有确保是空闲的情况下，才可以发送数据，从而避免打断其他节点正在进行的传输过程"。**

具体CSMA的工作机制关联着我们之前所叙述的三种CSMA模式，以下我们分别进行叙述：

- 1-persistentes CSMA：“**节点需要持续监听信道，一旦节点发现信道空闲后，则立刻发送数据。**”。
- 0-persistentes CSMA：“**节点不连续监听信道，若该时刻节点监听信道为busy，那么等待一段时间后，再次进行监听。若节点该时刻监听信道为空闲，则立刻发送数据。**”
- p-persistentes CSMA：“**节点需要持续监听信道，一旦发现信道空闲后，节点以p的概率立刻发送数据，以1-p的概率不发送数据。若节点该时刻不发送数据，那么等待一段时间后，再次进行监听，并以p概率再次发送**”。（*注：这里所述的p概率可以理解成抛骰子赌大小，如果抛大，那么就发送，反之不发送。其中抛大的概率就是p，而抛小的概率就是1-p*）

在以上三种CSMA机制中，若节点传输发送冲突，则类似aloha的基本算法，随机等待一个时间之后，再次进行重试。以上，我们分析了CSMA的基本工作模式，或者称之为CSMA的基本思想，接下来，我们具体讨论有线网络所应用到的CSMA/CD协议。

## **CSMA/CD**

CSMA/CD的全称是Carrier Sense Multiple Access with Collision Detection，即基于冲突检测的载波监听多路访问技术。CSMA/CD也是最初802.3中的核心，应用在10M/100M的半双工有线网络中，目前CSMA/CD的应用场景少了很多，大部分都直接基于全双工工作。

CSMA/CD从思想上应该是源自于1-坚持CSMA，即1-persistentes CSMA。在其基础上，加入了CD（Collision Detection）的机制。冲突检测，即CD的机制主要是用来发现冲突，并解决冲突的。我们下面描述CSMA/CD的具体工作机制：

“**节点发送数据之前需要持续监听信道，一旦节点发现信道空闲，则立刻发送数据。在发送数据的同时，节点持续监听信道，"探测" 是否有别的节点也在该时刻发送数据。**

**若传输过程中没有检测到别的节点的传输，那么成功传输。在成功传输后，节点需要等待帧间间隔IFG（interframe gap）时间后，可以进行下一次传输。**

**若在传输过程中，探测到别的节点也在传输，那么则检测到冲突。发生冲突后，节点立刻停止当前的传输，并且发送特定的干扰序列（JAM序列），用以加强该次冲突（用以保证其余所有节点都检测到该次冲突），在JAM序列发送完之后，节点随机选择一个时间倒数进行backoff。当backoff完成之后，节点可以尝试再次重传**”。

在上述的描述中，我们可以发现，CSMA/CD和1-坚持CSMA是非常相近的，与传统的aloha相比，CSMA/CD不仅仅添加了LBT的机制，还引入了冲突检测（Collision Detection）机制，用以在传输中立刻发现冲突，而不是依靠ACK的反馈来判断是否有冲突发生，从而提高网络效率。在CSMA中，我们还需要描述一些细节内容：

- **载波检测（CS：carrier sense）**：在有线网络中，载波检测实际上即是接收信道上的信息，并加以解析。用这种方式判断共享信道上有没有节点正在传输信息，从而达到监听（listen）的作用。其中载波检测这个名字实际上是从AM/FM接收中来的，即载波就是携带调制信息的模拟信号，从而载波监听就是对是不是有AM/FM信号进行侦听。
- **冲突检测（CD：collision detection）**：在一些理论中，介绍冲突检测为“发送的同时，接收同一个信道上的数据，并比较发送数据Tx与接收数据Rx”。若Tx=Rx，则没有冲突发生，若Tx≠Rx，则识别到一个冲突。在一些工程介绍中，介绍检测冲突的方法是“介质依赖法”。连接段介质（实际上是电缆）拥有传输和接受数据的独立路径（双绞线中有单独的发送和接受回路），冲突检测是在同一个接收段收发器中，借助同时发生在传输和接收数据路径上的活动来完成的。在同轴电缆介质上，收发器通过检测同轴电缆的DC（即直流信号）信号等级来检测冲突。当两个或者多个基站同时传输时，同轴上的平均DC电压可达到触发同轴收发器中的冲突检测电压等级。同轴收发器连续检测同轴电缆上的平均电压等级，若平均电压等级表明，有多个基站同时传输内容后，其会发送JAM信号到以太网接口处。发送JAM信号的这个过程比冲突检测时间较长，多出的时间包含了根据10Mbps以太网上总信号延迟算出的时间（即包含了JAM信号的传输时间）。
- **时隙与捕获效应**：在有线网络中，捕获效应被定义为1个时隙长度内没有冲突发生，同时时隙被定义为512bit在10Mbps或100Mbps网络的发送时间。在有线网络中选择为512bit作为一个时隙的参考值，是考量了为发送信号到对端的最大往返时间。该最大往返时间包含了电磁波通过物理层的往返时间以及传输JAM信号所花费的时间。（JAM信号是加强冲突的一个通知信号）。若节点已捕获信道，即已发送512bit，那么对方不一定会来打断你当前的传输，1.即确保对方能检测到你，2.并且反馈的JAM信号也能通知到你。同时，若从电磁波传输的角度而言，512bit在10M中传输的时间换算成电磁波能够传播的距离大约是2800米，512bit在100M中传输的时间换算成电磁波传播的距离大约是200米，对比有线网络的双绞线长度（大约100米）而言，这些参数还是可以接受的。在1000Mbps网络以及其上，都是默认物理层采用全双工模式的，若还是采用CSMA/CD的模式，那么这里的时隙长度会被定义为512byte的长度，不过目前这个可能是学术上的用法，而非协议的定稿。
- **重传机制（Backoff与BEB机制）**：若节点检测到冲突发生在前512个字节，即一个时隙内，那么节点首先进行backoff，然后进行重传。这里backoff是采用BEB（二进制指数回退算法），即在一个随机窗口内，选择一个随机数并乘以时隙（time slot）进行回退。在第0~10次回退过程中，每回退一次，随机窗口放大一倍，在第11次到第16次过程中，依然进行回退，并尝试重新发送数据包，但是不放大窗口大小，第17次若失败，则丢包。按照一般情况下，冲突不会发生在512字节以后的部分，即已经发生了捕获效应，即节点已经捕获到了信道。不过比如时间不同步这样的一些情况出现，导致冲突发生在512字节之后，貌似是不进行重传，直接丢包的。

## **CSMA/CD与CSMA/CA**

在综述完CSMA/CD后，对比我们前一次叙述的CSMA/CA，我们总结这两者之间的联系和区别。

- **联系**：CSMA/CD与CSMA/CA机制都从属于CSMA的思路，其核心就是LBT机制，换言之，两个在接入信道之前都需要进行监听。当发现信道空闲后，其才可以进行接入。

- **区别**：

- - **在思想上：**

  - - CSMA/CD是源自于1-坚持CSMA，而CSMA/CA是源自于p-坚持CSMA。即CSMA/CD是持续监听信道，一旦发现信道空闲，则立刻传输。
    - CSMA/CA是边进行backoff回退过程边进行监听，若信道空闲则进行backoff counter倒数，否则挂起随机倒数计数器，不进行backoff counter倒数的工作。只有当backoff counter（即随机倒数计数器）回退至0时，其才可发送数据。

  - **在冲突检测上：**

  - - CSMA/CD中是采用冲突检测+JAM机制，即边发送边监听实时信道状态，可以在传输过程中，实时判断信道中是否有冲突发生，一旦发现了冲突，则发送JAM信号以加强冲突，其余节点也因识别到该JAM信号，从而停止当前传输。若整个过程中，节点都没有发现冲突以及JAM反馈，那么该次传输成功。
    - CSMA/CA是源自于aloha的ACK反馈机制，若接收到对方反馈的ACK后，那么这一次传输成功，否则失败。

  - **在监听机制上**：

  - - 由于CSMA/CD是有线网络，故其监听是直接解调有线介质上的信息，若没有信息，则信道空闲，若存在信息，则信道繁忙。
    - 在CSMA/CA中，不仅引入了物理载波监听与虚拟载波监听这两种技术，同时在物理载波监听中，还分为能量检测（Energy Detection）和载波感知（Carrier sense）。同时该载波感知所指是利用无线帧物理层头部中的固定序列（即preamble），利用已知序列和其做相关运算（自相关或者互相关运算）进行识别。详细的一些内容可以参考上一篇有关DCF和CSMA/CA的文章。

  - **在回退（backoff）机制上**：

  - - 在CSMA/CD中，回退只有在冲突之后才会发生，节点选择选择一个随机时间进行回退，该随机事件具体是时隙乘以回退窗口内的一个随机数。其中为了避免多次冲突的问题，在每一次冲突后，节点的回退窗口也会执行BEB算法，即将回退窗口进行翻倍。在CSMA/CD中，回退一共可以进行16次，其中，第1~9次存在会对回退窗口进行翻倍，在第10~16次中，窗口大小不变（窗口最大1024），再次重试。第16次若失败，则进行丢包处理。
    - 在CSMA/CA中，节点的每一次传输之前都需要进行backoff过程。在CSMA/CA的backoff过程中，节点会在每一个slot中对信道进行监听（这里包含物理载波监听和虚拟载波监听），若信道监听为空闲，那么进行backoff，即随机倒数计数器减1，若信道监听为信道忙，则挂起该计数器，只有当该计数值为0时，节点才可以发送数据。在CSMA/CA中，若发生冲突后，对竞争窗口（Contention Window）进行BEB操作，在1~6次中，窗口大小翻倍，第6次时，窗口大小不变（窗口最大也是1024），再次重试，若第7次传输失败，则进行丢包处理。

  - **在时隙的定义上：**

  - - 在CSMA/CD中，时隙被定义在一个固定数据片大小在固定速率的媒介上传输的时间，比如在10M/100M网络中，时隙为512位在10M/100M网络下对应传输的延迟。
    - 在CSMA/CA中，时隙中包含三个方面的内容，即传播延迟，信道检测（CCA）以及收发天线转换。时隙时间具体与其对应的802.11协议版本有关，比如802.11b中，时隙即是20us。

  - **在捕获效应的定义上：**

  - - 在CSMA/CD中，捕获效应被定义为节点成功传输1个时隙的数据，从而节点能够确保自己已经捕获了信道，其余节点也都已感知到了这点，从而确保不会有冲突发生。
    - 在CSMA/CA中，捕获效应是指由于信号功率的不同，比如有两个节点同时向接收方发送数据，其中一者信号强度大（即SNR大），一者信号强度小（即SNR小）。在这种情况下，若信号较好的SNR能够达到解调其数据所需最低的SNR阈值的话，那么其是可以解调，即这次传输可以是成功的。直观的理解，我们可以认为一个大嗓门和一个小嗓门同时说话，那么我们是可以听清楚大嗓门的。

以上是总结的一些笔者理解CSMA/CA和CSMA/CD的区别，其他还存在的一些区别，比如在802.11DCF模式中所采用的RTS/CTS机制，在有线网中就不存在或者对应存在区别，在此就不再一一赘述了。

*注：在上述的讨论中，有线网络的部分知识主要是源于《Ethernet:The Definitive Guide》，而无线网络的部分主要来源于笔者的研究经历，在无线网络中，也有想要实现类似于有线网络的CSMA/CN的工作机制，笔者的一部分工作也是来源于此，有兴趣可以自行阅读。以上讨论中，如果存在错误，还请见谅。*

# PCF工作模式

## **序言**

在前面我们叙述过，在802.11的MAC层中，分成了两种基本工作模式：

- DCF（Distributed Coordination Function）
- PCF（Point Coordination Function）

我们已经介绍过了DCF的工作模式，而PCF模式当前只有协议中进行了规范，而在实际产品中几乎很少见到。所以就像在802.11权威指南和CWNA书本中所述一样，对于PCF的机制仅仅是协议规定，而几乎没有产品，所以纯粹对协议希望有深入了解的话，那么才需要对此进行阅读。这里仅仅是将笔者读协议以及相关资料中，所理解的PCF工作模式进行整理。

## **PCF简介**

PCF的全称是Point Coordination Function，即点协调工作模式。在802.11的MAC层协议结构中，PCF是基于DCF之上的协议，同样的还包含EDCA和HCCA两种模式，后两种主要是为了QOS进行设计的，具体如下图

![img](https://pic3.zhimg.com/80/777603cc6b64392a7b73d8af9e0cd8a6_720w.png)

由于PCF是以DCF作为基础扩展的，所以PCF与DCF是可以兼容工作的。在PCF模式中，两者的兼容实际上是基于一种交替工作的机制，即PCF和DCF各占据一段时间，交替进行工作。该交替周期即是CFP重复周期（CFP repetition interval），在该周期内，包含CFP和CP两个部分，如下图

![img](https://pic1.zhimg.com/80/404a7ab9cdc69aebd7de4b4fb774bdbc_720w.png)

- 无竞争时间（CFP）：Contention-Free Period，即CFP时间是为了PCF工作所设定的一段时间。该时间是利用虚拟载波监听（NAV）的机制进行保护的，该NAV是由Beacon帧进行设置，并由CF-END帧用来终止。
- 竞争时间（CP）：Contention Period，该CP时间是用来给DCF工作的一段时间，在该周期内，协议按照DCF的模式进行工作。

这里我们还需要更细一些说明该CFP时间设置的原理。在之前描述DCF模式中，我们基本已经描述了NAV的工作机制，其主要是利用无线数据帧MAC头部中的Duration字段进行设置。在CFP准备启动的时刻，AP首先利用beacon帧设置NAV时间至CFPMaxDuration，其具体设置方案如下：

- 利用数据帧的MAC头部中的Duration字段，设置CFPMaxDuration。标准的Duartion字段共有16个字节[0:15]，其中倒数2个字节，即[14:15]是标志位，且其存放方式应该是属于小端模式的，即后面的是高位，前面的是低位。如果是CFP设置NAV时，对应第14位置0,第15位置1，其余各位都是0。故解析出来，那么NAV的时间即设置为2^15=32768 microsecond。其对应结构如下图：

![img](https://pic3.zhimg.com/80/4a2d7ac9d99c2544cfcf6877666af01a_720w.png)

- 除了利用MAC头部的Duration字段，在CFP对应的beacon帧中，还有一个CF Parameter Set字段。利用该字段中的CFP MaxDuration，也同样设置该参数。在802.11中设置两次CFPMaxDuration参数的原因在于，是在于避免无法识别CF Parameter Set字段的节点，只要其能识别标准MAC头部的Duration字段，那么其也会被置为NAV状态，从而无法争夺信道的使用权。

![img](https://pic3.zhimg.com/80/fe710d86e66690a09be2c6ed8867f6b2_720w.png)

由于这里NAV是被设置为最大时间，所以NAV的技术与之前我们描述在DCF的RTS/CTS模式下存在差别。在DCF中的RTS/CTS模式下，NAV是通过倒数置0，从而释放信道。在PCF模式中，NAV的释放是通过CF-END帧，按照笔者记忆中，中间传递的各个帧中也会重复将NAV置为最大，只有在最后的CF-END中，才会将duration字段写成0，从而结束NAV时间，换言之，NAV时间的设定是可以被覆盖的。CF-END的帧结构如下：

![img](https://pic2.zhimg.com/80/7553548d6edc1f65a00a294074d4be2d_720w.png)

如上图，CF-END是一个广播帧，其类型是控制帧，子类型是CF-END，而且Duration部分设置为0，其余该帧内没有什么特殊的地方了。

通过以上的机制，PCF能够很好的与DCF进行兼容。在下面的内容中，我们开始解释PCF具体的工作模式。

## **PCF工作模式**

在这一段中，我们叙述PCF的具体工作模式。PCF的主要思想为：”**AP充当中心协调控制器（PC）的角色，根据其内部的轮询表（polling list）依次轮询与之连接的节点（CF-Pollable STA），看其是否有数据待传。在CFP时间内，节点由于NAV机制，故无法主动竞争信道。故除非基站轮询节点，要求其反馈数据，节点不可以主动进行传输动作。**“

在上述描述中，已经包含了，在PCF中的两个新的角色：

- PC（point coordinator）：即点协调器，一般情况下，都是由AP做点控制器。
- CF-Pollable STA：支持PCF机制的节点。

在PC身上，我们还会引入轮询表（polling list）的概念。在PCF中，PC按照轮询表的顺序，按照升序，依次对节点进行轮询。在免竞争期间，除非基站以轮询帧提出要求，否则工作站不得进行传输数据。轮询具体会采用CF-POLL帧来执行，节点接收到CF-POLL之后，向PC反馈数据。在标准的PCF中，一次CF-POLL只会反馈一个数据帧。只有在启用APSD（Automatic Power Save Delivery）的设计下，才会使用其他的请求方式（Trigger Frame），才会一次请求，反馈多个数据帧，不过这里由于我们没有讨论节能方面的内容，故不展开讨论。

并且在PCF中，还会引入多种新的帧结构，比如前面叙述中出现的CF-END，在PCF中还存在其余的各种帧如下：

- 仅PC发送：Data＋CF-Poll、Data＋CF-ACK＋CF-Poll、CF-Poll 和CF-ACK＋CF-Poll
- PC与CF-Pollable STA发送：Data、Data＋CF-ACK、Null和CF-ACK

接下来，我们还是假设讨论与DCF同样的拓扑，并且在该PCF讨论中，我们同时关注上下行流：

![img](https://pic4.zhimg.com/80/82bc839661f16c0d0e783459fc13d56f_720w.png)

由于PCF不同种帧类型其功能会有一些不同，为了说明清楚，我们选取几个典型的工作流程，进行具体的示例说明，其余的一些工作流程可以类比得出。

- **CF-Poll -> Data -> CF-ACK工作流程**

![img](https://pic1.zhimg.com/80/885ed0c706e60e0f552e085912afc010_720w.png)

1. 首先AP发送Beacon，利用其中的duration参数，将所有节点设置成NAV状态。（*PS：在CFP时间的设置上，前面我们描述过，也可以利用beacon帧中的CF Parameter Set，这里为了描述的方便，所以就不再强调了，还请见谅*）
2. AP本地没有发往节点STA1的缓存数据，故AP直接发送CF-Poll，让节点可以上传数据。
3. 节点发送DATA给AP。
4. 最后AP反馈CF-ACK给节点，从而结束一次传输轮询。

上图是最简单的请求反馈过程，除了首先是由AP触发这次传输以外，其余基本和DCF的工作是相同的。这里我们还需要注意的是，若AP成功接收了Data，那么其反馈ACK信息。若AP没有成功接受节点的DATA，那么可能会出现两种情况：

- STA1向AP反馈DATA过程中发生错误，从而DATA无法通过CRC校验。这个情况下，AP不会反馈CF-ACK，直接轮询下一个节点STA2。
- AP向STA1发送CF-Poll帧的过程中发生错误，从而STA1根本就不知道AP有要求自己反馈上行数据，从而STA1是不会主动反馈数据的。在该情况下，AP会等待PIFS时间，若PIFS时间内，没有检测到节点存在反馈，那么AP就认为这次传输失败，跳过该节点，继续轮询下一个节点，具体如下图：

![img](https://pic2.zhimg.com/80/48fcca57fcf61f7b9af51bdd20f01a5d_720w.png)

PIFS的时间实际上是由一个SIFS和一个SLOT组成，即PIFS=SIFS+SLOT。结合我们在DCF部分论述Slot和SIFS具体组成的内容，这里之所以PIFS这样设计，实际上是利用Slot里面的CCA机制，AP利用该CCA判断是不是存在反馈帧，若存在反馈帧，那么就进行接收。这里并没有采用DCF中的ACK timeout的简单机制来判断是否反馈，而是具体采用这种CCA检测的具体机制，是除了这里反馈CF-ACK以外，还有可能反馈其他类型的帧，比如CF-ACK +CF-Poll等，具体内容我们在后面进行叙述。

- **DATA+CF-Poll -> Data+CF-ACK -> CF-ACK工作流程**

![img](https://pic1.zhimg.com/80/cf0cf4365d9ea33e5d842824a2a5c69c_720w.png)

第二种情况较为复杂一些，我们先描述其时序图：

1. 首先AP发送Beacon，利用其中的duration参数，将所有节点设置成NAV状态。
2. AP本地存在发往节点STA1的缓存数据，故AP将自己的DATA以及CF-Poll同时发送，让节点在接收数据后，可以上传数据。
3. 节点发送DATA+CF-ACK给AP，其意在首先确认之前AP发送的下行数据，再反馈自身的数据给AP。
4. 最后AP反馈CF-ACK给节点，从而结束一次传输轮询。

我们现在讨论上面工作机制的一些细节内容。

- 首先叙述AP缓存节点数据的机制，在PCF模式以及节能模式下，缓存机制都会被有效利用起来，这里的缓存是指公网发往节点的信息，由于没有及时传给节点，从而缓存在AP身上。该缓存信息在每一个beacon周期内，也会在其TIM字段内利用Bitmap信息进行标识。Bitmap是一种映射的数据结构，其中每一个位就代表一个节点，即每一位都是和节点的二层地址进行关联。若该位为1时，那么代表该节点存在缓存数据，若为0，那么对应没有缓存数据。故节点在接收到beacon帧后，就知道在这个周期内，我会不会收到来自与AP的数据。
- 其次我们需要强调的是，这里的DATA+CF-Poll是一个帧，不是分别的两份帧。这里实际上是对应到一种特殊类型的帧，这里不同帧的类型实际上是通过在MAC头部第一个字段Frame control下的两个字段：Type和SubType组成的，如下图

![img](https://pic3.zhimg.com/80/004d709169ba2fb6d4209ded26beb836_720w.png)

我们总结在PCF中，type有关的具体相应参数如下：

![img](https://pic1.zhimg.com/80/1530f7728b944da9fc65ccce7b3416a4_720w.png)

注：CF-ACK与标准的ACK帧不同，标准的ACK为控制帧，而CF-ACK为数据帧。

- 最后我们需要理解，为什么在PCF这里协议选择用一个帧的功能来代替分别传输两个帧，其主要原因就是节省时间，这里不仅仅节约了额外帧交换中需要等待的SIFS时间，也减少了单独传输帧所花费的时间。比如说对比DCF中执行类似DATA+CF-Poll这样的发送流程，其发送大致为DATA+SIFS+ACK+CF-Poll+SIFS+DATA+ACK这么长的流程才可以完成，而采用合成帧的形式，那么就简单很多，并且对性能有好的提升。



- **CF-Poll -> Data -> CF-Poll + CF-ACK -> Data 工作流程**

![img](https://pic1.zhimg.com/80/8656289a6a0c66cd8d55276f7ba6cc40_720w.png)

在了解前面的内容之后，我们描述另外一种合成的帧，CF-Poll+CF-ACK帧，还是首先描述其工作流程：

1. 首先AP发送Beacon，利用其中的duration参数，将所有节点设置成NAV状态。
2. AP通过CF-Poll请求节点STA1，让STA1可以上传数据。
3. 节点STA1发送DATA给AP。
4. AP发送CF-Poll+CF-ACK，其中CF-ACK是发给STA1用以确认其发送的数据，CF-Poll是用来请求下一个节点发送数据，即发给STA用以请求数据。
5. 节点STA2反馈数据给AP。之后的工作流程我们这里省略。

大体上和之前的工作模式是类似的，唯一区别的是CF-Poll+CF-ACK帧，该帧既是发送给STA用来做CF-ACK确认，又是发送给STA2用以请求数据，而我们知道802.11帧的目的地址只有一个，所以这里是存在疑惑的，目前还没有在协议中发现具体描述这种帧结构的部分，目前猜想应该是类似CF-END+CF-ACK帧的结构：

![img](https://pic4.zhimg.com/80/8e97d57b8c90ff3d6c8a3f54ade2b893_720w.png)

在无线帧中，ACK帧是没有源地址，只有目的地址的，这点ACK和CTS同样。而在上图所示结构中，除了在ACK中存在的RA（Receive address）地址，还存在额外的一个BSSID地址。故我们初步猜测是，RA是用来作为ACK反馈的目标地址，在我们所示流程中，即为STA1的地址。而用来作为CF-Poll请求的目的地址可能是放在BSSID这个位置中，标准的BSSID是用来表示AP相应的地址（即SSID具体对应的BSSID地址），但是这里由于目的地是一个节点，故在CF-Poll+CF-ACK帧中，这里也许就是放的Polling的目的地址。即这里猜想在CF-Poll+CF-ACK这个帧中，该处还是一个地址，不过不是BSSID，而是Polling的目的地址。从而才可以利用一个帧，同时向两个节点传达目的。

- **CF-END与CF-END+CF-ACK**

在PCF的无竞争周期最后，是利用CF-END帧来作为终止信息的。其中CF-END也有两种可能性，即CF-END和CF-END+CF-ACK。同时，由于其可以终止CFP时间的特性，故协议中，这两种帧的类型都被定义为控制帧，与其余的PCF帧存在一定的区别。由于在该帧中的duration字段设置为0，并且这是一个广播帧。当所有节点接收到该帧后，修改自己的NAV时间为0，从而即是结束利用虚拟载波监听NAV机制所保护的无竞争时间，转入竞争接入状态。具体该帧结构如下：

![img](https://pic1.zhimg.com/80/3976671e7010ebe4330c1a2351a0ea68_720w.png)

其中Duration字段为0，RA字段为广播地址，而BSSID字段为AP上SSID所对应的BSSID地址。CF-END和CF-END+CF-ACK帧结构一样。

综上所述，我们阐述了有关PCF工作模式中，具有典型意义的几个工作流程，由于PCF的帧类型总数较多，所以能组合成多种不同的具体工作流程，所以我们就完整列举了。其余的情况应该都可以基于以上几个典型的情况进行类比。由于PCF的整理还是较为繁杂，所以难免会存在不清楚的地方。以上叙述中，如果有不清楚，或者存在有错误的地方，还请见谅。

# 隐藏终端和暴露终端

## **序言**

在无线通信中，有两个典型的问题，即隐藏终端和暴露终端问题。在802.11中，这些问题也是存在，同时也衍生出了一些新类型的隐藏和暴露终端问题。在前面描述DCF模式中，我们已经谈论了的隐藏终端问题。

实际上，隐藏终端和暴露终端都是由于CSMA/CA中所采用的LBT机制所引起。隐藏终端是由于监听到的信道空闲而不是真的空闲，故引发冲突。而暴露终端是由于监听到的信道忙而不是真的忙，故其可以传输而不传输。

在这里，综合之前的论述，我们对一般性的隐藏终端和暴露终端做一个简单的整理。

## **隐藏终端问题**

![img](https://pic4.zhimg.com/80/963bf6b1ac0d5501cf81f0918a113d67_720w.png)

隐藏终端问题可以简单定义为：**节点之间无法互相监听对方。但当其不可以同时传输时，其同时传输，从而导致冲突发生。隐藏终端在单个AP（或者单个Receiver）时就有可能发生。**

我们基于以上拓扑讨论基本的隐藏终端问题，在该拓扑中，STA 1与STA 2为两个节点，这两个节点都是关联在AP身上。图中蓝色虚线代表STA 1的发送范围，绿色虚线代表STA 2的发送范围。

由于图中STA 1与STA 2发送范围无法互相覆盖，即无法通过物理载波监听的方法，探测对方是否有发送数据。从而STA 1与STA 2可能会误以为信道空闲，从而同时发送，继而造成冲突。



![img](https://pic3.zhimg.com/80/ec3c65081032553d2c6bc724a9ff8fa6_720w.png)

如上图所述，根据DCF中CSMA/CA的工作机制，STA 1与STA 2在等待DIFS之后，分别选取一个随机数进行Backoff。STA 2由于随机数选择较少，从而首先倒数至0，并发送数据。当STA 2发送数据后，由于STA 1监听不到STA 2已经占用信道，其依旧误以为信道是空闲的，从而继续进行backoff。当STA 1的随机回退计数值倒数至0时，STA 1也会发送数据。

由于STA 1与STA 2的同时发送，即AP接收时存在重叠区域，即也是发生了冲突，最终这一轮传输失败。当这一轮传输失败之后，STA 1与STA 2采用BEB算法重新选择随机数进行回退，但后续过程中两者依旧无法互相监听，所以很容易再次出现同时传输的现象。在隐藏终端的情况下，网络是近似瘫痪的，换言之，STA 1与STA 2的吞吐量都趋近于0。

PS：除了RTS/CTS模式是在协议层面解决隐藏终端问题，实际情况下还有很多解决隐藏终端的问题，比如增加客户端功率，消除中间的障碍物，将造成隐藏终端问题的节点或者AP移动个位置之类的，实在不行的话，那么控制下原始AP的功率，再添加入一个新的接入点也行，不过最后个方法需要小心一些，因为搞不好会引起下面所述的暴露终端问题。

## **暴露终端问题**

暴露终端问题可以简单定义为：**节点之间能够互相监听对方。但其可以同时传输时，其不传输，从而造成浪费。暴露终端在多个AP（或者多个Receiver）时才有可能发生。**



![img](https://pic4.zhimg.com/80/9ea9c3f9db8cc2eef466de2eecb45787_720w.png)


我们基于以上拓扑讨论基本的隐藏终端问题，在该拓扑中，STA 1与STA 2为两个节点，其中STA 1关联在AP1上，STA 2关联在AP2上。图中蓝色虚线代表STA 1的发送范围，绿色虚线代表STA 2的发送范围。

图中AP1处于STA 1的覆盖范围内，而不再STA 2的覆盖范围内。AP2处于STA 2的覆盖范围，而不在STA 1的覆盖范围内。换言之，AP1只能接受到STA 1的数据，AP2也只能接收到STA 2的数据。当STA 1与STA 2同时发送时，接受节点AP1或者AP2处均不会发生冲突，故其是可以同时传输的。但是由于这样的拓扑特殊性以及DCF中CSMA/CA的工作机制，造成STA 1与STA 2无法同时传输，该问题则是暴露终端问题。

在CSMA/CA中，接入是遵守LBT（Listen Before Talk）机制的。我们在DCF的介绍中所述，每一个节点在接入信道之前需要进行backoff。在该过程内，若信道空闲，则每经过1个slot，随机倒数计数器进行一次倒数。若信道非空闲，则节点不会对随机倒数计数器进行倒数，并对其进行悬挂。只有当其倒数至0时，才可以发起传输。其中信道空闲与否是通过载波监听机制进行判断的，而在DCF中，存在物理载波监听和虚拟载波监听两种模式，这两种监听方式都有可能引起暴露终端问题，以下我们分两种情况进行讨论。（有关DCF的接入过程，详细内容请查阅之前的文档）

- **物理载波监听引起的暴露终端**



![img](https://pic2.zhimg.com/80/08d8409c470363a52371efb3b790bc6d_720w.png)

如上图所示，由于STA 1与STA 2可以互相监听。由于STA 2选择了较小的随机数进行倒数，从而其最先倒数至0，并进行发送。当STA 2首先发送数据包给STA 2后，STA 1监听信道为忙状态，从而无法发送信息。故根据拓扑而言，STA 1是可以传数据给AP1的，但是由于监听STA 2正在传输，导致信道忙，故STA1悬挂随机倒数计数器，无法继续倒数，从而无法传输。

这里实际上我们还可以更深入了解一下，实际上STA1为什么需要在别人传输的时候，悬挂自己的随机倒数计数器。在CSMA/CD中，实际上是没有悬挂过程的，只有在CSMA/CA中才存在。在CSMA/CD中，若信道忙，节点就不停的去监听信道，一旦发现空闲就传输。而在CSMA/CA中，节点在中间实际上不是监听信道，而是接收数据。其主要原因在于，STA 1在检测到STA 2正在传输造成信道忙时，其立刻开始接收该STA 2的数据，因为STA 1不知道该数据是否是发给自己的。只有当完整接收数据，CRC校验通过后，STA 1才可以检查帧MAC头部所对应的目的BSSID地址，看是否是自己的数据包，若不是才可以丢包。换言之，CSMA/CA中，悬挂实际上是为了接收，从而导致的现象是悬挂而已。

- **虚拟载波监听引起的暴露终端**





![img](https://pic2.zhimg.com/80/4c54619ebf62ea3e20b113b0f7dc18e5_720w.png)

如上图所示，在暴露终端场景中，若STA 2不仅选择了较小的随机数进行优先倒数，并且其发送的数据包是RTS数据包。当STA 1识别到该RTS数据包后，其就会被设置为NAV状态，无法在后面的过程主动竞争信道，进而无法传输。与之前描述用RTS/CTS解决隐藏终端问题时不同，在解决隐藏终端问题中，NAV是由AP所反馈的CTS帧所进行保护。而这里由于STA 1与STA 2能够互相监听，换言之，在暴露终端情况下，STA 1的NAV是被STA 2所发送的RTS帧进行保护的。在STA 1被NAV保护后，其也无法传输，最终导致暴露终端问题。

# 802.11b的发送过程与接收过程

## **序言**

802.11目前都还是属于一个半双工的协议版本，所以在其设计接入过程时，不仅仅要考虑避免由于共享信道造成的冲突问题，同时也要考虑发送和接收的切换问题。在基本的两种工作模式：DCF与PCF中，PCF是采用AP中心控制的方法，只有当AP去polling节点的时候，节点才会变成发送状态，否则节点都是出于接收状态，而DCF模式中，由于节点能够主动竞争信道，那么发送和接收的切换则变得较为复杂。参考IEEE 802.11 Tutorial（Mustafa Ergen），我们对这一块进行整理。在该资料中，整理了802.11b和802.11a两种工作模式，前者是基于DSSS的，后者是基于OFDM的，对于802.11n/ac以及其他的新协议，这一块过程上应该是更复杂一些，但是这份整理中还未涉及。我们这里首先整理802.11b工作模式下的相关内容。

## **802.11b：物理层头部**

为了理解802.11b中的发送和接收过程，我们首先需要对其物理层的头部进行一定的理解。在802.11b的物理层头部前面有两个部分，一个PLCP preamble，一个PLCP header。如下图（图参考自泰克的文档）

![img](https://pic1.zhimg.com/80/9b20696aa9cdb99e873b15d4f65ea2cc_720w.png)

其各个部分对应的功能如下：

![img](https://pic4.zhimg.com/80/b29ca6638516a14314348c57f8f4fb87_720w.png)

其中前置码（preamble）是采用最低速率进行发送的，也就是DSSS 1M，对应barker码的最低速率。Header部分也是用最低速率，或者次低速率进行发送的。sync是用来做帧同步的，SFD是用来找数据帧起始的。然后header里面是具体的一些设置。其具体的结构可以进一步展开：

![img](https://pic4.zhimg.com/80/87ecc6dfe12a3c29804821cf572adca3_720w.png)

在802.11b的物理层头部最先是preamble部分，在preamble部分包含两个部分，sync和SFD，其中sync是用来做帧同步的，也就是发现信道中有没有数据帧，SFD是作为帧起始标识的。

在sync中有分为长和短两个部分，一般也直接成为长preamble和短preamble。其中长preamble是用作在覆盖范围较大（速率较低）的模式下，短preamble是用来覆盖范围较小（速率较高）的模式下。sync如果是长训练序列全部填充为逻辑1，并且由于底层是DSSS 1M的，换言之这些逻辑1都需要经过11位barker码的扰码的。如果sync是短训练字段的话，那么填充为逻辑0，也经过相同的扰码处理，这里一个采用逻辑1和逻辑0也是为了避免冲突。SFD部分是0000 0101 1100 1111，一旦识别到这个序列，就代表发现了一个数据帧。

在802.11b的PLCP header部分，主要是做一些传输参数设置的。第一位是signal位，该位主要是告知payload的传输速率的，其中在802.11b一共只有4个速率，而且我们关注到，这里一共有8位，也就一共可以表明2^8个速率，但是实际中很多位是没有使用的。第二个专注长度位，即length，这里的单位是us，是payload传输的时间，这里的长度是采用16位的无符号整形。后面那个CRC位是用作校验位的，用来判断物理头部有没有错误。最后剩下来的就是Service位，其全称是HR配置位。这里的HR指的是High Rate，原因是由于最开始的802.11协议即是基于DSSS/FHSS技术的，而802.11b实际上也是基于同样的技术，但是由于其扩频码以及调制技术之类得到的升级，同时为了与传统的802.11协议做区别，所以命名即为802.11b HR/DSSS模式。其余还有一些内容可以参考（[有关802.11b物理头：整体结构](https://link.zhihu.com/?target=http%3A//blog.csdn.net/rs_network/article/details/50512177)，[有关802.11b物理头：preamble部分](https://link.zhihu.com/?target=http%3A//blog.csdn.net/rs_network/article/details/50512252)，[有关802.11b物理头：Header部分](https://link.zhihu.com/?target=http%3A//blog.csdn.net/rs_network/article/details/50512618)）。接下来我们描述具体的802.11b中的发送和接收过程。

## **802.11b：发送过程**

![img](https://pic3.zhimg.com/80/0619b5a455fd682d69bf72df3c603abe_720w.png)

上图描述了802.11b的发送过程，左边一部分是描述帧的各个部分与状态机的对应关系，中间主要是发送模式下，各个状态的转移过程，右边描述是PHY与MAC层的交互过程。接下来，我们按序描述一次发送过程：

1. 初始状态是Rx（接收状态）。若MAC通过PHY_TXSTART.req方法对PHY进行通知，则STA从RX状态转移至Tx Init状态，代表有数据需要被发送。在DSSS模式下，参数TXVECTOR，一般包含了（LENGTH，DATATRATE，SERVICE，TXPWR_LEVEL）这4个具体的变量值，主要是设定数据的长度，速率，扰码的初始化序列，以及发送功率这些，这里先不展开了。若没有MAC层下发的通知，则节点还保持在Rx状态，代表没有上层数据的情况下，节点进行数据的发送。同时这里需要注意的是，我们在DCF竞争过程中，提到节点在不停的监听信道，只有信道空闲的时候，才会进行发送数据，所以Rx模式的状态转移到自己，也存在这样的一种情况，即不停的尝试接收。
2. 当状态切换为了Tx Init状态后，PHY层会向MAC层反馈PHY_TXSTART.conf（这个conf指的不是配置，而是确认，所以在协议中目前是采用PHY_TXSTART.confirm这种表述，避免歧义）。这里可以注意到，Tx Init状态下面可以转移到两个状态，一个是Encode Pream.状态，一个是TxRx Switch状态。我们关注后者，即在该图表述中，在发送过程中任何一个状态都有可能因为接受到MAC层发送过来的PHY_TXEND.req信息，直接转换到TxRx Switch状态，无论发送过程是否完全结束，所以在后续的几个状态下，都可以直接切换到TxRx Switch状态，该TxRx Switch可能是一个逻辑开关，也可能是一个物理的射频天线开关，这里节点目前是发送状态，即天线是可以发送的，一旦进行天线切换，那么就转换为接收状态了。
3. 接下来，STA会转换到Encode Pream.（对应左图红色SYNC和绿色SFD这两个部分）以及Encode PLCP Hdr.（对应左图紫色PLCP Hdr.这个部分）。这两个步骤实际上都是在封装PHY层的头部，即PLCP Preamble以及PLCP Header。这一块内容在一开始的802.11b物理层头部部分，我们已经加以了叙述。
4. 当PHY层的header部分封装好了之后，MAC层会向PHY层发送PHY_DATA.req，用来向PHY层传递数据，并通过物理层进行发送（在上图中，这一块是画在Encode Pream.的后面，但是根据笔者理解协议中的顺序，感觉是在数据包开始的部分才是）。最后上层通过PHY_TXEND告知PHY层数据结束，从而正确转移至TxRx Switch状态，最终完成传输后，转换为Rx接收状态。

![img](https://pic1.zhimg.com/80/5ae75bcac94c1951644fa629d6867c64_720w.png)

*PS：这里我们基本就按照IEEE 802.11 Tutorial（Mustafa Ergen）这一份材料进行描述，在原协议中，一般是采用上图这种上下层交互的模式（上图在07版协议542页），以及流程图来描述一些具体的过程，虽然较为严谨，但是不是很直观，所以还是这一份材料直观一些。所以需要对细节还需要更深入研究的话，那么还是读原协议好一些，这里很多内容都进行了简化和省略了。*

## **802.11b**：**接收过程**

![img](https://pic1.zhimg.com/80/bdb973cdfb9d1e0a24d714bec41b31f0_720w.png)

上图描述了802.11b的接收过程，图中三部分的含义和之前一样。接收状态较为复杂，需要综合我们在DCF那一块描述的载波监听的环节进行综合理解。以下我们按序进行叙述：

1. 初始状态是Rx（接收状态），这里并没有直接画出来，是由于节点如果不是在Tx状态时，默认就是保持在Rx状态。在Rx状态里面，节点所做的第一个动作主要是为了载波监听CCA，上图中，为了简化并没有包含虚拟载波监听的部分，这里我们也不进行扩展。在DCF那一块描述中，我们所述CCA包含了两个部分，ED（能量检测）和CS（载波侦听），在上图中，节点首先进行能量检测，判断能量是否大于一个预设的PMD_ED.indicate（即图中的PMD_ED.ind），初始的信道状态是通过右边的PHY_CCA.ind预设为idle，即空闲的。
2. 在通过能量检测判断信道是否空闲后，即ED转移到CS的状态后，PHY层需要采用载波侦听CS的方式，检测是否是一个802.11帧，因为如果外界干扰较大，那么能量检测也会发现信道是忙的。载波侦听在802.11b中主要是通过互相关的方式，判断对preamble相关的结果是不是大于一个给定的阈值，如果相关找到一个峰值的话（即图上的peak(s) found），那么通过PMD_CS.ind这个参数触发寻找SFD的状态，在802.11b中，SFD的意思和有线网络中SFD的意思基本一致，都是一个特定序列用以标识数据包的起始部分。如果检测不到SFD的话，PHY会转移到RSSI Monitor状态，直到其检测的RSSI小于给定阈值的时候才会回到初始的ED状态（该RSSI是通过ED获取的，即这里就是检测不到帧，但是信道上有能量），在这一个过程中，PHY层向MAC层传输的PHY_CCA.ind都是出于busy状态，只有既没有检测的CS的peak，也没有存在RSSI大于阈值的情况下，PHY才会转移为ED状态，并反馈上层信道是idle状态，只有在idle状态下，STA才可以进行发送。上述的两个部分对应左图的红色和绿色，SYNC和SFD的部分。
3. 当SFD状态完成之后，即STA已经识别到有一个数据帧正在发送了。这时候，节点首先接收数据帧的PLCP Header部分，并且首先对其进行CRC校验。在PLCP Header部分包含了后续接收数据所需要的一些信息，比如包长度以及传输速率这些参数，所以如果header部分接收错误的话，那么后续进行是没有必要进行接收的（换言之是不知道怎么解析），所以首先要对PLCP Header部分进行CRC确认，如果失败的话，则判断信道是否空闲回归之前的步骤。如果成功的话，那么就对这些参数进行匹配，并通过PHY_RXSTART.ind对上层进行反馈，告知MAC层有一个数据包正在接收中。这里还存在一个问题是，PHY层需要判断发送过来数据包的速率是否是本地可以支持的，因为速率如果太高可能无法解调（这里目前的协议中这个问题基本不存在，STA都是全速率支持的，早期版本可能会存在这个问题），如果无法达到所需求的速率，节点也是不进行接收的。这一部分对应左图中，紫色，PLCP Header的部分。
4. 当上述都满足条件后，最终节点对数据进行接收，即状态Data Decode，当接收完数据之后，向上层反馈PHY_RXEND.ind，这一部分对应左图中蓝色Data部分。

# 802.11a/g的发送过程与接收过程

## **序言**

我们之前描述了802.11b的发送和接收过程，802.11b是基于DSSS模式下的，这一篇我们关注下基于OFDM的802.11a/g的发送和接收过程。同样主要是参考IEEE 802.11 Tutorial（Mustafa Ergen），我们对这一块进行整理。对于802.11n/ac以及其他的新协议，这一块过程上应该是更复杂一些，但是这份整理中还未涉及，所以整理中并未包含。

## **802.11a/g：物理层头部**

为了理解802.11a/g中的发送和接收过程，我们首先需要对其物理层的头部进行一定的理解。相比802.11b的物理层头部，802.11a/g较为复杂一些。在802.11a/g的物理层头部前面有三个部分，一个STF，一个LTF，还有一个SIGNAL，即短训练字段和长训练字段以及一些具体的设置，如下图（图参考自泰克的文档）

![img](https://pic4.zhimg.com/80/7de4c6efa8488f9b4fa10fdfd20d7f2f_720w.png)

*PS：这里需要指出的是在802.11a/g中，整个物理层头部都叫做preamble，与802.11b中的PLCP Preamble的概念不同，这里就对于PLCP和PMD子层有非常明确的分界，所以还需要注意一下。*
其各个部分对应的功能如下：

![img](https://pic1.zhimg.com/80/f0b2d33d9b1598c2505d2508efadfb5c_720w.png)

在协议原版中，对这一块有更细致的描述，如下图（07版协议第600页）

![img](https://pic3.zhimg.com/80/36dc23c0c546c54ba73ba296b588b1d2_720w.png)

在802.11a/g的物理层头部中，第一个部分为STF（Short Training Field），STF主要是由10个短的symbol组成（t1~t10），其每一个symbol是0.8us，其包含了很多个功能，其中t1-t7主要是包含Signal Detect，AGC，Diversity Selection，t8-t10主要是包含Coarse Freq，Offset Estimation，Timing Synchronize，其中部分内容我们不进行展开了，一般情况下，我们认为STF主要的两个功能是：

- 帧同步【即判断有没有一个数据帧到达，从而寻找SFD（Start-of-Frame Delimiter）】
- 粗频率同步，这里主要是针对频率偏移所做的一个同步的工作，同时也正好是对应后面的细频率同步的阶段（即LTF阶段）

我们在DCF的部分下，提到CCA中存在一种载波侦听CS的方式，其主要就是基于t1-t10这个部分的自相关或者互相关来完成的，如下图（参考Cambridge.Next Generation Wireless LANs.802.11n and 802.11ac）：

![img](https://pic2.zhimg.com/80/57fd0209e639ea7fb5a1cd900d47df61_720w.png)

横轴是采样点数，纵轴是幅度，这里并没做归一化，这里可以数出来一共有10个尖峰，和这里t1-t10的数量一致，一般识别到一个尖峰后，STA就认为信道里面是有数据帧正在被传输的，从而完成CS的检测。一般情况下，为了避免时延扩展的影响，这里采用自相关的效果会比互相关好一些。同时有关频率估计这一块，由于和本文主旨关联不大，所以不进行展开了。

第二个部分是LTF（Long Training Field），其主要功能是细频率同步和信道估计。从结构上而言，LTF一种是三个部分，1.GI，即保护间隔，用来防止ISI，即符号间干扰。2.两个独立的长训练symbol，T1以及T2。

SIGNAL部分在Preamble的最后一个部分，其结构如下

![img](https://pic1.zhimg.com/80/b4a776199613e6f1601d4f75861e2b38_720w.png)

首先Rate是标识数据包的传输速率的，即采用什么调制方式，编码速率，一般协议中直接所述标识了MCS值（MCS对应不同的速率），这里一种4个bit，实际上可以标识为2^4，16个速率，实际上使用为8个。然后Length位是标识了数据包（具体payload）的长度，这里没有什么特殊的地方，与802.11b的前面不同，802.11b那里是传输数据包的时间，而802.11a/g的情况下是长度。tail位是有个时候为了做FEC的，具体与卷积编码有关，在802.11a/g中，数据包头部和payload是分开来编码的，所以在头部优一个tail部分，payload体中间也有一个tail部分。通常这个部分设置成逻辑“0”。最后是reserved和parity部分，通常情况下，parity是用来做偶数奇偶性校验的。由于这里parity只有1位，所以在噪声比较大的情况下，很容易发生误识别的问题。所以在这一些设计中，把reserved位当做parity的一个扩展。同时，在802.11a/n混合模式中（这里由于802.11n也可以定义在5G频段），这里也有使用reserved位来维护一个协议的后续兼容性，即采用reserved来表示这个是一个802.11n MF Frame（PS：MF即是mixed format）。其余的一些补充可以参考（[有关802.11a/g物理头：Premble结构](https://link.zhihu.com/?target=http%3A//blog.csdn.net/rs_network/article/details/50510262)，[有关802.11a/g物理头：STF部分](https://link.zhihu.com/?target=http%3A//blog.csdn.net/rs_network/article/details/50510365)，[有关802.11a/g物理头：LTF部分](https://link.zhihu.com/?target=http%3A//blog.csdn.net/rs_network/article/details/50511183)，[有关802.11a/g物理头：SIGNAL部分](https://link.zhihu.com/?target=http%3A//blog.csdn.net/rs_network/article/details/50511562)），基于这些预备知识，我们下面描述802.11a/g的发送和接收过程。

## **802.11a/g：发送过程**

![img](https://pic2.zhimg.com/80/6c13d37eaf8fafe18de81ec179f86d31_720w.png)

总体结构上而言，802.11a/g和802.11b的发送过程基本变化不大，有些相同的部分我们会简化一些描述。

1. 初始是Rx状态，若收到上层的PHY_TXSTART.req(TXVECTOR)信息，则PHY层转换到Tx Init状态，在802.11a/g的TXVECTOR和802.11b中基本一致。
2. 当成功转移到Tx Init状态后，下一个状态是Gen. Pream.状态，这一步是用来产生preamble的，不过在该图中，这里主要是完成封装preamble中的STF和LTF两个字段的工作，即对应左图中的红色S1-S10部分，以及绿色pilot1-pilot2部分，由于这份资料较早，故直接采用了pilot这个说法，当前在802.11a/g中，pilot主要指的是用以信道估计的专用导频子载波，LTF也有这样的功能，主要一个是在传输前所使用，一个是在传输中所使用。这里同时PHY会向MAC层反馈PHY_TXSTART.confirm信息。
3. 当转移到Encode SIGNAL状态后，这里是对preamble中的singal字段进行封装，其字段内容在之前我们已经提到过了，所以这里就不展开了，实际上和802.11b中的PLCP Header部分是一致的。
4. 当接收到从MAC层发送过来的PHY_DATA.req之后，PHY转移到Encode Data状态，对数据进行发送，知道上层数据发送完毕，MAC层会传递来PHY_TXEND.req信息，从而PHY层会根据该信息转移至TxRx Switch状态对天线的工作机制进行转换。同时在传输过程中，任何一个状态也都有可能由于收到PHY_TXEND.req信息，而直接转移至TxRx Switch状态，这一点与802.11b中应该一致。若最终发送完成后，转移为Rx状态，并等待下一次传输。

## **802.11a/g：接收过程**

![img](https://pic4.zhimg.com/80/501c7c701ccb7d3e727aae950f832b4b_720w.png)

在802.11a/g的接收过程中，基本结构和802.11b的类似，细节存在一些区别。

1. 在Rx状态下，首先节点还是通过ED和CS的方式判断信道是否空闲，以及有没有对应的数据帧在信道中进行传输。如果CS检测到的话，那么可能就存在一个数据帧，那么需要再次通过FD来确定是不是一个数据帧，我们前面提到过，在802.11a/g中都是以相关的方式检测的，而不像802.11b中是采用SFD的方法检测帧起始部分的，所以在FD检测的时候，会不断的循环检测，知道找到最后一个跳变的位置（即last peak located），那么才检测到一个帧起始。若CS检测失败的话，与802.11b相同，其会根据能量检测判断信道是否空闲，只有信道空闲时，才会转移为ED模式。在Rx状态下，当信道busy时，PHY会向MAC通过PHY_CCA.ind反馈busy，当转移回ED状态时，PHY会向MAC反馈idle。
2. 当FD识别到数据帧起始之后，转移入PMD Est.状态，这个状态貌似不是一个参数，且Est.应该是establish的意思，这里原始协议中没有直接采用过这个词组，而是在句子里面大致这样说过。在PMD Est.状态之后，通过传递PMD_DATA.ind参数，PHY开始处理SINGAL字段，其首先对其进行奇偶校验，这里没有采用802.11b中的CRC的方式，也许是为了简化一些。当解析成功后，提取解调数据所需要的MCS值，数据包大小等相关信息用以对上层数据包进行解析。若奇偶校验失败，则停止这一轮的传输，等待信道空闲后重新开始。
3. 当成功解析到了SIGNAL字段之后，PHY层会对其数据字段的传输速率是否匹配进行判断，如果该速率是支持的话，那么转移至DATA Decode状态。若数据速率不支持的话，那么意味着无法解调，这里由于STA已经通过SIGNAL字段知道的数据包的大小以及传输速率，所以能够计算出数据包传输所需要花费的时间，从而就没有转移至RSSI Monitor状态，而是转移至Wait Frame End状态，等待对方释放信道，类似NAV的工作模式，等待计时为0时，转移回ED状态。
4. 如果SINGAL字段解析成功，且速率匹配的话，那么就正常接收数据包，并反馈给MAC层PHY_RXSTART.ind信息，最终当数据接收完毕之后，反馈给上层PHY_RXEND.ind信息，然后回到初始状态。

# 再论802.11a/g的发送过程与接收过程

## **序言**

我们之前描述了802.11a/g的发送和接收过程，都是基于协议表述上下层的交互机制的角度来描述的，而没有关注物理层获得数据帧之后，如何发送这样一个具体的流程，这一篇我们再对802.11a/g的物理层发送和接收过程进行一些扩展。这里主要是参考《Cambridge.Next Generation Wireless LANs.802.11n》这一本书上面的描述，我们对这一块进行整理。

*PS：目前我们的整理中还在尽量避免一些复杂的公式和表述的方法，希望先以简单的概念和流程先进行整理，至于一些细节部分可能之后有时间在独立整理，所以如果存在细节表述不对的地方，还请见谅。*

## **802.11a/g：OFDM Symbol和OFDM Subcarrier**

为了理解802.11a/g物理层的发送和接收过程，我们首先需要对其物理层的一些基本知识做一些简单的理解。

在802.11a/g协议中，其物理层是采用OFDM技术（Orthogonal Frequency Division Multiplexing），OFDM技术这里我们不做过多的展开，不过为了理解后文，我们需要明白两个概念，即OFDM符号（OFDM Symbol）以及OFDM子载波（OFDM Subcarrier），前者主要是在时域的角度而言，后者则对应频域。

![img](https://pic2.zhimg.com/80/233f33928ea21c2862a051c9695c4a81_720w.png)

首先我们理解下OFDM symbol，如上图蓝色部分所指（该图见07版协议595页，同时红色方框在后文处所用，这里并没有关联），我们可以发现，在802.11a/g中，其最终描述物理层帧的时候，并没有采用bit作为基本单元，而是采用OFDM symbol作为基本单元，这也是我们所需要接受的一个概念，在802.11中，若其信道的带宽固定，比如规定是20MHz的信道带宽，且由于其子载波数也是定值，那么其OFDM symbol的大小也就是固定的了。

我们下面具体以802.11a/g的一个OFDM symbol举例进行解释：

![img](https://pic4.zhimg.com/80/477fb7b83d830fb7ebec0ac04960ece7_720w.png)

上图我们描述了两种OFDM symbol，一种是不带CP（循环前缀），为图中左边部分，该OFDM symbol占时长3.2us，一种是带CP（循环前缀），为图中右边部分，该OFDM symbol占时长4us。图中的蓝色箭头代表发送的样本点，在20MHz信道带宽的情况下，其每0.05us就发送一个样本点，一个OFDM symbol（不包含CP）一共包含了64个样本点，这64也代表着发送和接收过程中，都是以64个点为一个组合，进行一次处理，而不是一个个点单独处理，所以在802.11a/g下，其基本单元都是OFDM symbol，而不是关注一个个采样点。同时为了减少通讯环境的影响，通常会在这64个样本点之前还添加一段CP，该CP是将原来OFDM Symbol的最后一段，复制到该Symbol的头部之前，用来避免由于时延扩展所造成的码间串扰以及载波间干扰（在协议中，CP和GI（Guard Interval）是在同一个位置添加的，我们可以理解成，利用CP来填充GI）。

接着我们需要了解下802.11a/g在频域上所对应子载波的结构。在802.11a/g中，实际上一共有64个子载波，如下图我们具体看下OFDM子载波的结构：

![img](https://pic1.zhimg.com/80/980502c47bedec6bb70346fb03819a90_720w.png)

如上图所示，子载波一共分成4个类型

- Null Subcarrier，图中蓝色的箭头，用来做保护间隔的，没有承载任何数据，在左边（即频率较低的一侧）有6个Null子载波，在右边有5个Null子载波。
- Pilot Subcarrier，图中绿色的箭头，用来估计信道参数并用在具体的数据解调中，承载的是特定的训练序列，一共有4个导频子载波。
- DC Subcarrier，图中黄色的箭头，一般材料里面没有用这个词，这里仅仅是为了描述造了一个词，在子载波中心位置的DC subcarrier一般都是空置不用的，所以这里标识一下。
- Data Subcarrier，图中红色的箭头，用来真实传递数据所用的子载波，在802.11a/g中，这种子载波一共有52个。

![img](https://pic3.zhimg.com/80/48d5e37c90d56878fc79a00aaf1b5fba_720w.png)

最后参考上图（参考《Supporting Real-time Wireless Traffic through a High-Throughput Side Channel》，貌似这张图表述的还不错，至于中间的ener），我们简单描述下以上OFDM Symbol和OFDM Subcarrier的关系，其两者主要是由于IFFT/FFT的机制进行关联的。在802.11a/g的系统中，发送机和接收机处理数据都是按照，64个一组处理一次这样的形式，而这个64个一组能够分辨实际上就是通过OFDM subcarrier这种频域上，各个子载波是正交的形式，所以可以独立并且同时进行处理。而发送机发送只能按照一个个样本点进行按序的发送，若按矩阵进行理解的话，一开始发送机是处理64*1的纵矩阵，一次性处理64个点，然后通过IFFT计算，将这64个点（也就是对应64个子载波）转换为1*64个样本点，这64个样本点就构成了时域上的一个OFDM Symbol，其中每一个样本点都包含了原来64个点的部分信息，只有在接收方接收完这64个点之后，才可以进行一次逆运算（FFT），重新转换为64*1的矩阵进行处理，最后接收方才可以对数据进行正确的接收。有了这些预配知识以后，我们后面开始描述一些物理层的发送和接收过程。

## **802.11a/g：物理层（PHY）的发送过程**

![img](https://pic2.zhimg.com/80/7939aab520b6f2cee754b14f3f063ad5_720w.png)

相比之前描述的802.11a/g的流程，我们接下来描述的内容是当物理层的数据帧中，STF，LTF以及SIGNAL字段都已经封装好之后，接下来物理层发送流程的一些细节。我们用上图来描述一个物理层具体的发送过程：

1. 首先当正式的数据字段从MAC层下到物理帧之后（PLCP Header部分已经处理完了），会被增加三个部分：service，tail以及pad bits（这里可以关注第一部分描述OFDM symbol图中红色方框部分），这里需要注意的是，service字段虽然属于PLCP Header的内容，但是其是在DATA部分以高速率进行发送的，其余tail字段是为了卷积编码所使用的，pad bits是我们所述802.11a/g物理层都是基于OFDM symbol的，所以当symbol中数据字段不够的时候，需要填充空白字段，从而才能够生成OFDM symbol。
2. 在添加完三个部分之后，数据帧需要经过扰码器（Scrambler），扰码器的初始状态是通过service字段获得的，同时service字段实际上是通过MAC层传递下来的TXVECTOR参数获得的，在整个传输过程中，发送机和接收机需要采用相同的扰码序列。
3. 当扰码结束后，依序进行卷积编码（Conv. Encoder，用以增加冗余），用比特组成码元（Group bits into symbols），交织器（Interleaver，用以避免相邻的bit受到相同的频率选择性衰落的影响），然后对数据进行调制并映射到相应的子载波上（Modulator / Mapper），需要注意的是这里一般调制的数据都是复数，按笔者理解这里应该就是IQ相位进行的调制，所以在调制器模块之后，都是并发两个输出指向下一个模块。
4. 在数据部分完成之后，接着是插入4个导频码（Insert Four Pilots），用来在导频子载波上使用。
5. 当准备工作完成之后，进行IFFT变换（IFFT），生成一个OFDM Symbol中的一个个样本点，在802.11a/g中，一共有64个样本点。然后将该64个样本点对应的后1/4（即后面的0.8us），复制到symbol之前，从而构造了一个带CP的OFDM Symbol（Prepend Cyclic Prefix）。
6. 为了满足协议中spectral mask的要求，需要对每一个OFDM Symbol使用脉冲整形函数（Pulse Shaping Filter）进行平滑，以减少频谱旁瓣的干扰，实际上这里可以理解成是添加了一个升余弦滤波器做了一些处理。在《Cambridge.Next Generation Wireless LANs.802.11n》一书中，有给出推荐的整形函数的公式，这里就不展开了。
7. 最后通过DAC生成模拟波形，经过混频，功率放大器PA，最终通过天线发送出去，那么一个发送过程基本就结束了。

*PS：下图是参考《MIMO-OFDM Wireless Communications with MATLAB》一书中，OFDM Symbol经过脉冲整形之后的时域结果，这里只是给出一个直观的感觉，对于参数本文并不展开。*

![img](https://pic3.zhimg.com/80/57bfdae741ee4f9b321b35cc7e5595c2_720w.png)

**802.11a/g：物理层（PHY）的接收过程**

![img](https://pic2.zhimg.com/80/c0ac26ed43df22e37175bbab44289175_720w.png)

对照802.11a/g的发送流程，我们接下来描述对应的接收流程。在上图所描述的接收流程中，STF，LTF以及SIGNAL字段的使用是被包含在内的。

1. 在接收信号一端，信号经过低噪声放大器LNA，混频之后，接收机首先通过STF和LTF字段完成初期的AGC，频率校正（Frequency Correction），以及码元定时校正（Symbol Timing Adjust）的相关功能。同时在数据帧头部的SIGNAL字段中，也提供了上层解调所需要具体的MCS值，数据帧长度等相应信息，上图并未体现，不过这个部分信息也是需要在接收过程初期就需要获得的。
2. 在这之后，对接收序列进行串并转换（Serial to Parallel），实际上可以理解成累积采样点的过程，然后移除每一个OFDM Symbol的保护间隔CP（Remove Guard Interval，这里CP和GI的位置是一致的，协议表述一般为GI），然后进行对这些采样点序列进行FFT变化，转换为频域子载波进行处理。
3. 在FFT之后，利用LTF字段以及导频Pilot的相应信息对OFDM Symbol再一次进行一些细致的处理，包含信道均衡（Channel Equalizer），导频追踪和相位校正（Pilot Tracking & Phase Correction）以及处理一些解码所需要的可靠性的信息（Reliability information for decoder）。
4. 接着要按序进行解映射（Demapper）和解交织（De-Interleaver）的工作，据《Cambridge.Next Generation Wireless LANs.802.11n》一书所言，802.11a系统是采用BICM（Bit Interleaved Coded Modulation）的方式完成解映射，解交织的相应工作，这一块笔者也没有深入看过，故先了解与一下。
5. 当以上的内容处理结束后，数据就需要被进行并串转换，从而从之前的OFDM Symbol，一个个按照一组采样点的处理方式，变成按照数据流的处理方式。然后经过解码获得解调之后的数据流。这里实际上还是存在非常多的细节部分，但是本文并没有对此进行展开，还请见谅，有部分内容扩展到也可以参阅原书。
6. 当解码之后，最后一个步骤是解扰码。接收机通过数据帧中携带的service字段作为解扰器的初始状态，从而一次解扰整个数据流。

*PS：本文主要简单叙述了802.11a/g物理层接收和发送过程的一些流程，因为本文主要关心是物理层发送和接收的总体流程，所以避免了一些具体过程的内容，比如没有过多展开说明OFDM symbol时域和OFDM Subcarrier之间的关系，CP，GI以及64样本点以及FFT/IFFT的关系之类也有点不明确，后续解调的一些细节也一带而过，同时为了简化，部分概念也不是表述很好，可能也有一些错误，导致部分表述存在问题，故还请见谅，有错误还请指出，谢谢。*

# 初探节能模式（PS mode）与缓存机制

## **序言**

由于802.11的协议工作机制，如果其一种处于工作状态下，那么能耗还是比较大的，尤其移动设备的电量有限，所以在802.11协议初期就设计了相应的能耗管理机制，即引入了节能模式。本文我们主要讨论一下其节能模式的一些基本思想和相应的组件。对于具体的MAC层工作机制，我们在后续的文章中在进行展开。

*注：本文初始的意图是描述在节能模式下具体的MAC层工作机制，不过后来在写缓存结构的时候，发现内容整理还是较多，所以进行分拆。故在本文中，我们主要描述了802.11协议中，节能的基本思想，以及其所添加的一些组件，具体的MAC协议之后再进行补充。*

## **802.11协议中的能耗**

为了理解802.11节能机制，我们首先需要梳理一下wifi中的一些所出现的能耗。通常情况下，802.11设备一共会有4个工作状态：

- Sleep（休眠模式）：节点会关闭发送和接收模块进行休眠，从而能耗最低。
- Rx Idle（接收空闲状态）：节点对信道进行监听，但并未真实接收数据帧。
- Rx（接收状态）：节点监听到数据帧，并对其进行接收。
- Tx（发送状态）：节点发送数据帧。

其中Rx Idle状态，Rx状态和Tx状态的关系，需要从我们之前描述的发送/接收过程来理解。1）节点需要首先执行CCA，用以监听信道中有没有数据帧（主要是ED和CS两个过程），这个过程即是Rx Idle状态。Rx Idle状态下面可以转移至Rx状态，也可以转移至Tx状态。2）若节点在监听信道过程中，发现有802.11的数据帧，那么其就转移至Rx状态进行接收。3）若节点本身有数据需要发送，且在持续监听信道的过程中（即backoff过程中），发现信道是空闲的，那么其就转移至Tx状态进行发送。

在上述过程中，真正有用的只有Rx和Tx状态。但是实际过程中，为了保证接受与发送中没有冲突，节点需要长时间处于Rx Idle状态，从而会消耗很多能量。一般意义上，Rx Idle状态近似于Rx状态，只是一个少了一些上层的逻辑处理工作，而能耗较大的RF模块，LNA，AGC这些都是同样需要工作的。所以在802.11协议设计中，需要引入Sleep休眠状态以代替Rx Idle状态，达到节能的目的，进而扩展成了休眠模式下的工作机制。

下图给出了一般wifi芯片中，这四种模式的功耗情况（参考《AR5213_Data_Sheet_0704》中第10.1.5 Power Consumption节）

![img](https://pic4.zhimg.com/80/5bcfff94561c03c50588fd81aa44130b_720w.png)

该图所描述的都是工作在802.11g的模式下，为了更好的描述主题，我们对原图进行了一些裁剪，其余工作模式的功耗还请查阅原文。上图分别列举了AR5213这块芯片，在1.8V的供电模式和3.3V的供电模式下，对应的不同的功耗。可以明显看出，Sleep状态和其他几个状态的功耗还是有很大差距的，从而节能模式如果设置的好，那么的确可以达到一个很好的节能效果。

同时，上图只是给出了一个标准Tx的功率大小，在802.11中还存在transmit power levels参数，一般有8个级别，可以调节具体的Tx功率。同时在beacon帧中，也可能会添加Power Constraint element与Power Capability element这些参数，从而对该区域内的节点功率进行约束。这些都会影响具体的Tx功率大小，不过由于这些机制主要用于TPC（Transmit Power Control）机制，而本文讨论主要是节能机制，所以就不展开了。

## **节能模式的基本思想**

按照之前我们的叙述，在802.11中功耗最大的部分是在Rx Idle状态。如果能够减少Rx Idle状态的持续时间，那么节点就可以节能了。在本章节讨论中，由于不讨论具体的MAC机制，所以我们简单假设一个拓扑，该拓扑仅包含一个AP和一个节点。节点上行发送都是发往AP的，下行是AP发往节点的。故从节点的角度而言，执行Rx Idle的目的则有两种可能性：

- 如果节点是为了发送数据，那么Rx Idle是用来监听信道的，从而如果没有数据发送，那么就不进行监听，从而就可以减少Rx Idle的持续时间了，这个还是很容易做到的。
- 如果节点是为了接收数据，那么Rx Idle则一定需要长时间持续进行。因为作为接收方，节点无法知道AP什么时候发送给自己的下行数据，所以要不断的监听信道，保持Rx Idle状态，对于每一个数据包都不能漏。由于节点无法控制AP，所以这一块是比较难做到的。

所以在802.11中就提供了一种被动请求机制，其主要就是提供了一种机制，让节点可以控制AP，让其发送对应的下行帧给自己。故在节能模式下，802.11协议中就引入了两个机制：

- 缓存机制：这里缓存的主要是AP发往节点的数据。当AP从外网接收到要转发给节点的数据后，会将以MSDU的形式（即MAC层的数据帧）进行缓存（这里仅仅对工作在节能模式下的节点数据进行缓存），并不直接发送给节点。
- PS-Poll机制：若节点想要获取下行数据，那么节点需要主动跟AP请求数据，该请求帧就是PS-Poll帧。AP接收到该帧后，会检查缓存区是否有对应该节点的缓存，如果有就会从缓存区中调出对应该节点的缓存数据，并进行下发，如果没有则反馈一个NULL帧（既空数据）。有的书中，也将这个请求机制比较形象的描述为“兵乓”机制。

我们用下图大致描述下这里其交互机制：

![img](https://pic1.zhimg.com/80/4cdab293a32f4610f98b184f6f47d8ec_720w.png)

1. 由于AP已知节点工作在节能模式，所以其首先将发送给节点的数据进行缓存。
2. 当工作在节能模式的节点wake-up后，其在完成竞争后，首先发送PS-Poll帧向AP请求下行数据帧。
3. AP从而就在自己的缓存区里面找该节点的缓存数据。当找到对应数据帧后，通过Frame进行反馈，这里可以看到上图标注了一个IEEE80211_FCTL_MOREDATA的描述，该参数实际上对应到无线数据包中的more data字段，如果AP。
4. 如果节点识别到该more data字段为1后，则知道AP中还有自己的缓存数据，那么会再次发送PS-Poll帧进行请求。
5. 直到AP反馈的Frame中的more data字段为0，那么节点就不会继续反馈PS-Poll帧。该轮的数据请求就结束了，从而继续sleep进行省电。

*PS：上图简单描述了节能模式的基本工作原理，其中我们省略了ACK的过程，以及在多节点情况下的具体工作机制，之后我们再进行补充。上述表述如果有错误的地方，还请见谅。*

## **缓存机制**

这里我们大致谈论下AP对于下行数据的缓存机制，首先笔者对这一块也没有完全的理顺，尤其是协议与内核实现机制这一块，貌似并不是完全按照协议的定义来实现的，所以这里只是一些简单的列举。如有错误还请指出，以便将这一块更加理顺一些。

- **协议中对于缓存机制的描述（参考802.11协议07/12版本）**

在协议中，对于该buffer的描述还是较为复杂的。为了表述缓存，我们首先要描述在802.11协议中，对于一个帧如何存放是怎么定义的。在802.11协议中，数据帧的存放是通过FragSdu结构体进行存放的。（细节见07版协议第805-806页）

![img](https://pic1.zhimg.com/80/04135b127866fc1a239ea6edb739b480_720w.png)

在这一段中，我们按照标注的顺序进行描述。

- 红色部分的1，这个部分描述了这整个模块的功能，是用来描述一个分段支持类的。然后在这个类下面，定义了3个子模块（图中只有2个，还有一个与节能模式有关所以放在后面描述）。
- 红色部分的2，注释表明说明，这里定义了一个数组用来存放具体的数据帧的。
- 蓝色部分的1，标识部分即是该FragArray数组的具体定义。
- 红色部分的3，注释了FragSdu的功能，实际上整个发送缓存，无论是否有fragment都是按照FragSdu进行存储的，该FragSdu在实现上具体就是一个结构体。虽然名字是用来定义分片的SDU的，但是其中也写明了“Each SDU, even if not fragmented, is held in an instance of this structure awaiting its (re)transmission attempt(s).”，故即使该数据包没有分片，那么应该是按照FragSdu这种形式统一存放的。
- 蓝色部分的2，在FragSdu结构体中，主要存放这个具体数据包中对应的很多的参数。这些参数包含一些数据帧中具体的控制字段，我们以紫色方框的标注叙述其具体描述方法。在紫色方框这一行中，紫色1标注该变量名为psm，紫色2所标注变量类型是Boolean类型，紫色3所标注的字段是注释，标注该变量是描述该数据包是否发往节能模式下的节点的。在这一行表述中，如果该变量是1的话，那么就标识这个数据包对应的接收节点是工作在节能模式，反之则不是。之前在红色部分2所定义的FragArray数组，也是通过最后一行所定义的pdus参数，存放在FragSdu结构体中。

*PS：因为本文是描述节能模式下的缓存机制，所以就没有对帧重组部分的进行展开，如果是帧重组的情况，那么主要起作用的是FragNum类型的3个参数和SeqNum类型的1个参数。*

每一个帧是通过FragSdu来存放的，对于多个帧，在802.11协议中实际上是以一个队列进行存放，该队列即是SduQueue。在802.11协议中，发送缓存以及用来节能模式下的发送缓存都是一个队列的结构。在802.11协议描述中，其是首先定义了一个队列的类，然后在分段支持类进行对SduQueue进行了继承。首先我们查阅下Queue类的初始定义，如下：

![img](https://pic1.zhimg.com/80/f7c8f1f617e8dd17156bbf85268d42d0_720w.png)

在该Queue类中，其定义了两个方法，即Qfirst(queue,item)和Qlast(queue,item)。其中Qfirst(queue,item)子函数负责把数据帧插入到队列首部，Qlast(queue,item)负责把数据帧插入到队列尾部，在一些材料中，这里还所述定义了first_and_tail方法，不过笔者在协议中并没有直接找到。在分段支持类中，对Queue进行了继承，如下：

![img](https://pic3.zhimg.com/80/7eea7bbd91ad7066fd3fd331189838ca_720w.png)

即增加了一个方法Qsearch(queue,addr)，在节能模式下，当节点发送PS-Poll后，AP需要在缓存区查找出对应该节点的数据帧，再进行相应的传输。在这一段描述中，该FragSdu描述是为了power save buffers使用的，但是很多材料中所述，整个传输缓存就是按照SduQueue的形式存放的，这里笔者并没有严格考证过，最后我们用一张图大致描述下整个结构。

![img](https://pic1.zhimg.com/80/254bc306fd87eb2151db8f2d9c3eca98_720w.png)

- ***内核中对于缓存机制以及节能模式的描述（参考《Linux Kernel Networking》第12章部分内容以及openwrt的源码）***

在内核中，对于缓存是在openwrt源码中\net\mac80211\Sta_info.h中定义的，如下图

![img](https://pic4.zhimg.com/80/11461e57f8863ac549c841002e04e4eb_720w.png)

其中ps_tx_buf就是用以节能模式下，存储节点的buffer的，其中IEEE80211_NUM_ACS参数一般设成4，其对应是802.11e中存在的4中不同优先级的队列，sk_buffer_head是一个结构体，其含义是一个链表头，一般该结构都是用来辅助sk_buff结构快速找到链表头结点的。具体实现中，应该是利用该链表结构实现了一个Queue，或者说是一个FIFO。

同时实现中，定义了一些有关buffer长度的限制，笔者目前整理一共有三处限制。

![img](https://pic1.zhimg.com/80/61b0fe8ea3036144466b52e02bab9124_720w.png)

- STA_MAX_TX_BUFFER：该参数大小是64（书上所述是128），是用来限制ps_tx_buf的带下的，位置在\net\mac80211\Sta_info.h中。该参数的意思是，每一个节点最多可以储存64个数据包。

![img](https://pic3.zhimg.com/80/10f2c58dfd289e9dd586279a619a7ece_720w.png)

- AP_MAX_BC_BUFFER：该参数大小是128，是用来限制bc_buf的大小，位置是在\net\mac80211\Ieee80211_i.h。该buffer是专门用来存放组播/广播帧的，该buffer只有1个队列。

![img](https://pic3.zhimg.com/80/564e169720a5a82c349a65a2543741f6_720w.png)

- TOTAL_MAX_TX_BUFFER：该参数大小是512，根据描述，是用来限制总的buffer大小的，位置是在\net\mac80211\Ieee80211_i.h中。

*PS：上述主要还是关注了下，AP中为节能模式所设定的缓存结构，具体的节能实现机制和MAC层协议，这里我们还没有展开，还请见谅。*

# 节能模式（PSM）

## **序言**

在802.11主要的版本中，总共定义了四种节能模式，本文主要关注最初始的PSM模式，对于在802.11e中添加的ASPD以及802.11n中添加的PSMP，SMPS机制，我们在下一篇再进行论述。

**PSM（Power Save Mode）**：802.11协议中初始的节能模式，其对基础架构模式和IBSS模式下的节能机制分别进行了定义，并且在DCF和PCF模式下，其具体的MAC层工作机制也有不同。
如同我们之前的描述，802.11的节能模式基本思想是：AP缓存下行数据，只有当节点休眠结束后主动向AP请求，AP才进行下行数据的反馈。这里实际上存在一个问题，即节点不知道AP上有没有自己的缓存数据。故实际思路应该是，AP周期性向对应的节点其广播缓存区情况，从而节点可以知道自己是否被数据缓存了。在休眠结束后，被缓存数据的节点就会进行数据请求，反之就继续休眠。这样可以有效避免节点进行一些无意义的数据请求（即AP上没有缓存数据，但是节点进行数据请求）。

所以本文我们首先要回答两个问题：1）AP如何广播自己的缓存区信息（即AID，TIM与Bitmap机制），2）AP什么时候广播对应节点的缓存区信息（即TSF，TBTT，Listen Interval field与CFP repetition interval）。在此之后，我们再对协议中具体的MAC层工作机制。

*PS：本篇的概念又多又繁杂，且与前面描述的DCF和PCF基本工作模式关联较大。故本篇已尽量按照先需求后设计的思路进行描述，其他不足之处，还请见谅。同时在802.11的一些分支版本中也定义了一些特定的节能模式，比如802.11v的WNM-Sleep Mode，这些我们就不进行展开了。*

## **AID，TIM与Bitmap**

在802.11协议中，设计了一种用较少字段就能够广播自己缓存区信息的机制，如下图，我们首先描述其大致的思想：

![img](https://pic3.zhimg.com/80/v2-df07b9d62aa93709289765dbaa1f18b2_720w.jpg)

实际上是AP是采用一种Bitmap结构，用来通知节点自己的buffer信息的，若将其看做一个矩阵的话，那么该矩阵的每一行有8列，最下包含1行，最大包含251行，换言之该矩阵最大的存储空间为251个By。该矩阵中每一个位置代表了一个节点，比如红色方框位置就代表了STA0，蓝色方框位置就代表STA4，紫色方框位置就代表STA24。而矩阵中具体的某一个元素则代表了Buffer的情况，若该元素为1，那么代表其对应节点有数据缓存，若元素为0，那么就没有数据缓存。AP周期广播这样一个bitmap，节点就会查看自己对应的位置是1还是0，从而再决定是否要发送PS-poll请求数据。

那么具体该矩阵中的某一个位置，对应的就是节点的关联ID（AID）。

- **AID（Association IDentifier）**：关联ID，该参数相当于给STA起一个别名。在AP身上有一个association ID table，其中每一个AID都是和其对应STA的MacAddr进行绑定的。AID的范围是从0~2007，所以也说明了在协议中，一个AP最多可以关联2007个节点。AID=0的位置为保留字段，并不分配给节点，用以代表所有的组播和广播。
  比如上图中，红色方框处描述了AID=0有数据缓存，也就是存在组播或者广播的缓存（即实际上STA0不存在），蓝色方框为AID=4的节点（也就是实际存在的节点STA4）其数据被缓存，紫色方框为AID=24的节点，其数据被缓存。

**AID的分配：**当一个节点（STA）向AP发起关联请求（Association Request）后，AP会反馈的关联相应帧（Association Response）。AID也是在这个过程中被分配，并告知节点（PS：在重关联过程中，该AID也会被分配，不过这里我们并不讨论）。如下图，是一个Association Response帧格式其中就包含了Association ID这个参数。

![img](https://pic2.zhimg.com/80/v2-31ab46d88ba8031c518cf9f03bb762d1_720w.jpg)

通常AP在分配AID参数时，应该是按照从1开始，一个个下发给节点的，同时这里虽然显示的是2 Byte，也就是16位，但是为了与我们后面提到的Duration/ID字段兼容，所以其最高的两位都是置1，作为保留字段，所以范围是1~2007。因为AID的分配不像DHCP协议那样，可以设置一个失效时间，即AP不会主动回收已经分配给某些节点的AID。所以导致新的节点加入AP时，被分配的AID有的时候会比较后，后面我们分析TIM字段中的bitmap设计对此就有所考量。下图是在抓包中，具体的AID的显示：

![img](https://pic3.zhimg.com/80/v2-6c1e8cbce5ac23f36af33d9d1488a1fe_720w.jpg)

当AID分配之后，节点就可以利用bitmap来广播自己所缓存的buffer信息，在802.11协议中，由于该buffer也是周期性的进行反馈，所以被放置在beacon帧中，作为一个字段被携带，该字段就是TIM字段。
TIM（Traffic Indication Map）：流量指示图，实际上是一个基于bitmap结构的流量指示图，用以标识AP的缓存信息。其具体结构如下：

- **Element ID**：元素识别码，用来标识beacon帧中所包含的不同字段。
- **Length**：长度，描述的是该Element的长度，实际上Element ID和Length是一般管理帧中information element必备的元素，这里就不详细展开了。
- **DTIM Count**，DTIM Period：DTIM计数以及间隔的时间。在802.11协议中，我们可以看到三个概念，TIM，DTIM，ATIM。TIM是一种基本的流量指示图的结构，标准的TIM中仅仅指示AP缓存的单播信息，DTIM（Delivery Traffic Indication Map）是一种特殊的TIM，其除了缓存的单播信息，也同时指示AP缓存的组播信息。一般情况下，每一个beacon帧中都包含一个TIM信息，不过该TIM具体是不是DTIM，则需要考量DTIM Count和DTIM Period两个参数。DTIM Period是一个周期，是一个固定值，代表经过几个TIM之后就会出现一个DTIM。而DTIM count是一个计数值，是变化的，当DTIM count=0时，则代表这个TIM是一个DTIM。实际上如果DTIM Period设置成1，那么每一个TIM字段中，DTIM count都等于0，所以每一个TIM就是DTIM了。PS：至于ATIM，ATIM是一个帧，在IBSS模式下被使用，由于本文主要讨论的就是基础架构模式下的无线网络，所以这里就不展开了。
- **Bitmap Control，Partial Virtual Bitmap**：该字段就是Bitmap的具体字段，实际上与我们一开始描述的bitmap结构还存在一些区别。以下我们重点描述下协议中具体使用的bitmap结构。
  Bitmap：在前面，我们所给出的是一个最为初始的一种bitmap结构，该结构还是有一些缺点的
  占据较长的传输时间：同时由于在802.11协议中，Beacon的实际发送一般都是采用最低速率的，其包含两个原因，1）beacon帧是一个广播帧，其没有ACK反馈，所以无法设置重传机制，2）beacon帧目的是广播AP的基本信息，所以希望所有的节点都能够有效的接收该数据，从而采用较低的速率以保证信号较差的节点也可以接收该信息。所以，如果每一个Beacon帧中，都包含一个完整的251 Bytes的bitmap，那么就会占据比较长的传输时间，降低信道的利用率，对整体的吞吐量造成影响。所以在实际应用中，对于后面没有使用到的AID位置，我们传输时可以省略，从而减少bitmap的空间。
  缺少灵活性：由于bitmap中每一位置就对应了一个节点的AID，同时在我们之前叙述，AP对于AID的分配并没有一个回收机制。所以有可能出现，AID从0~300的位置都是没有再使用过的节点信息，而真正活跃的节点都是在AID从300~330左右的位置。这样如果仅仅去除后面没用的AID位置，也会多出来300 bits左右的空间浪费（即之前0~300个没有再次使用的AID范围）。故这里不仅仅需要省略后面的bitmap空间，也要对前面的bitmap空间进行优化省略。

![img](https://pic1.zhimg.com/80/v2-e26a641d49d9f93788e25dc9602ede38_720w.jpg)

如上图，我们可以更明确的看到其缺点，并且想到改进的思路。比如在该图的情况下，只有AID=120~127位置的节点，存在数据缓存。其余AID<120的节点没有数据缓存，AID>127的节点也同样没有，所以具体传输时，我们只要通知AID为120~127的节点即可，其余两个部分都是冗余，也就是没有意义的，所以对此我们要进行压缩。在802.11中，具体是设计了Bitmap Control和Partial Virual Bitmap的结构来解决这个问题，如下图所示

![img](https://pic2.zhimg.com/80/v2-753a2ef4570ac0d1edc447c27ba03e59_720w.jpg)



在802.11协议中，Bitmap control和Partial Virtual Bitmap是放在一起使用的，其中Bitmap control字段还分成两个部分：

- 第[0]位是用来指示是否有组播/广播数据包被缓存的，这个是一个特殊位。如果为1，那么有组播/广播数据被缓存，反之没有。
- 第[1:7]位是用来标识Bitmap offset，用来指示AID的偏移情况。该参数是用来描述在Partial Virtual Bitmap中起始AID的，在上图中，由于Bitmap offset部分都为0，所以起始AID是从0开始的（PS：由于协议规定AID=0是一个保留字段，用来标识所有广播和组播信息，所以没有分配给节点进行使用。但是Bitmap control字段中的第一位也是这个功能，所以实际上AID=0是没有被使用的。），之后的AID=1就代表了节点1，而AID=8则代表了节点8。Partial Virtual Bitmap是一个变长的字段，范围是1~251，也就是说，如果后面的AID没有对应的缓存，那么就不会存放在Partial Virtual Bitmap中。（PS：这里需要注意的是，由于这里是按照Byte的形式进行存储的，所以是按照8位进行步进，如果不够8位的部分，则需要补全）

![img](https://pic2.zhimg.com/80/v2-e64723b3ba0ffbd3dee36ba4b1b5e7d5_720w.jpg)



我们现在关注Bitmap Offset的使用方法，前面提到，Bitmap offset是用来描述首位AID的偏移的，若该字段都为0，代表偏移值为0，所以在Partial Virtual Bitmap中是以AID=0开始计数的。现在我们描述Bitmap Offset不为0的情况，首先我们给Bitmap control每一位标注x1~x7，这里标注顺序与一般二进制表示的顺序刚好相反。每一位代表特定的偏移量，这些偏移量计算都是以8做为奇数的，若仅仅x1为1，其余都为0，那么AID起始为2*8=16，若仅仅x4为1，其余都为0，那么AID的起始为16*8=128。以下我们再举一些例子：

- 若没有组播/广播数据，且AID=24的节点有数据，那么Bitmap Control字段为【0 1 0 0 0 0 0 0】，Partial Virtual Bitmap为【0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0】。实际上AID=24，也就等于3*8，如果是二进制的话，那么可以分解成（2^1+2^0）*8，也就是有两位置1即可，但是由于Bitmap Offset中最小的单元是2，而不是1（可以看到，2^0也就是x0这一位实际上是被组播/广播数据提示这一位占据了，所以用不了），所以与AID=24最接近的起始位置是AID=16，从而就确定了bitmap control字段，然后Partial Virtual Bitmap按序找到AID=24的位置，进行标注即可，最后要补全一个字节。
- 若存在组播/广播数据，且AID=100的节点有数据，那么Bitmap Control字段为【1 0 1 1 0 0 0 0】，Partial Virtual Bitmap为【0 0 0 0 1 0 0 0】，具体计算方法和上面一样。

*PS：在802.11协议中，实际上给出了Bitmap的C语言实现的demo，在07版协议的Annex L中就有给出，用兴趣可以自行阅读。*

前面我们描述的是AID在AP发送的TIM字段中的应用，在节点发往AP的请求中，实际上也是用的AID参数。在节点向AP请求数据，所发送的PS-Poll帧当中，就是将Duration/ID标识为AID，下图是一个PS-Poll的帧结构：

![img](https://pic1.zhimg.com/80/v2-df4ba05159ca73480128942fd093ec68_720w.jpg)

其中Duration/ID字段直接被标识成了AID字段，其具体内容如下：

![img](https://pic1.zhimg.com/80/v2-894cc871de4d0f6ba64158f7b6a6810c_720w.jpg)

从而节点向AP发送PS-Poll帧中，直接没有包含源地址，而是采用AID作为替代，当AP接收到PS-Poll后，根据其AID，在缓存空间搜索其对应的缓存内容，进而反馈给节点。

## **TSF，TBTT，Listen Interval field与CFP repetition interval**

按照之前的描述，AP是周期性的发送beacon帧，在该beacon帧中的TIM字段包含了对应缓存区的信息。但是如果每一个帧中都包含所有节点的TIM信息会有两个缺点：

限制了节点的休眠时间，由于每一个beacon帧都包含了TIM信息，所以节点需要定时醒来接收对应的beacon，这一点也是比较耗费能量的，如果让节点多休眠一会，那么会更节能
增加了TIM的信息，如果beacon帧中，并没有包含所有节点的TIM信息，那么就可以按照我们前面所述的Bitmap control和Partial Virtual Bitmap进一步压缩空间，减少beacon传输时间的浪费
所以802.11协议设计中，节点是周期性的醒来，并且AP知道节点对应的苏醒周期。当节点醒来之后，AP才会在对应beacon的TIM字段中，为其指示缓存区信息。（在实际情况下，AP除了在对应的睡眠周期到达后要醒来，同时也会计算DTIM到达时醒来，因为后者是广播信息，前者是单播信息）。

那么为了做到前面所述的需求，AP和节点之间首先要做到时间同步，然后要规定一个周期，进而完成周期性获取TIM信息这样一个需求。

- **TSF（Timing Synchronization Function）**：协议中是用TSF机制来描述定时同步功能。TSF定时器一共64位，单位是us。在基础架构模式中，定时同步是同步AP发送的beacon帧来完成的，在beacon中有一个Timestamp字段，该字段也是64位，并且是在beacon中不是按照Element形式进行存放的，所以每一个beacon帧中必定会有一个Timestamp。当STA接收到AP的beacon帧后，提取Timestamp字段的时间戳，并且添加一下本地估算出来的延迟（从天线端口接收到最后处理的本地延迟），从而完成节点与AP时间同步的功能。

![img](https://pic2.zhimg.com/80/v2-2e3063e6626b6dba49836be83414cc2d_720w.jpg)

上图就是beacon帧中，timestamp相应的字段，在其之后，我们可以看到一个Beacon Interval字段，该参数实际上在路由器配置中可以看到，一般被描述为Beacon时槽，且大小为100ms，即0.1s（PS：通常情况下，网速都是按照10进制进行步进的，即1kbps=1000bps这样，k是kilo的意思。而在802.11协议中，这里规定了一个时间单位TU，Time Unit，TU是少有的按照二进制进行步进的单位，1TU=1024us，这里实际上是kilo-binary的计数方法。所以一般我们设置的是0.1s，但是在实际的Beacon帧中是0.1024s，这里有一个区别），该参数与TBTT时间是一致的。

- **TBTT（Target Beacon Transmission Time）**：信标预定传送时间，实际上这个是一个定时后的发送/接受beacon动作的周期，其周期的时间就是由Beacon Interval所决定的。当TBTT时间到达的时候，AP会主动发送beacon帧，而节点也都会主动接受该beacon帧（包括休眠模式的节点，也会苏醒过来接受该beacon），然后利用beacon进行时间同步，并且查看TIM字段，若没有自己的数据缓存，那么节点继续转为休眠模式，直到下一个TBTT时间到来。

Beacon帧是按照TBTT时间进行周期性发送的，但是节点也不会是严格每一个beacon都需要监听的，为了更有效的设计节能模式，节点应该是每间隔几个TBTT周期，再监听一次beacon帧，从而就可以延长自己的休眠时间。

- **Listen Interval**：监听间隔是指工作站两次苏醒之间，历经多少次TBTT，也就是跳过了多少个Beacon帧。较长的监听间隔，节点休眠的时间就越长，从而越节能，但是会耗费AP的缓存区空间，也增加了接入时延。

Listen Interval是节点通过Association Request帧发送给AP的，从而AP就知道节点的苏醒时间，在对应节点苏醒的时候，其才会在Beacon帧中，为其指示Buffer的状态。该字段一共16位，其单位是Beacon的周期间隔，也就是TBTT时间，若Listen Interval设置成2，那么代表节点每经过两个beacon周期，才苏醒一次。在抓包中，如下图所示：

![img](https://pic3.zhimg.com/80/v2-357ef589e7e92028583046e2706e031e_720w.jpg)

在802.11时间周期这一块实际上规定的是比较繁杂的，由于我们讨论的是协议中完整的节能模式，该节能模式实际上也分DCF和PCF下不同的工作模式，所以我们还需要明白CFP repetition interval，即CFP周期和上面TBTT时间的一个关系。

- **CFP repetition interval**：CFP重复周期是用来协调PCF和DCF两个不同工作模式的一个调度周期，其中包含CFP和CP两个部分，CFP是用来给PCF时间进行工作的，CP时间是给DCP来工作的。这一部分内容我们在讨论PCF的时候有讨论过。

最后用一张图，我们标识一下这几个调度周期之间的关系：

![img](https://pic4.zhimg.com/80/v2-e64927c4543cf9ea1e544017f27c7327_720w.jpg)

TBTT周期是beacon之间的周期（如图上蓝色部分），每间隔TBTT，AP就会发送一个beacon，该beacon中有可能包含TIM信息（图中红色部分），也可能包含DTIM信息（图中紫色部分），其间隔是由DTIM Period参数进行设置的。同时我们还可以关注到，beacon的发送有可能在CFP时间内，也有可能在CP时间内，其实际上就仅仅按照TBTT间隔发送即可，若在CFP时间内，beacon发送的间隔是很准确的等于TBTT，而在CP时间内，因为DCF的竞争接入机制，所以beacon的间隔会出现一些小偏差，基本是约等于TBTT时间。


CFP repetition interval是较为注意的一个间隔（图中绿色部分），CFP时间间隔是要等于TBTT时间的倍数的。实际上我们知道，CFP的NAV时间设置是通过beacon帧的NAV或者CF Parameter Set机制来完成的（具体可以查看我们之前PCF的叙述），所以CFP的起始一定会有一个beacon帧，而结束不一定。同时在CFP或者CP中，都有可能出现多个beacon帧。如上图中，第一个CFP的开始一定是一个beacon帧，而结束则不是与beacon同时的。那么CFP时间结束后，到CFP周期结束前，其剩余的就是就是CP的时间。且在这张图中，我们可以看到在第一个CFP周期内，就存在2个beacon帧。

## **PSM模式（Power Save Mode）**

在初始的802.11 PSM模式中，DCF和PCF模式下，还有不同的工作机制。以下我们首先叙述节点如何进入PSM模式，然后叙述DCF的工作形式，最后我们叙述PCF。（PS：至于该两个时间周期的调度关系，我们已经在前面提到过了，这里就不加以展开了。）

**1、如何进入PSM模式**

节点如果要工作在PSM模式下，首先要告知AP，自己将要工作在节能模式。在802.11帧中，这个信息是包含了MAC层头部中的Frame Control Field中的，也就是说，任意一个帧都可以用来进行工作模式的切换，节点可以在关联上AP的时候，就切换到PSM模式，也可以在工作状态中，切换到PSM模式。在Frame Control Field字段中，我们有两个内容需要注意，如下图：

![img](https://pic1.zhimg.com/80/v2-d2dee8f81ee74cb86ef4a563f237073c_720w.jpg)

这个两个内容即Pwr Mgt（Power Management）以及More Data。

- **Pwr Mgt（Power Management）**： 该字段用来标识在该帧过后，节点是否会进入省电模式（PSM mode）。若为1，那么就进入PSM mode，反之就保持当前工作状态。由于在基础架构模式下，AP本身有电源供给，且AP负责整个网络的核心管理，所以AP发出的下行帧中，该字段默认设置为0。
- **More Data**：该字段是AP指示节点，是否还有该节点的缓存数据没有发送。若为1，代表AP还有对应节点的数据缓存，反之则没有。由于我们前面提到过，在PSM mode中，请求数据实际上是一种“兵乓”机制，一个请求只会有一个反馈。所以AP在反馈下行帧的时候，会不断指示节点是否还存在缓存，如果有缓存的话，那么节点会继续请求数据。只有当AP中所有对应该节点的缓存都被清空以后，那么节点才会重新进入休眠状态。

**2、DCF下的PSM模式**

DCF是基于竞争的工作模式，所有的节点需要接入信道需要进行竞争，包含AP以及工作在节能模式下的节点。
因为节能模式有关的参数较多，用一个图例来说明比较困难，所以我们尽量尝试说清楚，不足的地方还请见谅。

![img](https://pic4.zhimg.com/80/v2-49f74ece8374e476685912cf1bbfad77_720w.jpg)

那么上图描述了1个AP，2个节能节点工作的时序图，黑色的轴所代表的是数据包发送和接收的时序，紫色的线上代表节点苏醒的情况。图中STA1的Listen Interval等于2，STA2的Listen Interval=1（为了图意简便，就没有标识在图上了）。

1. 一开始，我们假设由AP发送一个beacon帧（即1st Beacon），由于这个beacon帧是作为最初时刻的beacon，所以节点需要提前wake up并接收该beacon帧。如图中所示，beacon帧中的TIM字段标识，STA1节点有数据包待传，而STA2节点没有数据包。所以STA1在接收到beacon之后，保持wake up状态，而STA2则转为sleep状态。
2. STA1由于已知AP中有自己的数据包，其首先要进行Backoff（这里有关DIFS，backoff，SIFS的过程与标准DCF相同，所以这里都以省略形式带过），当Backoff完成后，其向AP发送一个PS-Poll帧，用以请求数据。
3. 当AP接收到该PS-Poll帧之后，其首先要反馈一个ACK（在初探节能模式中，我们并没有强调该ACK的反馈，实际上802.11中的单播帧都是需要ACK反馈的），当ACK反馈后，AP再将数据发送给STA1，并且在该数据的Frame control字段中，标识more data=1。
4. 当STA1接收到AP的数据后，其首先也是需要反馈ACK，并且查看该数据帧中的More data字段，由于该字段等于1，所以STA1无法转为sleep状态。其还需要持续向AP请求数据，那么其再次经过backoff，然后发送PS-Poll帧给AP。
5. 当AP再次收到PS-Poll后，首先还是ACK，然后反馈数据。假设这次反馈的数据包是STA1缓存在AP的最后一个数据包，那么AP在反馈中会把more data字段设置为0。
6. 当节点收到该数据包后，由于more data=0，所以STA1会在反馈完ACK后，进入休眠。
7. 当第二个Beacon传输时（2nd Beacon），由于STA1的Listen interval=2，所以其还是处于休眠状态，而STA2的Listen interval=1，所以每一个beacon周期其都需要醒来，接收该beacon。假设第二个beacon中，STA2还是没有数据（图上未标明），那么其接收完beacon后就转为休眠模式。
8. 当三个Beacon传输时（3rd Beacon），STA1和STA2都会苏醒并接收该beacon。同时，该beacon中标识，两个节点都有数据包被缓存在AP中，所以两个节点都需要进行竞争接入。在上图中，我们假设STA2首先完成backoff，并接入信道。在STA2占据信道传输时，STA1会检测信道是繁忙的，所以不会同时进行发送，这点实际上就是DCF的竞争过程。
9. 当STA2给AP发送PS-Poll，并且得到AP反馈的数据后，STA2检查该数据包中的more data字段为0，所以其接收完该数据包后，就进入sleep。而STA1由于还没有接收到数据，则还会竞争接入信道，直到接收完AP中对应其的缓存，那么其才会再次进入sleep模式。

以上，我们描述了一个PSM-DCF的基本工作模式，这里我们还需要额外注意的一点是DTIM时间，由于绘图情况较为复杂，所以我们只能够描述一下情况。在PSM模式下，节点苏醒的条件有两个，达到其中一个其就会苏醒。
节点根据Listen interval进行苏醒，即每隔Listen interval时间，节点会苏醒一次，直到接收完AP中自己的缓存，才会转为睡眠模式。

DTIM周期，由于我们知道DTIM实际上是用来下发AP上缓存的组播/广播帧的，所以所有的节点都需要在这个时刻苏醒，并且接收这个帧。所以只要该beacon携带的是DTIM，所有的节点也会苏醒（即使不在Listen interval规定的苏醒时刻）。在节点都苏醒后，AP会首先传输其缓存的组播和广播帧，节点接收完该组播或广播帧后，同时自己又不在TIM缓存中（笔者理解，由于AP知道节点的Listen interval，所以不会每一个beacon中都会携带其的TIM信息），那么该节点就会进入sleep，直到自己规定的时刻再次苏醒。

同时这里我们并没有对上行数据做具体说明，当节点本地有数据需要发送给AP时，其经过backoff后，会主动进行数据发送。至于节点会首先发送PS-Poll还是发送本地数据，笔者并没有考究。

**3、PCF下的PSM模式**

PCF是基于调度的接入方式，节点的接入顺序是通过AP的轮询完成的。

![img](https://pic4.zhimg.com/80/v2-48549335c4fd775afc6e536dd97ccdaf_720w.jpg)

实际上由于PCF的调度机制，所以一般更加设置节能方案，在上图中，我们假设STA1的Listen Interval=1，STA2的Listen Interval=1，并且我们假设DTIM period为4，并且第一个beacon，即1st beacon中携带的就是DTIM。

1. 首先AP发送一个Beacon，即1st Beacon，节点也保证在这个beacon周期之前就已经苏醒，用以保证能接收该beacon的信息。在1st Beacon中，携带的是DTIM信息，并且标识AP中有广播数据包的缓存。
2. 当Beacon时间结束之后，AP首先会发送缓存的广播帧，由于是广播帧，所以这里不需要等待ACK的反馈。当广播帧发送之后，AP会依次向节点发送数据帧，并轮询节点。由于DTIM中携带的信息表示，STA1和STA2都有数据被AP缓存，所以在没有收到下行数据包之前，STA1和STA2都是保持wake up状态。
3. AP会首先向STA1发送DATA+CF-Poll帧，这是一个帧，但是同时具有两个功能（即向STA1发送数据，并请求STA1的上行数据），这里在PCF工作模式介绍中，已经提到过了。
4. 当STA1接收到该数据后，其会向AP发送ACK以及自己的缓存，同样的，该信息也是封装在一个帧中，即DATA+CF-ACK帧中一次性反馈上去，节约了一些帧间间隔。同时由于AP下发的数据中，more data字段等于1，所以STA1接收完该数据后，还需要保持wake up状态，等待AP下方剩余的数据。
5. 在PCF中，AP是按照AID的升序对节点依次进行轮询的，所以即使发送给STA1的数据字段中，more data=1，但是其还是有先轮询下一个节点，而不会一直逗留在STA1上。AP会向STA2发送Data＋CF-ACK＋CF-Poll帧，可以注意这个帧有三个功能，既向STA1进行ACK确认，也向STA2发送数据，并进行数据请求。
6. 当STA2接收数据后，其同样想AP发送DATA+CF-ACK帧，并且由于more data字段等于0，所以STA2传输完该数据后，就进入sleep状态。且由于STA1与STA2的Listen interval都等于1，所以STA2会在下一个beacon到来之前就醒来，并接收该beacon数据。
7. 在第二个beacon中，即2rd Beacon，TIM指示STA1有数据，则STA1和AP继续进行数据交换（图中省略了），而STA2没有数据缓存，所以在接收完beacon后，STA2就进行sleep了。
8. 在第三个beacon中，即3rd Beacon，TIM字段指示STA1有数据，而STA2没有数据。所以STA2还是接收完beacon就进入sleep了，而STA1首先接收AP发送的下行数据，这里由于我们假设DTIM period为4，所以该beacon中携带的是TIM信息，即AP没有组播/广播包需要首先发送。所以一开始AP就发送DATA+CF-Poll给STA1，并且由于该帧中，more data字段等于0，所以AP在成功接收该数据帧，并反馈ACK之后，就进入sleep了。

## 其他资料

参考一篇比较老的paper《WaveLAN®-II: A High-Performance Wireless LAN for the Unlicensed Band》，这里对上面我们整理的一些内容有更好的图示，可以具体参考下：

![img](https://pic2.zhimg.com/80/v2-a507f8083f32272af236c5ae6c703431_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-0167f0526d20f818709acc972caa5069_720w.jpg)

# 节能模式（APSD，PSMP，SMPS）

## **序言**

在802.11主要的版本中，总共定义了四种节能模式，在前面一篇文档中，我们介绍了最基本的PSM模式，以及其工作方式上的一些细节。由于PSM是在最初的802.11协议下进行的设计，其用了较为保守设计，以确保最稳定的运行需求。在后来的802.11几个新版本中，为了改善节能模式的性能，所以还出现了一些其他的节能模式。本文主要介绍了其中主要的三个节能模式：APSD，PSMP以及SMPS。

*PS：实际上在802.11的一些分支版本中也定义了一些特定的节能模式，比如802.11v的WNM-Sleep Mode，这些我们就不进行展开了。*

## **APSD（Automatic Power Save Delivery）**

ASPD模式是对PSM模式的一个直接改进。PSM模式的其最大的缺点在于请求数据时采用的“乒乓”机制。即一个polling帧请求，一个数据帧反馈，这样一个来回交替的过程。该设计在数据缓存较多的情况下，会造成过多的polling帧出现，降低实际网络传输效率。从而ASPD就需要对此加以改进。

- **APSD（Automatic Power Save Delivery）**：ASPD是基于802.11e进行设计的。在802.11e中设置一个服务时间的概念，即Service Period（SP）。我们可以简单的理解成，若节点占据信道后，其制定一段服务时间，并且在该段时间内，该节点可以传输多个帧，换言之就是一次竞争多次传输。在ASPD中，还分为S-APSD与U-APSD两种具体的工作模式。（PS：本文对Service Period以及EDCA的具体工作机制不会加以展开，其内容后期会放在对802.11e的整理中）

我们利用下图，首先描述一下APSD的基本思想：

![img](https://pic4.zhimg.com/80/5fd64110be2e289d3e9a9896177d8d4f_720w.png)

在上图中，我们假设有一个QOS-AP，有一个QOS-STA（*PS：由于ASPD是基于802.11e的，所以QOS-AP与QOS-STA都是支持802.11e的设备*）。假设是由QOS-STA发起一个传输过程，即首先会发送一个“Trigger Frame”帧，这个帧有可能是QoS data或者QoS Null帧，通过该帧，节点申请到一个服务时间，即Service Period Start（*PS：该服务时间可以理解成802.11e中的TXOP时间，而不是一般意义上网络模型中所用的服务时间，在服务时间内，可以传递多个网络帧*），然后QOS-AP会反馈一个ACK和一个QOS-Data帧。接下来在服务时间范围内，QOS-STA会持续和QOS-AP进行数据交换。当QOS-AP的缓存全被发送完之后，会在最后一个QOS-Data帧中的QOS控制字段，标注EOSP（End Of Service Period），从而结束一个服务时间，即Service Period End。对比我们在初探节能模式中所提到的PS-Poll，这种“乒乓”的模式而言，前者一个请求一个反馈，而APSD中，一次请求就可以交换多个帧。下面我们说明S-APSD以及U-APSD。

- **S-APSD（Scheduled APSD）**：基于调度的APSD，S-APSD可以在EDCA（DCF的扩展）和HCCA（PCF的扩展）这两种工作模式下都可以使用，从笔者的个人观点而言，S-APSD更像是前面我们提到的PSM-PCF模式下的扩展。由于S-APSD的具体工作机制不太好抓包做确认，所以只能够通过对协议的字面含义进行理解，如有错误，还请见谅。

![img](https://pic4.zhimg.com/80/d2eda04af68e8fadc22323c4578d2683_720w.png)

如上图所示，是S-APSD的一个工作模式。在S-APSD中，SP（Service Period）是预先调度的，在调度时间将要到来之时，QOS-AP会发送一个triger frame，同时QOS-STA也会提前醒来接受该帧，从而开启一个服务时间。该服务时间是通过管理帧中的Schedule Element字段进行调度的，所以节点可以提前知道什么时候应该醒来。在上图中，QOS-AP发送的triger就是PS-Poll，然后就开始和QOS-STA交换数据，即STA向AP反馈数据之后，AP再向STA反馈数据，这样交替切换，直到SP时间结束。

在这里，QOS-AP和QOS-STA交换数据还是上下行按序切换的，即这里还是有一些类似“乒乓”机制，在后面我们提到的PSMP实际上对这一点会再次加以改进。

- **U-APSD（Unscheduled APSD）**：基于非调度的APSD，U-APSD只可以在EDCA的模式下进行使用，U-ASPD更像之前提到的PSM-DCF模式的扩展。

![img](https://pic1.zhimg.com/80/ec1fc282c1b58beb188942ffcc9dc318_720w.png)

如上图，是U-APSD的工作时序。在该模式中，QOS-STA会首先发送一个triger帧（即QOS-Null）给AP，AP收到该帧的时候，就意味着一段服务时间的起始，接着AP和节点会相继交换数据。（*PS：至于在服务时间内，上下行数据交替发送过程中是否还会有bakcoff，笔者目前所读的资料是没有的，不过对于协议中的原文描述，笔者还没有确定*）

实际上在一个SP时间内的工作机制，S-APSD和U-APSD是基本机制的，区别主要在于S-APSD的SP时间是实现调度好的，比如前面该时间就是利用beacon帧中实现调度，而在U-APSD是节点发起的，即该调度时间任意时刻都有可能发起，同时还可以主要到，一般S-APSD都是AP进行发起，而U-APSD是节点进行发起较多，不过这点也不是绝对而已。

## **PSMP（Power-Save Multi-Poll）**

实际上从802.11e中引入TXOP，Block ACK，802.11n中引入的RIFS，帧聚合，802.11ac中引入MU-MIMO（PS：协议中仅仅是AP下行可以使用MU-MIMO，上行未包含），这些技术都会导致AP的突发（burst）下行传输的效率相比上行接入效率要高。

所以从节能模式的角度而言，在APSD中，先分节点，再分上下行的传输模式，就没有先分上下行，再分节点的传输效率高，那么后者就是PSMP设计的基本想法。

- **PSMP（Power-Save Multi-Poll）**：在802.11n中新增的模式，可以理解是引入了更严格的调度机制，其首先利用一个PSMP帧来调度整个节能模式的传输周期，将其分成PSMP下行传输时段，PSMP-DTT（PSMP Downlink Transmission Time）和PSMP上行传输时段，PSMP-UTT（PSMP Uplink Transmission Time）。在PSMP-DTT过程中，AP进行突发传输，其中帧间间隔可能会更小，比如RIFS。RIFS的时间会比SIFS会更小，SIFS时间是包含了一个发送状态到接受状态的切换时间，而RIFS仅仅是两次发送状态之间的切换时间。在该过程中，节点可以不采用CCA，直接在被调度的具体时间内醒来，并接受数据，从而可以获得更多的休眠时间，从而节能。在PSMP-UTT时间内，节点仅仅会在被调度的周期内醒来，并反馈上行数据帧，从而也减少了较多的监听过程，节约了能量。在PSMP中，若AP的下行传输中存在广播/组播包，那么会在PSMP-DTT时间内，第一个数据帧进行发送，这点实际上和之前的PSM模式传输组播或者广播帧是一样的。

如下图表述了一个PSMP的时序调度（参考《Cambridge.Next Generation Wireless LANs.802.11n》）

![img](https://pic1.zhimg.com/80/62403bdbd5270c8e6058a3332e07a2e0_720w.png)

那么AP首先发送一个PSMP帧，该帧中包含了后续时间内，下行链路和上行链路具体的调度安排。然后开始进入PSMP-DTT时间，第一个是发送本地缓存的组播/广播帧（即PSMP-DTT1时刻内），然后按序发送节点所对应的缓存单播帧，这里PSMP-DTT时间内，帧间间隔可以采用RIFS，以达到更高的效率。对于ACK的部分，由于笔者没有做详细考证，所以没有加以描述。当PSMP-DTT时间结束后，节点会依次在自己对应的上行调度周期内，发送数据帧，如STA1就在PSMP-UTT1中发送上行数据。当PSMP-UTT时间结束后，这一轮PSMP的数据交换就完成了。

*PS：一些PSMP的细节在《Cambridge.Next Generation Wireless LANs.802.11n》一书第9章中，所述较为详细，有兴趣可以扩展阅读。*

## **SMPS（Spatial Multiplexing Power Save）**

最后，我们描述一下在802.11n中所叙述的SMPS模式，即多天线模式下的节能模式。在该模式下，节点可以选择关于多余的天线，从而达到节能目的。但在实际过程中，节点是不好贸然关闭自己的天线的，因为其无法确定AP是按照多空间流的形式，还是按照单空间流的形式向其发送数据。若AP采用多流发送下行数据，而节点仅仅是单根天线的工作模式，那么是无法正确接收的（这里与发送分集不同，若发送分集也是需要AP按照分集模式进行发送，而不是空分复用的形式发送，其预编码的策略不同）。所以节点要与AP有关关闭天线该动作，进行适当的沟通，那么该机制就对应到SMPS的使用。

- **SMPS（Spatial Multiplexing Power Save）**：该模式下，节点会关闭多余的天线，仅仅使用一根天线进行工作，从而达到节能的目的。在SMPS中还分为两种模式，一者静态工作模式（Static SM Power Save），一者动态工作模式（Dynamic SM Power Save）。

![img](https://pic1.zhimg.com/80/ab3e5969b57fa66ef0c0e08e4820912c_720w.png)

上图表示的是一个静态工作模式下的SMPS，其中我们可以看到，节点说先需要发送一个action frame，将AP切换为单流发送下行帧，以让节点节约一些能量。若需要恢复回多流工作模式，则需要反馈一个action frame，其中显式注明static mode disabled，从而AP接下来发送的帧才会是多流模式。

![img](https://pic3.zhimg.com/80/39e6d7cf9dba1013077c494eb7b915aa_720w.png)

上图是动态工作模式下的SMPS，其中当STA发送一个动态模式的action frame后，AP紧接着反馈的下行帧中就会采用单流模式（图中的下行帧是RTS，实际上也可以是数据帧）。当该帧反馈后，AP发送下一个帧的时候，则会回到默认发送的多流模式，主动从单流模式切换回来，而在静态模式中，这个切换需要一个显示的action frame，故这里就是静态和动态SMPS的一个区别。

*PS：一些SMPS的细节在《CWAP：Certified Wireless Analysis Professional Official Study Guide 》一书第10章中，所述较为详细，有兴趣可以扩展阅读。*

# 初探协议性能以及物理层速率计算

## **序言**

在初始的802.11协议版本之后，陆续更新的802.11e，以及802.11n以及更新的802.11技术，其都是基于改善当前802.11协议的缺陷不断进行改进的。为了理解这些改进，我们首先要理解802.11存在的一些问题，其中一个主要的问题就是性能问题。

本文我们先简单介绍802.11中一个常见问题，即路由器的宣称速率不等于实际速率的问题，然后我们具体分析一下这个宣称速率（即物理层速率）的计算方法。在后面一篇文章中，我们会介绍用数学方法对该吞吐量具体进行估计的方法，即Bianchi模型。

*PS：由于不是论文，所以本文还是以理解为主，对于表述和定义不追求毫无瑕疵，故有错误的话，还请见谅。*

## ***802.11的实际速率（即MAC层吞吐量）***

首先介绍一下802.11实际速率的定义，为了描述准确一些，我们一般称该实际速率为MAC层的吞吐量，如下图（参考Ekahau - Wi-Fi Capacity Analysis for 802.11ac and 802.11n）。

![img](https://pic3.zhimg.com/80/v2-a6f54eab2255a19754864fbfe3037212_720w.png)

**MAC层吞吐量：传输真实数据（即上图的Data，实际上对应MSDU部分）的传输速率，不好包含图上所述的overhead部分。**

如同之前我们介绍DCF以及CSMA/CA一样，在DCF的传输过程中，需要经过DIFS，Backoff，PPDU（MPDU+PHY Header），SIFS以及ACK这样几个过程。这些过程实际上都是作为MAC层协议的组成部分，而不属于真正的数据传输部分。我们统称这些MAC层的损耗叫做overhead，如果这些overhead越少且能够保证协议的基本性能（比如冲突概率）不变，那么该MAC协议的性能也就越优。为了更一般的对该性能作为参考，我们可以定义归一化的MAC层吞吐量，即MAC层的效率。

**MAC层传输效率：传输真实数据（Data）的时间占总传输时间（Overhead + Data）的比例。**

以下我们给出一个具体的示例进行参考：

![img](https://pic1.zhimg.com/80/v2-030675c37d5fbee6c8cfba85e4fe14e8_720w.png)

在上图（左）中，Payload transmission即真实数据部分（即绿色的部分，对应之前图中的Data），该绿色部分只占整个传输时间的大约12%，是很少的一个部分。在上图（右）中，由于采用了帧聚合技术，所以MAC层性能有一定的提高，可以增加到49%左右。

一般路由器上所标注的都是物理层的传输速率，但是这个速率是不可完全到达的，其真实有效的部分实际上是物理层速率乘以MAC层传输效率的一个结果。上图这里的12%与49%仅仅是一个参考，其性能我们可以更准确的用Bianchi模型分析出来**。**

因为之前在[802.11协议精读2：DCF与CSMA/CA](https://zhuanlan.zhihu.com/p/20721272?refer=dot11)，我们已经介绍了DCF的工作模式，所以我们就简单分析Overhead中不同的组成部分：

1. **Physical layer wait times（对应时序图，DIFS，Backoff，SIFS）**：这里实际上是指802.11协议定义的接入前需要等待的一段时间。由于无线信道只有一个，好比一个教室一样，如果有两个同学同时说话，那么老师就无法听清楚两者的说话，故需要设置Backoff的机制来避免碰撞。
2. **Physical layer frame（对应时序图，PHY）：**一个802.11数据帧的最开始是物理层的头部（PHY），其是用来传递一些具体接收MPDU时候需要的参数。协议中，一般物理层头部都是采用最低速率进行发送（即公共已知的，比如6Mbps），而上层数据的速率是包含在数据包内部的（比如54Mbps）。由于该PHY的采用低速传输，所以占总时间的比重较大。该物理层头部具体的组成可以参考（[802.11协议精读6：802.11b的发送过程与接收过程](https://zhuanlan.zhihu.com/p/21483155?refer=dot11)，[802.11协议精读7：802.11a/g的发送过程与接收过程](https://zhuanlan.zhihu.com/p/21485216?refer=dot11)）。
3. **Mac layer overhead（对应时序图，MAC header，FCS，ACK）：**主要是MAC层中的一些参数，用来标识是哪个节点进行传输以及传输目的为哪个节点，同时还包含了一些MAC层的控制信息，同时该部分时间还包含了ACK反馈的时间。由于MAC头部是以高速率进行发送的，所以占时间的比重较少。
4. **Retransmission frame（时序图中未体现）：**在802.11中是有可能存在传输失败的，比如（信号质量差或者发生碰撞）。在冲突之后，节点是需要对数据进行重传。重传的过程是一个完整的重新传输的过程，从而也会浪费更多的时间。为了减少重传时间这样比较大的时间浪费，协议设计时就会尽量减少发生重传的概率。

以上都是一个简单的分析，之后我们会在介绍Bianchi模型时进行更具体的分析。

## **802.11的物理层速率**

前面我们叙述了一下802.11实际速率，即MAC层吞吐量的部分。以下我们着重介绍一下802.11的物理层速率以及其具体计算方法。在802.11中一共规定了4中基本工作模式（DSSS，FHSS，IR，以及OFDM），其中基于DSSS的802.11b以及基于OFDM的802.11a/g/n/ac都被较多的使用。本节我们分别以802.11b以及802.11g举例介绍下计算方式。

**DSSS（802.11b）**

DSSS是基于直序扩频的工作方式，其中每一个数据Bit都被映射到一个扩频序列进行发送。扩频序列是一个特殊的二元脉冲序列，其中每一个脉冲我们称之为一个码片（chip）。在这个码片内的那个1和0是不承载信息（即数据Bit），信息是通过识别整个码片来传递的，即多个码片代表一个数据Bit。在802.11b中，采用了Barker码和CCK码这两种扩频序列。在802.11b中，码片速率（chip rate）代表每秒发送或者接收的码片数目，协议中为11Mchip/s。

![img](https://pic2.zhimg.com/80/v2-0c8dcb9d37bf724135c88ec0cd6e30d5_720w.png)

如上图，符号/码片比对应特定的扩频编码方式（包含扩频序列和编码方式）。

**DSSS物理层的速率 = 调制阶数 \* 码片速率 \* 符号/编码比**

以上图的802.11b为例，调制阶数是DBPSK即为1，符号/码片比为1/11（即默认的barker码，用11位的扩频序列代表1个bit），故 1 * 1/11 * 11Mchip/s = 1Mbps。

**OFDM（802.11g）**

OFDM是采用正交子载波进行工作的一种模式，即将整个数据信道分解成很多个子载波，这些子载波在数学上是正交的，比如在802.11a中，有用的数据子载波就是48个（详细的是64个子载波，其中48个是数据子载波，4个导频子载波，1个DC子载波不使用，其余的都是用来做保护的虚拟子载波，具体图例[参考](https://zhuanlan.zhihu.com/p/21952348/goog_180812726)[802.11协议精读8：再论802.11a/g的发送过程与接收过程](https://zhuanlan.zhihu.com/p/21496609?refer=dot11)）。

在OFDM机制下，发送方发送的实际上是一个个symbol，比如一个帧就是由 [ symbol_1 symbol_2 symbol_3 ... symbol_xx]，这样组成的，当子载波给定的情况下（比如802.11a就是固定48个有效子载波），那么其symbol的周期就是固定的，不会随着速率变化而变化，在802.11a中，该symbol周期就是4us。在给定symbol周期的情况下，发送速率实际上是由这个symbol上所能够携带的信息量决定的，而这个信息量又是又调制方式和编码速率决定的。

![img](https://pic4.zhimg.com/80/v2-df0c2b868ec6b2b0906d8422fd05c827_720w.png)

如上图，这里的调制就是对应的调制方式，FEC速率就是对应的编码速率。

**OFDM物理层的速率 = （数据子载波数目 \* 调制阶数 \* 编码效率) / (symbol周期）**

以上图的802.11a为例，数据子载波数目为48个，调制阶数是16QAM即为4，编码速率为1/2（可以简单理解编码速率为冗余度，即将1个bit传输2次，避免错误），故 [ 48*4*(1/2) ] / 4us = 24Mbps。若速率越高，那么对信号质量的要求越高（即灵敏度要求越高，参考下图，07版协议第617页）。

![img](https://pic4.zhimg.com/80/v2-8bec84e016dbb58c845fcd3bb66030c3_720w.png)

其中Minimum sensitivity (dBm) 一栏就描述的是接收方需要的接收灵敏度，该数值也高（比如-65dBm就比-82dBm要高17dB）。信号越好，传输速率才可以达到更高。

# 协议理论性能（Bianchi模型）

## **序言**

为了更好理解一些802.11的后续设计，我们需要深入了解一下802.11的协议性能。我们之前简单描述了下协议性能的部分，这一段我们讨论下具体数学模型下的802.11性能（Bianchi模型）。

Bianchi模型出自于论文《Performance Analysis of the IEEE 802.11 Distributed Coordination Function》，该论文在2000年的时候发表在JSAC（IEEE Journal on selected areas in communications）上，根据google scholar上的记录，该论文的他引次数已经高达8267次（相应的资源：[bianchi模型](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9707826)）。其实关于802.11的理论性能从协议刚开始出来的时候就有人研究，直到现在，这个问题还是在继续研究中，该论文是这个领域中最为有代表性的一篇文章，故凡是做802.11协议的，都会阅读理解这篇文章。

*PS：本文并不是按照Bianchi原文以推导的形式给出，而是为了方便理解进行的倒叙。其中部分表述和定义如果存在一些错误，还请见谅。*

## **Bianchi模型的假设**

我们首先列举一些Bianchi模型中，所设定的一些假设。

- **Single-cell Network**：可以简单认为是个单信道环境，即所有节点共享一个功能信道，并且这个网络中，所有的节点都是互相可以监听到对方的。
- **The collision processes of the nodes can be decoupled**：即无论节点重传了几次，其在传输时候的冲突概率都是一个定值，且都是相对独立的。
- **Channel conditions are ideal**：信道是一个理想信道，即传输错误仅仅由于传输碰撞造成，与物理层的信道质量无关。且由于Single-cell的假设，所有节点都可以互相监听，所以网络中也没有隐藏和暴露终端问题。
- **Saturation throughput**：Bianchi模型分析为饱和情况下的吞吐量，即任意一个节点都是假设有数据包的，不存在节点竞争到信道之后，没有数据包待发送的情况出现。
- **No packet dropped**：按照协议所述，如果数据包发送失败，节点是可以发起重传的。这个重传次数上限为6次，如果超过该次数，那么就需要丢包。而在Bianchi模型中，保留的重传次数上限为6次的这个设置，不过没有设定6次以后进行丢包，而是一直保持在第6次这个状态进行重传。

## **MAC层效率（归一化吞吐量）**

在之前的一篇文章中，我们定义了MAC层的归一化吞吐量为传输真实数据（Data）的时间占总传输时间（Overhead + Data）的比例。

在Bianchi模型中，其具体定义如下（部分表述有稍微修饰一下）

![img](https://pic2.zhimg.com/80/v2-7817c73a7e48b99cce4084668b643ac5_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=S)为归一化吞吐量（注：本文讨论的吞吐量都是系统的吞吐量，没有具体到某一个节点的吞吐量上，而是所有节点整体的吞吐量），分子分母都是一个数学期望，实际上就是平均时间。分母代表的是Generic slot（这个后面我们说明，与DCF中的标准slot时间存在区别），分子定义的是在这个Generic slot内，传输数据的时间。不严格的说，其物理意义和我们之前一篇描述的定义是一样的。

**Generic Slot：这个是一个随机选择的时间，其与802.11中DCF的具体接入机制有关。一般意义上，我们理解其物理意义就是Backoff counter倒数1次的时间间隔。**

![img](https://pic3.zhimg.com/80/v2-94113ab0d94f0a8a1ec5216b4501a95e_720w.png)

如上图为Generic slot的3种可能取值。其中![[公式]](https://www.zhihu.com/equation?tex=%5Csigma+)代表协议中的slot时间（比如802.11g中的9μs），![[公式]](https://www.zhihu.com/equation?tex=T_%7Bs%7D+)为成功传输所花费的总时间，![[公式]](https://www.zhihu.com/equation?tex=T_%7Bc%7D+)为碰撞一次所花费的总时间。![[公式]](https://www.zhihu.com/equation?tex=P_%7Btr%7D+)为至少有一个节点准备发送的概率，![[公式]](https://www.zhihu.com/equation?tex=P_%7Bs%7D+)为成功传输的概率（实际上理解成只有1个节点传输的概率，如果有多个那么就会造成冲突）。我们进一步阐述如下：

- **情况1 —** ![[公式]](https://www.zhihu.com/equation?tex=%5Csigma+)：若节点在Backoff过程中，经过1个slot，backoff counter未倒数到0。这个概率为![[公式]](https://www.zhihu.com/equation?tex=1-P_%7Btr%7D+)，消耗的时间就是一个slot，即![[公式]](https://www.zhihu.com/equation?tex=%5Csigma+)时间。

若节点经过这个slot，backoff counter正好倒数到0，那么节点就会发送数据（即概率![[公式]](https://www.zhihu.com/equation?tex=P_%7Btr%7D+)）。但是发送后，这里还存在两种情况，一者发送成功，一者发送失败。

- **情况2 -** ![[公式]](https://www.zhihu.com/equation?tex=T_%7Bs%7D+)：若节点成功发送该数据，那么损耗时间为![[公式]](https://www.zhihu.com/equation?tex=T_%7Bs%7D+)，其对应概率为![[公式]](https://www.zhihu.com/equation?tex=P_%7Btr%7D%2AP_%7Bs%7D)，即不仅发送，且发送成功。
- **情况3 -** ![[公式]](https://www.zhihu.com/equation?tex=T_%7Bc%7D+)：若节点发送数据，但是由于冲突（比如多个节点backoff counter倒数同时至0），那么这个数据帧是没有无法成功被接收的，这个损耗的时间就是![[公式]](https://www.zhihu.com/equation?tex=T_%7Bc%7D+)。其对应概率为![[公式]](https://www.zhihu.com/equation?tex=P_%7Btr%7D%2A%5Cleft%28+1-P_%7Bs%7D+%5Cright%29+)，即虽然发送，不过发送失败。

具体的![[公式]](https://www.zhihu.com/equation?tex=T_%7Bs%7D+)和![[公式]](https://www.zhihu.com/equation?tex=T_%7Bc%7D+)还与节点的工作模式有关（Basic模式或者RTS/CTS模式），我们分别解释：

**Basic模式：**该模式的简单流程如下图：

![img](https://pic2.zhimg.com/80/v2-6c95c92f84881afb21ff86eac4eebe05_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=T_%7Bs%7D+)和![[公式]](https://www.zhihu.com/equation?tex=T_%7Bc%7D+)的时间如下：

![img](https://pic1.zhimg.com/80/v2-9a3821feb7f30375b524959e7f3689e8_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=H)代表物理层头部的传输时间，![[公式]](https://www.zhihu.com/equation?tex=SIFS)和![[公式]](https://www.zhihu.com/equation?tex=DIFS)都是协议给定的帧间间隔，![[公式]](https://www.zhihu.com/equation?tex=ACK)为协议给定的ACK帧的传输时间，![[公式]](https://www.zhihu.com/equation?tex=%5Cdelta)为电磁波传播延迟（DATA-ACK过程由于是一来一回，所以传播延迟是两个）。![[公式]](https://www.zhihu.com/equation?tex=E%5Cleft%5B+P+%5Cright%5D+)为payload的期望，代表数据包（MSDU）传输时间的均值。![[公式]](https://www.zhihu.com/equation?tex=E%5Cleft%5B+P%5E%7B%2A%7D++%5Cright%5D+)代表的是发生冲突时，冲突中较长数据帧的均值，因为冲突只有在较长数据帧发送完之后，信道才被释放。

**RTS/CTS模式**：该模式的简单流程如下图：

![img](https://pic3.zhimg.com/80/v2-5d60dd043700e90c34853e912faa7002_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=T_%7Bs%7D+)和![[公式]](https://www.zhihu.com/equation?tex=T_%7Bc%7D+)的时间如下：

![img](https://pic3.zhimg.com/80/v2-ca3ce0f8d60dc9cb55776ed8751cddea_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=RTS)和![[公式]](https://www.zhihu.com/equation?tex=CTS)代表其数据帧对应的传输时间。上图中我们可以发现，RTS/CTS模式下，虽然传输时间是相应增加了（由于引入了RTS/CTS握手），但是冲突损耗是减少了。该设计能够保证，这个在节点较多的情况下（即碰撞概率较大的情况下），RTS/CTS的性能受到较小的影响。

本文为了简化，我们直接假设所有节点的数据包大小是一个定值，从而![[公式]](https://www.zhihu.com/equation?tex=E%5Cleft%5B+P+%5Cright%5D+)就等于传输这个数据包所花费的时间，且![[公式]](https://www.zhihu.com/equation?tex=E%5Cleft%5B+P+%5Cright%5D+%3DE%5Cleft%5B+P%5E%7B%2A%7D++%5Cright%5D+)。（在bianchi原文中没有进行该假设，只是为了简化本文的叙述，所以我们做数据包大小为定值的假设）

综合以上的Generic slot和其对应时间，我们可以具体给出归一化吞吐量![[公式]](https://www.zhihu.com/equation?tex=S)的具体计算公式。

![img](https://pic4.zhimg.com/80/v2-75f4074abe6d3b992d02859ae1b1f88b_720w.png)

其中分母就是Generic slot的均值（即事件概率乘以其对应时间），分子为在一个Generic内，成功传输数据（MSDU）部分的时间。

## **传输概率（![[公式]](https://www.zhihu.com/equation?tex=P_%7Btr%7D+)）和成功传输概率（![[公式]](https://www.zhihu.com/equation?tex=P_%7Bs%7D+)）**

前面我们给出了归一化吞吐量![[公式]](https://www.zhihu.com/equation?tex=S)的表达式，该式中，由于![[公式]](https://www.zhihu.com/equation?tex=T_%7Bs%7D+)和![[公式]](https://www.zhihu.com/equation?tex=T_%7Bc%7D+)中的参数都是协议给定。为了计算吞吐量，我们只要求出概率![[公式]](https://www.zhihu.com/equation?tex=P_%7Btr%7D+)和![[公式]](https://www.zhihu.com/equation?tex=P_%7Bs%7D+)就行了。

![img](https://pic4.zhimg.com/80/v2-5d480ab73b21b3ec8ac341910b3c6ad3_720w.png)

- ![[公式]](https://www.zhihu.com/equation?tex=P_%7Btr%7D+)：其物理意义是至少有一个节点，在这个slot内准备传输。这里![[公式]](https://www.zhihu.com/equation?tex=%5Ctau+)指的是发送概率，![[公式]](https://www.zhihu.com/equation?tex=n)指的是总的竞争节点数目（由于假设是one-cell network，并且饱和吞吐量，所以所有节点都在竞争信道）。我们可以这样理解![[公式]](https://www.zhihu.com/equation?tex=P_%7Btr%7D+)的物理意义：![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%28+1-%5Ctau++%5Cright%29+)代表其中某![[公式]](https://www.zhihu.com/equation?tex=1)个节点没有发送的概率，![[公式]](https://www.zhihu.com/equation?tex=%5Cleft+%28+1-%5Ctau++%5Cright+%29%5E%7Bn%7D)所有节点都没有发送的概率，所以其反面，![[公式]](https://www.zhihu.com/equation?tex=1-%5Cleft+%28+1-%5Ctau++%5Cright+%29%5E%7Bn%7D)就是至少有![[公式]](https://www.zhihu.com/equation?tex=1)个节点可以发送的概率了。

![img](https://pic2.zhimg.com/80/v2-397cc2c8927f375ee1b125c0cf32b2f1_720w.png)

- ![[公式]](https://www.zhihu.com/equation?tex=P_%7Bs%7D+)：这个实际上是个条件概率，物理意义是在有节点发送的前提下（即分母的![[公式]](https://www.zhihu.com/equation?tex=P_%7Btr%7D+)），成功传输的概率（即有且只有一个节点正在传输）。分子我们可以这样理解：![[公式]](https://www.zhihu.com/equation?tex=%5Ctau%5E%7B1%7D++%2A+%5Cleft%28+1-%5Ctau+%5Cright%29+%5E%7Bn-1%7D+)，其中![[公式]](https://www.zhihu.com/equation?tex=%5Ctau%5E%7B1%7D+)代表代表有![[公式]](https://www.zhihu.com/equation?tex=1)个节点正在发送，![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%28+1-%5Ctau+%5Cright%29+%5E%7Bn-1%7D+)代表其余![[公式]](https://www.zhihu.com/equation?tex=n-1)个节点都没有发送，即有且只有一个节点发送，那么才没有冲突。又是因为这个节点没有固定下来说，具体某一个节点，所以要做个排列组合，即一共![[公式]](https://www.zhihu.com/equation?tex=n)个节点，即![[公式]](https://www.zhihu.com/equation?tex=n)中情况，所以分子再乘以![[公式]](https://www.zhihu.com/equation?tex=n)。

上面我们介绍了![[公式]](https://www.zhihu.com/equation?tex=P_%7Btr%7D+)和![[公式]](https://www.zhihu.com/equation?tex=P_%7Bs%7D+)的具体表达式，其中![[公式]](https://www.zhihu.com/equation?tex=n)是节点数目，所以一般也是给定的。所以最后剩下来的参数就是![[公式]](https://www.zhihu.com/equation?tex=%5Ctau)了，我们需要对该参数进行分析。

## **发送概率（![[公式]](https://www.zhihu.com/equation?tex=%5Ctau)）和冲突概率（**![[公式]](https://www.zhihu.com/equation?tex=p)**）**

通过以上分析，我们最终只要知道每一个节点的发送概率![[公式]](https://www.zhihu.com/equation?tex=%5Ctau)就可以求出吞吐量了，但是这个![[公式]](https://www.zhihu.com/equation?tex=%5Ctau)就没有那么好求了，其主要是源于802.11协议中，发送和冲突是互相影响的。发送概率![[公式]](https://www.zhihu.com/equation?tex=%5Ctau)中包含了冲突概率![[公式]](https://www.zhihu.com/equation?tex=p)，而冲突概率![[公式]](https://www.zhihu.com/equation?tex=p)中也包含了发送概率![[公式]](https://www.zhihu.com/equation?tex=%5Ctau)。

以下我们描述一下bianchi模型中具体分析的过程。bianchi模型实际上采用了一个二维的Markov chain，具体如下图：

![img](https://pic3.zhimg.com/80/v2-8d14f10146bacc93b9087b6d67d5188e_720w.png)

我们先简单说明下其中的一些参数，然后在具体讨论。每一横行代表的是一次Backoff过程，每一纵行代表的是一次二进制指数增加CW窗口大小的过程。以第1行为例说明如下：

- 状态![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%28+0%2CW_%7B0%7D-1++%5Cright%29+)，![[公式]](https://www.zhihu.com/equation?tex=0)代表是第0次的Backoff过程（即CW窗口是默认大小），![[公式]](https://www.zhihu.com/equation?tex=W_%7B0%7D-1)代表Backoff counter选取数值为![[公式]](https://www.zhihu.com/equation?tex=W_%7B0%7D-1)（由于CW范围是从0开始，所以最大数值为![[公式]](https://www.zhihu.com/equation?tex=CW-1)），![[公式]](https://www.zhihu.com/equation?tex=W_%7B0%7D)就是第0次Backoff时候的CW大小。

- 状态![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%28+0%2CW_%7B0%7D-1++%5Cright%29+)转移至![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%28+0%2CW_%7B0%7D-2++%5Cright%29+)代表了1次Backoff counter的回退（如图中红色1标识），其概率为![[公式]](https://www.zhihu.com/equation?tex=1)（因为不存在碰撞）。

- 当Backoff counter倒数至0后，即转移至状态![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%28+0%2C0+%5Cright%29+)时，节点可以发送数据。

- - 若发送成功（即概率![[公式]](https://www.zhihu.com/equation?tex=1-p+)），如图中红色2标识，就需要重新在CW窗口内选择一个随机数（即某个随机数被选中的概率为![[公式]](https://www.zhihu.com/equation?tex=1%2F+W_%7B0%7D+)），并转移到该状态（比如转移到状态![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%28+0%2C1+%5Cright%29+)，其转移概率为![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%28+1-p+%5Cright%29+%2F+W_%7B0%7D+)）。
  - 若发送失败（即概率![[公式]](https://www.zhihu.com/equation?tex=p+)），如图中红色3标识，那么需要首先调节CW窗口大小（指数为2增长），即![[公式]](https://www.zhihu.com/equation?tex=W_%7B0%7D)变为![[公式]](https://www.zhihu.com/equation?tex=W_%7Bk%7D)，在第二轮中，![[公式]](https://www.zhihu.com/equation?tex=k%3D1)。然后节点需要在更新后的CW窗口大小![[公式]](https://www.zhihu.com/equation?tex=W_%7B1%7D)中选择一个随机数（概率为![[公式]](https://www.zhihu.com/equation?tex=1%2F+W_%7B1%7D+)），并转移至该状态（比如转移到状态![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%28+1%2C1+%5Cright%29+)，其转移概率为![[公式]](https://www.zhihu.com/equation?tex=p++%2F+W_%7B1%7D+)）。

- 在Bianchi模型中，假设是没有丢包过程的。而二进制指数回退并不是上限无穷的增加CW窗口，其有个最大次数![[公式]](https://www.zhihu.com/equation?tex=m)次，在bianchi模型中。如果节点第m次回退后，还是发送失败，则不增加CW窗口大小，而是直接在这一轮设置的CW大小（![[公式]](https://www.zhihu.com/equation?tex=W_%7Bm%7D)）中，直接选择一个随机数进行重传（这个概率就是![[公式]](https://www.zhihu.com/equation?tex=p++%2F+W_%7Bm%7D+)）。

更一般的我们用数学标识即是下面的式子：

![img](https://pic1.zhimg.com/80/v2-3fd5d70d21a627ea65d0e21f3e4fb5d0_720w.png)

下面我们先表示冲突概率

![img](https://pic2.zhimg.com/80/v2-9338240b5aab5e5b25a18a2f28da62e5_720w.png)

由于Bianchi模型中，已经假设节点之间的冲突过程是相对独立的。假设我现在是某个节点，我已经处于发送状态，所以剩余的![[公式]](https://www.zhihu.com/equation?tex=n-1)个节点都不能够发送（即概率![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%28+1-%5Ctau++%5Cright%29+%5E%7Bn-1%7D+)），如果有任意一个也处于发送状态（即概率![[公式]](https://www.zhihu.com/equation?tex=1-%5Cleft%28+1-%5Ctau++%5Cright%29+%5E%7Bn-1%7D+)），那么就会发生冲突。

最终我们考虑发送概率![[公式]](https://www.zhihu.com/equation?tex=%5Ctau)，参考下图

![img](https://pic2.zhimg.com/80/v2-91370288dbb07c3b80d4771e854f9a41_720w.png)

协议规定，如果节点Backoff counter倒数到0，那么就可以进行发送。由于节点可能处在不同的backoff状态（即初次传输，重传1次，重传2次等等），所以我们需要对转移到这些状态的概率做一个累加，即：

![img](https://pic3.zhimg.com/80/v2-b9c9173d5b0032a75bc6b11a2ecc68da_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=m)代表CW最多增加![[公式]](https://www.zhihu.com/equation?tex=m)次，![[公式]](https://www.zhihu.com/equation?tex=i)是个index，代表第![[公式]](https://www.zhihu.com/equation?tex=i)次Backoff过程，![[公式]](https://www.zhihu.com/equation?tex=b)代表状态，![[公式]](https://www.zhihu.com/equation?tex=b_%7Bi%2C0%7D+)代表第![[公式]](https://www.zhihu.com/equation?tex=i)次Backoff counter倒数到0。因为每一次发送完之后，节点都必须要转移到状态![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%28+0%2C0+%5Cright%29+)。所以我们可以直接计算转移到状态![[公式]](https://www.zhihu.com/equation?tex=b_%7B0%2C0%7D+)的条件概率。即如果发送没有发生冲突（即概率![[公式]](https://www.zhihu.com/equation?tex=1-p)），状态转移至![[公式]](https://www.zhihu.com/equation?tex=b_%7B0%2C0%7D+)的概率（即![[公式]](https://www.zhihu.com/equation?tex=%5Cfrac%7Bb_%7B0%2C0%7D%7D%7B1-p%7D+)）。

最后我们表示出![[公式]](https://www.zhihu.com/equation?tex=b_%7B0%2C0%7D+)状态时候的稳态概率即可

![img](https://pic1.zhimg.com/80/v2-46bdf6fa2d3cbd47c797299f368eaa00_720w.png)

这个概率的物理意义有些繁杂，我们就不进行展开了，最终我们可以计算发送概率为：

![img](https://pic2.zhimg.com/80/v2-5bc7ba80330bbccbb919b912e5bdd901_720w.png)

从而获得以下的一个联立的方程（其中上式的![[公式]](https://www.zhihu.com/equation?tex=%5Ctau+)和下面的联立表达还有一个参数带入的步骤，具体可以参考论文，这里直接跳跃到下面的结果了）：

![img](https://pic1.zhimg.com/80/v2-d10554c59b838e7758cef8eeef0aec98_720w.png)

我们看到上面的表达中，![[公式]](https://www.zhihu.com/equation?tex=p)表达式中包含![[公式]](https://www.zhihu.com/equation?tex=%5Ctau+)，同样![[公式]](https://www.zhihu.com/equation?tex=%5Ctau+)中表达式也包含![[公式]](https://www.zhihu.com/equation?tex=p)。故我们需要采用fix-point的方法，才可以对其进行求解。具体求解方法我们在下一篇文章中进行讨论。

## **结果分析**

以下我们直接参考Bianchi论文中给出的结果，大致说明一下：



![img](https://pic4.zhimg.com/80/v2-ef6484d18fd0f1c0df3f28d168a6f16f_720w.png)

上图横轴代表节点数目（节点数目从0到50），纵轴代表归一化吞吐量（即范围从0~1，图中是从0.5开始绘制）。图中一共绘制5组结果：

- ![[公式]](https://www.zhihu.com/equation?tex=%5Ctriangle+)代表Basic模式下，初始的CW窗口设置为32，CW窗口可以回退增大3次。
- ![[公式]](https://www.zhihu.com/equation?tex=%5Csquare+)代表Basic模式下，初始的CW窗口设置为32，CW窗口可以回退增大5次。
- ![[公式]](https://www.zhihu.com/equation?tex=%5Ccirc+)代表Basic模式下，初始CW窗口设置为128，CW窗口可以回退增大3次。

从这三组值的对比上可以看出，节点数越多，Basic模式的性能越差。其基本原因就是冲突概率的增加。通过增加CW窗口大小的方法，能够一定程度上避免冲突问题，所以能够缓解随着节点数增加，而造成的吞吐量下降。初始设置更大的CW比增加回退次数要更有效一些。

- ![[公式]](https://www.zhihu.com/equation?tex=%5Cast+)代表RTS/CTS模式下，初始的CW窗口设置为32，CW窗口可以回退增大3次。
- ![[公式]](https://www.zhihu.com/equation?tex=%5Cdiamond)代表RTS/CTS模式下，初始的CW窗口设置为128，CW窗口可以回退增大3次。

在RTS/CTS模式下，可以发现其吞吐量相比Basic模式，能够在节点数较多的时候，受到较小的影响，其基本原因在于冲突损耗上。Basic模式冲突一次是损失了一个数据帧的时间，而RTS/CTS模式下，冲突一次仅仅损耗了一个RTS时间。同时我们还可以看到，由于冲突损失较小的情况下，我们没有必要设置更大的CW窗口大小，因为更大的窗口大小就意味着更多的回退次数，从而消耗更多的时间。

# 协议理论性能（仿真验证）

## **序言**

前面我们已经讨论了802.11的性能，以及其理论模型，为了验证理论模型，我们大致做一个仿真验证。本文主要介绍笔者在研究过程中写的一个简化版的仿真模型，至于NS2，NS3，OPNET这些，由于整体代码较为繁杂，所以我们不加以扩充。

本项目已经开源在github上：[SimWiFi](https://link.zhihu.com/?target=https%3A//github.com/fzxy002763/SimWiFi)（注：目前还没有把ReadMe写完，并且这份代码是从我另外一个仿真简化而来，所以有些参数还没有优化好，导致相对误差还比较大），其中包含了求解Bianchi模型的MATLAB代码，以及仿真DCF的C++代码，以及一个简单的Powershell脚本。

## **求解Bianchi模型的理论性能**

参考Bianchi模型中我们的叙述：[802.11协议精读13：理论协议性能（Bianchi模型）](https://zhuanlan.zhihu.com/p/24302361?refer=dot11)。在之前的叙述中，我们已经说明，只要能够计算出发送概率![[公式]](https://www.zhihu.com/equation?tex=%5Ctau+)，就可以一步一步推导出理论性能。而发送概率![[公式]](https://www.zhihu.com/equation?tex=%5Ctau+)和冲突概率![[公式]](https://www.zhihu.com/equation?tex=p)是一个fix-point问题，如下式：

![img](https://pic1.zhimg.com/80/v2-d10554c59b838e7758cef8eeef0aec98_720w.png)

以下我们简单介绍如何用Matlab的fsolve函数对此进行求解。

fslove函数是Matlab用来做方程求解的，与solve函数不同，前者是采用迭代法进行数值求解，后者是符号求解（即可以写出具体的求解表达式）。我们前面的方程实际上是不好直接写出表达式的，所以我们采用fslove函数进行求解。

x = fsolve(fun,x0,options)

fsolve的调用格式如上，其中fun是以句柄的形式写入的，x0是初值，options是一些具体的参数。比如：x = fsolve(@(x) sin(3*x),[1],optimoptions('fsolve','Display','iter'))，其中句柄就是（@(x) sin(3*x)），初值是[1]，求解的过程按照迭代的形式进行显示。

在具体求解Bianchi模型中的发送概率![[公式]](https://www.zhihu.com/equation?tex=%5Ctau+)和冲突概率![[公式]](https://www.zhihu.com/equation?tex=p)的时候，我们采用单独新建一个函数的形式来做函数句柄（一者这样表述方便，二者是![[公式]](https://www.zhihu.com/equation?tex=%5Ctau+)中含有一个求和式，所以不好用一个函数形式进行表达）。

代码如下（在开源项目中都已经包含了这些文件），其中还可以看到声明了三个global参数，分别是CW窗口大小![[公式]](https://www.zhihu.com/equation?tex=CW_%7Bmin%7D+)，回退次数![[公式]](https://www.zhihu.com/equation?tex=m)，节点数目![[公式]](https://www.zhihu.com/equation?tex=nodeNum)，这些在求解中实际上是以参数的形式传入的，不过由于这里参数的函数句柄用来做fsolve求解，所以就采用globe的形式进行传参。

![img](https://pic3.zhimg.com/80/v2-5f26743607b7ccbbd66396c282950d46_720w.png)

具体调用如下（注：调用之前需要用global参数设置![[公式]](https://www.zhihu.com/equation?tex=CW_%7Bmin%7D+)，![[公式]](https://www.zhihu.com/equation?tex=m)，![[公式]](https://www.zhihu.com/equation?tex=nodeNum)三个参数）：

![img](https://pic2.zhimg.com/80/v2-daae98aa46540326c3a16ebde1c5bbbd_720w.png)

开源代码中我应该是用的alpha和beta的表述，实际意义是和![[公式]](https://www.zhihu.com/equation?tex=p)，![[公式]](https://www.zhihu.com/equation?tex=%5Ctau+)相同的。然后按照之前所列的公式，一步一步计算即可。

## **DCF仿真（FSM思路）**

这一节我们讨论下协议仿真的思路，大部分802.11协议的仿真，或者说网络的仿真都是基于离散随机事件的，换言之是基于事件触发的仿真机制。为了一些特殊的仿真需要，即在时间轴上，具体执行某一个事件，仿真在这个事件执行过程中是否有别的事情发生，所以我们设置了一个基于时间触发的仿真机制，并用此机制来做802.11协议的仿真。

在具体的仿真中，我们采用有限状态机（Finite State Machine、FSM）的思路，即用时间触发来驱动每一个节点中的FSM。基于OOP的思想，我们将每一个节点封装成一个类。类中用一些成员变量来记录节点的一些参数和状态，比如SIFS，DIFS之类。并且同一个时间，节点只能处于一个发送状态。

![img](https://pic4.zhimg.com/80/v2-e9c06cd910da243fb46c734b9aab29cb_720w.png)

如上图，总的是有一个时间轴（比如从![[公式]](https://www.zhihu.com/equation?tex=0%5Cmu+s)到![[公式]](https://www.zhihu.com/equation?tex=100+s)），然后有一个公共信道channel，信道有两种状态：idle和busy。

节点上还另外有一个计时器，当时间轴上的时间大于节点的定时的时候，那么节点执行一次状态机的切换（在节点类中，进行状态切换）。每一个单元时间（比如说![[公式]](https://www.zhihu.com/equation?tex=1%5Cmu+s)），节点都做一次与时间轴同步时间的工作，比如说上图，第![[公式]](https://www.zhihu.com/equation?tex=0%5Cmu+s)的时候，节点执行一次状态机切换（即IDLE_STATE往Backoff_STATE切换），然后执行DIFS和Backoff counter初始化的动作（具体见代码）。然后节点在第![[公式]](https://www.zhihu.com/equation?tex=0%5Cmu+s)到DIFS时间内，节点只做时间同步的工作，不做状态切换。当第DIFS时间到达后，节点再将状态从Backoff STATE切换到SEND_STATE。

此时由于节点（Node）处于发送状态，那么就将信道至忙。其他的节点在执行过程中，会检测信道的状态，如果发现信道忙，那么其他的节点就什么都不做，仅仅空置这一个单位时间即可。其中每一个节点的FSM状态机设置如下：

![img](https://pic3.zhimg.com/80/v2-a2d2cc7671ec14b824185e41621d85e6_720w.png)

- IDLE_STATE：初始状态。若节点没有选择Backoff counter，那么随机选择一个。若有，就保持不变。并且每一次Backoff前执行（包含frozen后的Backoff）等待DIFS的动作。
- BACKOFF_STATE：在DIFS时间后，节点转移到BACKOFF_STATE，在该状态下，节点每经过一个Slot，倒数一次Backoff counter。若在该Slot过程中，如果发现信道忙，则延迟该Slot的计时器，直到信道idle时，再继续倒数。当Backoff counter倒数至0时，转移到SEND_STATE。
- SEND_STATE：当转移到该状态后，节点发送数据帧。即设置计时器为数据帧传输时间（包含ACK），并且将信道设置为busy状态。当传输完成后，即转移至RECEIVE_STATE。
- RECEIVE_STATE：如果传输过程中，主时间轴没有发现冲突发生，并且这一次传输没有信道影响（通过概率判断），即代表本次传输成功。那么节点在RECEIVE_STATE状态内，记录发送成功一个数据帧，并将CW窗口大小至为![[公式]](https://www.zhihu.com/equation?tex=CW_%7Bmin%7D+)。成功接收后，信道置为idle，节点状态转移至IDLE_STATE。
- COLLISION_STATE：当SEND_STATE后，我们通过主时间轴上，判断是否有两个或者两个以上节点同时进入了SEND_STATE。如果有的话，那么就意味着冲突发生，此时这些冲突节点都进入了COLLISION_STATE，并将其CW窗口大小翻倍（这个是在主时间轴上做的）。由于节点可能发送的数据包长度不同（虽然仿真默认是相同的），当其中最长的数据帧发送完之后，转入ACKTIMEOUT_STATE，并将系信道释放，即置为idle。
- ACKTIMEOUT_STATE：该状态由于没有成功发送数据包，所以不进行数据包个数上的记录，然后直接转移回IDLE_STATE。

以上就是一个仿真的基本思路，通过这种方法能够较为直观理解下，仿真DCF的随机接入机制。不过基于时间驱动的仿真缺点就在于耗时，笔者之前的一个版本是用matlab写的，就是因为运行时间原因，所以修改到C++上运行，以上仿真思路仅供参考，如有错误，还请见谅。

# 链路模型（基于Free-Space Path Loss）

## **序言**

在无线局域网中，主要的性能除了吞吐量之外，另外一项比较受人关注的就是覆盖范围，而为了计算Wi-Fi的覆盖范围，我们首先要梳理其链路模型。本文我们基于基本的自由空间传输损耗模型（Free-space path loss），对802.11中的链路模型进行分析。



*注：在该文之后，我们会基于在理解链路模型的基础上，继续讨论如何计算无线的覆盖范围，以及具体在802.11协议中的具体信道模型。由于主要还是偏向理解，所以若在本文中出现一些表述错误，还请见谅。*

**影响覆盖范围（无线链路质量）的因素**

Wi-Fi的理论覆盖范围与很多因素有关，我们简单列举如下：

- **发送功率**：发送功率越大，信号的覆盖范围就越大。FCC建议其标准值为70mW。

- **功率放大增益**：包含发送时候的PA（Power Amplifier）以及接收时候的LNA（Low Noise Amplifier）。如果本地能够对信号提供一个放大的功能，那么信号的强度就能够提高。

- **天线增益**：包含发送天线增益以及接收天线增益。天线是可以增大信号的，评估这个增益性能的指标就是增益值。不同的天线种类，比如全向天线或者定向天线，具有不同的增益性能。

- - 定向天线有更好的聚焦能力，在总功率不变的情况下，能够有效提高接受者的接收功率（即聚焦） 。定向天线可以做智能天线波束成型（smart antenna beam forming）。
  - 全向天线有更好的覆盖能力，能够将能量更平均的覆盖到周边的所有节点上。
  - 利用多根全向天线做发送，可以做传输波束成型（Transmit Beamforming，TxBF）。利用信号的预编码技术来完成的，TxBF通过调节发送信号的相位，让信号在接收方呈现干涉叠加的效果。利用多根全向天线做接收，也可以做接收分集，增加信号质量。

- **信道衰落与干扰**：信道的影响包含两部分，衰落和干扰。

- - 衰落是由信道的特性造成的。衰落分成三部分，大尺度衰落，中尺度衰落（阴影衰落）以及小尺度衰落（多径）。

  - - 大尺度衰落：主要受到传输距离影响的电磁波衰落，距离越远，信号衰落越强。

    - 中尺度衰落：又称为阴影衰落，主要是由遮挡物造成的。（其实这个定义用的并不多，不过在无线局域网环境中，还是比较适合的，所以就放上来了）

    - 小尺度衰落：又称为多径衰落，主要是不同路径到达的信号之间造成的互相干扰。根据发送和接收方是否在视距（Line-Of-Sight，LOS）范围内，分为瑞利衰落（Rayleigh Fading，即NLOS范围）和莱斯衰落（Rice Fading，即LOS范围内）。 【PS：这里之前写反了，感谢

      [@Kelly珂](https://www.zhihu.com/people/ca2b14dc76ab51a9b06b1a05a8458f14)

       

      的指出】

  - 干扰由两部分组成，一部分是其他同频段的设备干扰，一部分是背景噪声（一般理论上我们认为是高斯白噪声，其主要是由热噪声造成的）。

## **链路模型**

这一节中，我们建立模型刻画之前所述的影响Wi-Fi覆盖范围的一些因素，如下图所示：

![img](https://pic2.zhimg.com/80/v2-ef5da3a9def3008408e750d8b7790e8d_720w.png)

即接收功率我们可以表述为（以dBm的形式表达）：

![[公式]](https://www.zhihu.com/equation?tex=P_%7BRX%7D++%3D+P_%7BTX%7D+%2B+G_%7BTX%7D++-+PL+-+N+%2B+G_%7BRX%7D)

其中![[公式]](https://www.zhihu.com/equation?tex=P_%7BRX%7D)为接收功率，![[公式]](https://www.zhihu.com/equation?tex=P_%7BTX%7D)为发送功率，![[公式]](https://www.zhihu.com/equation?tex=G_%7BTX%7D)为发送增益（包含了功率放大增益和天线增益），![[公式]](https://www.zhihu.com/equation?tex=PL)为信道衰落，![[公式]](https://www.zhihu.com/equation?tex=N)是噪声功率（假设没有干扰），![[公式]](https://www.zhihu.com/equation?tex=G_%7BRX%7D)为接收增益。

**注：这里噪声代表的热噪声，一部分是信道上的，一部分是天线到接收机之前的有损耦合造成的。**

在上式中，![[公式]](https://www.zhihu.com/equation?tex=P_%7BRX%7D)，![[公式]](https://www.zhihu.com/equation?tex=P_%7BTX%7D)，![[公式]](https://www.zhihu.com/equation?tex=G_%7BTX%7D)，![[公式]](https://www.zhihu.com/equation?tex=G_%7BRX%7D)都是发送接收机的固有设置，可以当做常数。

![[公式]](https://www.zhihu.com/equation?tex=PL)我们假设是自由空间损耗模型（Free-Space Path Loss，FSPL），![[公式]](https://www.zhihu.com/equation?tex=N)假设是热噪声，以下我们重点阐述下这两个部分。

**自由空间损耗模型：**该模型是理想的大尺度衰落模型，一般意义上，我们假设的理想信道就是该模型（即只存在大尺度衰落）。该模型的物理意义如下图：

![img](https://pic3.zhimg.com/80/v2-d1d91a2f8b89c05e417d6e4c3228ef2a_720w.png)

在自由空间（即没有遮蔽物）的中心，发送方以![[公式]](https://www.zhihu.com/equation?tex=P_%7BT%7D+)的功率进行发射信号，接收方与发送方距离为![[公式]](https://www.zhihu.com/equation?tex=d)。进一步参考上图，我们可以想象，这些距离发送端距离为![[公式]](https://www.zhihu.com/equation?tex=d)的所有点（即接收方可能出现的位置）构成了一个球面，该球面的面积为![[公式]](https://www.zhihu.com/equation?tex=4%5Cpi+d%5E%7B2%7D+)。总发送功率![[公式]](https://www.zhihu.com/equation?tex=P_%7BT%7D+)是平均分布在该球面上任意一个点上的，接收功率![[公式]](https://www.zhihu.com/equation?tex=P_%7BR%7D+)即为![[公式]](https://www.zhihu.com/equation?tex=P_%7BT%7D+%2F4%5Cpi+d%5E%7B2%7D+)。

且我们进一步假设，接收方是以有效面积为![[公式]](https://www.zhihu.com/equation?tex=%5Clambda+%5E%7B2%7D+%2F4%5Cpi+)的天线进行接收（一般天线的面积与波长有关），最后我们可以得出接收功率为：![[公式]](https://www.zhihu.com/equation?tex=P_%7BR%7D%3D+%5Cleft%5B+P_%7BT%7D%5Clambda%5E2+%5Cright%5D++%2F+%5Cleft%5B+%5Cleft%28+4%5Cpi++%5Cright%29%5E2d%5E2+%5Cright%5D+)。在与发送功率![[公式]](https://www.zhihu.com/equation?tex=P_%7BT%7D+)相除之后（即求链路的衰减），我们可以得到自由空间损耗（FSPL）如下：

![img](https://pic4.zhimg.com/80/v2-52026afaeab6e76526dcc95bfede1a0b_720w.png)

一般情况下，大家还很常见以dB形式表达的自由空间损耗（![[公式]](https://www.zhihu.com/equation?tex=f)单位为MHz，![[公式]](https://www.zhihu.com/equation?tex=d)单位为km）：

![[公式]](https://www.zhihu.com/equation?tex=PL%3D32.44%2B20%5Ctimes+log_%7B10%7D%5Cleft%28+f+%5Cright%29++%2B20%5Ctimes+log_%7B10%7D%5Cleft%28+d+%5Cright%29++)

实际上这两个表述实际上是一样的，以下我们做一个数学推导（初始![[公式]](https://www.zhihu.com/equation?tex=f)单位为Hz，![[公式]](https://www.zhihu.com/equation?tex=d)单位为m，最后结果![[公式]](https://www.zhihu.com/equation?tex=f)单位为MHz，![[公式]](https://www.zhihu.com/equation?tex=d)单位为km）：

![img](https://pic4.zhimg.com/80/v2-ff2af6221ed9bc9f6b530cbd2f5a1927_720w.png)

故上述的两种表达本质上是相同的，之后我们会基于该模型示例估计无线传输范围。由于自由空间模型中，没有考虑到阴影衰落，而CWNA的书中是给出一些遮挡介质对于信号的影响的（信号为2.4G的情况下），所以一起记录在这里（参考CWNA教材）：

- 木门（Wood door）：–3 dB
- 金属机架（Metal rack）：–6 dB
- 隔间墙（Cubicle wall）： –2 dB
- 基墙（Foundation wall）： –15 dB
- 无色玻璃窗（Nontinted glass windows）：–3 dB
- 石膏墙或石膏夹板（Drywall or sheetrock）：–3 dB
- 电梯或金属障碍物（Elevator or metal obstacle）：–10 dB
- 砖，混凝土，混凝土块（Brick, concrete, concrete blocks）：–12 dB

**本底噪声（热噪声**）

在论文假设中，我们一般直接假设背景噪声为0均值的高斯白噪声（在Digital Communications Fundamentals and Applications一书中，第5.3.4节所述：由于热噪声功率谱密度在频率![[公式]](https://www.zhihu.com/equation?tex=10%5E%7B12%7D+)以下为常数，所以一般将接收机的热噪声过程当做高斯白噪声处理），并给定一个噪声功率即可。其实一般情况下，我们可以根据热噪声有参考的背景噪声的公式的，如下：

![img](https://pic2.zhimg.com/80/v2-b17f905315bb2e92d645a416716bccfd_720w.png)

其中噪声功率![[公式]](https://www.zhihu.com/equation?tex=N)是以dBW形式给出的，![[公式]](https://www.zhihu.com/equation?tex=BC)是玻尔兹曼常量（Boltzmann's constant，![[公式]](https://www.zhihu.com/equation?tex=1.38%5Ctimes+10%5E%7B-23%7D+J%2FK)或者![[公式]](https://www.zhihu.com/equation?tex=-228.6++%5C++dBW%2Fk%2FHz)），![[公式]](https://www.zhihu.com/equation?tex=C%5E%7B%5Ccirc%7D+)为摄氏温度（括号内直接带入![[公式]](https://www.zhihu.com/equation?tex=290K)），![[公式]](https://www.zhihu.com/equation?tex=B)为带宽（比如802.11a/g为![[公式]](https://www.zhihu.com/equation?tex=20MHz)），![[公式]](https://www.zhihu.com/equation?tex=F)为噪声系数（noise
figure，一般为![[公式]](https://www.zhihu.com/equation?tex=9dB)）。

**注：以上的参数选择参考MATLAB2016a中基带仿真的代码。**

故最终带入802.11的结果即为：

![img](https://pic2.zhimg.com/80/v2-629b9b102ae79da9f854f115320b4a91_720w.png)

实际上这个值和07版协议中给出的背景噪声（也就是本底噪声）的参考值还要小的，CWNA书中第3.4节以及第3.6节指出，一般2.4G信道的本地噪声为![[公式]](https://www.zhihu.com/equation?tex=-110dBm+%5Csim++-100dBm)，所以除了热噪声之外，可能还包含了一些信道上别的白噪声。不过也是可以参考07版协议Table 19-10中所述“RSSI的范围和实际上功率是独立的”，换言之，本地噪声的具体数值也是可以自己设定的，主要还是根据实际使用场景为准。

# 信道模型（SISO）以及Break Point距离

## **序言**

在前面讨论完基本的链路模型之后，本文我们主要讨论802.11协议中所规定的几种信道模型。该部分内容笔者并没有在07或者12的协议版本中找到，目前所检索到讨论该部分内容的资料如下：

- Cambridge的《Next Generation Wireless LANs》系列书籍，第3.5节部分内容。
- TGn Channel Models（IEEE 802.11-03/940r4），相关资源整理（[TGn Channel Models](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9712173)）。
- TGac Channel Model Addendum Supporting Material（IEEE 802.11-09/0569r0），相应资源整理（[TGac Channel Model Addendum Supporting Material](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9712181)）。
- TGac Channel Model Addendum（IEEE 802.11-09/0308r1212），相应资源整理（[TGac Channel Model Addendum](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/fzxy002763/9712396)）。

实际上根据TGn Channel Models，802.11中SISO的信道模型也是当时直接从HiperLAN/2的信道模型参考过渡过来的，只是HiperLAN/2现在基本已经见不到应用了而已。

*注：本文主要还是描述SISO的信道模型，至于MIMO的信道模型之后我们再进行讨论。本文在参考《Next Generation Wireless LANs》，并在其原有基础上补充了一些内容，故如果有错误的地方，还请见谅。*

## **802.11中的信道模型**

在无线局域网内的信道模型相比通信网络实际上简单不少。一般信道建模分为三种：统计性模型（经验模型），确定性模型以及半确定性模型。其中802.11的SISO信道模型即为统计性模型，MIMO信道模型则是基于相关矩阵的半确定性模型。

在802.11协议中，一共规定了6个参考模型（代号为A~F），每一种模型对应着一种室内场景，具体如下（参考Next Generation Wireless LANs 802.11n and 802.11ac第39页，3.5.1节）：

![img](https://pic3.zhimg.com/80/v2-ef7ec9467166e410ecfb38b52e4b9546_720w.png)

其中不同的模型对应不同的时延扩展（delay spread），RMS为均方根的意思，即Root Meam Square。如果delay spread越大，那么代表其覆盖的范围就越大（可以理解成传输的距离越远，延迟也越大）。

- **模型A**：实际上是一个理想模型，其没有对应的真实使用场景，主要是一个平坦衰落的瑞利信道，一般只用来做理论研究。
- **模型B**：小范围传输的场景，比如在居室内以及居室与居室之间的传输，一般家用场景都是该模型。
- **模型C**：中小传输的场景，一般较大的居室或者小型的公共场景中采用，比如会议室，课室之类。
- **模型D**：一般办公场景所使用，比如某一层办公楼，大的会议室，具有隔间的办公区域之类，是一个典型的商用场景。
- **模型E**：大型办公场景，这个场景更偏向于比如商场，多层办公楼，小型校园，这样更加公开一些的商用场景。
- **模型F**：大型室内以及室外场景，工业区，以及城市广场之类，该场景只有在大范围覆盖的Wi-Fi网络中才有使用到。

以上我们简单介绍了802.11协议中所规定的几种信道模型，以下我们具体分析在SISO情况下具体的理论模型。

## **理论模型（SISO）**

在802.11协议中，信道模型为一个理论模型，包含了以上几种不同的不同的场景（即参数设置不同）。其具体的数学模型如下（以dB的形式）：

![img](https://pic2.zhimg.com/80/v2-de20a59ea513e11b41e88cfa5c9a1ea5_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=L%5Cleft%28+d+%5Cright%29+)为路径损耗，![[公式]](https://www.zhihu.com/equation?tex=L_%7BFS%7D%5Cleft%28+d+%5Cright%29++)为Free Space Loss（在之前一篇中：[802.11协议精读15：链路模型（基于Free-Space Path Loss）](https://zhuanlan.zhihu.com/p/24332783?refer=dot11)，我们有对此进行介绍），![[公式]](https://www.zhihu.com/equation?tex=d)为发送者和接收者之间的距离，单位为![[公式]](https://www.zhihu.com/equation?tex=m)，![[公式]](https://www.zhihu.com/equation?tex=d_%7BBP%7D+)为break point距离。

如果![[公式]](https://www.zhihu.com/equation?tex=d%3C%3Dd_%7BBP%7D+)，实际上还是在视距内的（LOS），那么路径损耗和Free Space Loss相同，若![[公式]](https://www.zhihu.com/equation?tex=d%3Ed_%7BBP%7D+)的话，那么实际上是一个非视距的传输（NLOS），其不仅包含了在LOS内的Free Space衰减，还包含了另外一项更高阶数的衰减（注：Free Space的距离参数带入的是Break point的距离）。NLOS情况下的模型是一个统计模型，物理意义不是很明确。一般而言，在NLOS情况下，属于Two-ray Ground Reflection的模型，不过这里模型比较接近，不过还不是完全一样就是了。

![img](https://pic2.zhimg.com/80/v2-9de80137e7f40070bc86197819dd34a5_720w.png)

其中一些其余的模型参数如上图，其中第二列是表述了不同模型下Break Point（BP）的距离，第三列表述的是在BP距离之前，其是按照指数为2的形式衰减的（即距离的平方，Free space模型），第四列是在BP距离以后，是按照指数为3.5的形式衰减。最后两列是一些阴影衰落的参数值。第三和第四列的slope的意思可以参考一下公式更好理解：

![img](https://pic4.zhimg.com/80/v2-7791a620d13e3ec0f978674cf15cc15f_720w.png)

Free space loss我们可以写成第一行的式子，又因为一般发送信号的频率给给定的，所以为一个定值，所以我们可以将![[公式]](https://www.zhihu.com/equation?tex=20log%5Cleft%28+f+%5Cright%29+-147.5)设置为![[公式]](https://www.zhihu.com/equation?tex=L_%7B0%7D+)。剩下来的![[公式]](https://www.zhihu.com/equation?tex=20log%5Cleft%28+d+%5Cright%29+)写成![[公式]](https://www.zhihu.com/equation?tex=%5Cgamma+10log%5Cleft%28+d+%5Cright%29+)，其中![[公式]](https://www.zhihu.com/equation?tex=%5Cgamma+)对应的就是这个slope，所以不同的slope对应不同指数的衰减情况。

不同的模型按照以上的公式进行带入即可。同时在协议中，我们关注每一个模型下，都根据BP为界，存在两种不同的衰减情况，以下我们主要解释一下BP的物理意义。

## **菲涅尔区域与Break Point（BP）**

本节我们分别从物理意义和统计结果上分别理解下Break Point距离。

**物理意义**

Break Point的物理意义是从菲涅尔区域所定义的，菲涅尔区域（Fresnel zone）是一个虚构的椭圆球体区域，参考CWNA第4.7节的图例如下：

![img](https://pic4.zhimg.com/80/v2-4ed50ea180c2acce23c0cf36e33918c7_720w.png)

如上图，中间的为Point source，然后内圈的椭圆为第一菲涅尔区域（First Fresnel Zone），外圈的椭圆为第二菲涅尔区域（Second Fresnel Zone）。以下我们只关注第一菲涅尔区域，其区域半径可以用以下公式计算：

![img](https://pic4.zhimg.com/80/v2-a96206e319a769b33750b6d48ca2682b_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=r)为第一菲涅尔区域的半径，![[公式]](https://www.zhihu.com/equation?tex=d)为链路距离（单位为m），![[公式]](https://www.zhihu.com/equation?tex=f)为信号的频率。如果第一菲涅尔区域被阻挡，那么会严重影响无线信号的传输。直观的我们可以认为，如果第一菲涅尔区域被阻挡，那么就会从LOS的信道变成NLOS的信道。

基于菲涅尔区域的理解，我们开始定义Break Point距离，如下图（参考《CHANNEL MODELING FOR FIFTH GENERATION CELLULAR NETWORKS AND WIRELESS SENSOR NETWORKS》）

![img](https://pic1.zhimg.com/80/v2-e043b72684f374bbc54607673ffc4980_720w.png)

图中，![[公式]](https://www.zhihu.com/equation?tex=h_%7Bt%7D)和![[公式]](https://www.zhihu.com/equation?tex=h_%7Br%7D)为收发天线的高度，![[公式]](https://www.zhihu.com/equation?tex=d_%7BB%7D+)为break point距离，其余一些参数与我们的主题无关，所以就不一一阐述了。Break point的物理意义参考图（b），当第一菲涅尔区域（即红色的虚线）刚刚好接触到障碍物（即地面）的时候，这个时候发送和接收者的距离即为Break Point distance。

在（a）图中，发送和接收之间的距离小于![[公式]](https://www.zhihu.com/equation?tex=d_%7BB%7D+)，即第一菲涅尔区域没有碰触到地面，这个时候主要的传输还是依据视距直线传输的，即通过地面反射的信号（图中褐色折线）对传输的影响较小，所以主要是Free Space Loss。图（b）则是一个临界，图（C）中，第一菲涅尔区域已经超过了地面，所以接收方接收的信号除了由沿视距直接传输的，也有地面反射的信号。这种除了由直射信号以外，还有反射信号的情况，即是典型的Two-ray Ground Reflection模型，所以我们可以看到，在BP距离以外，802.11模型中的slope是3.5（即类似Two-ray模型，Two-ray模型为4），而不是Free space的2。

参考CWNA的教材，若障碍物不是出现在中间位置，那么菲涅尔区域的计算公式如下：

![img](https://pic3.zhimg.com/80/v2-822b6475ba5472d025d7583e8c5213a2_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=N)为第几菲涅尔区域，![[公式]](https://www.zhihu.com/equation?tex=d_%7B1%7D+)为发送者到障碍物的距离，![[公式]](https://www.zhihu.com/equation?tex=d_%7B2%7D+)为接收者到障碍物的距离，以上距离都为![[公式]](https://www.zhihu.com/equation?tex=m)。

**统计结果**

![img](https://pic3.zhimg.com/80/v2-ada206e26431080c1ff0e8c36cb04102_720w.png)

参考上图，我们描述下break point在统计结果上的意义。上图表述的是一个900M频段上的传输（802.11中的图例没有找到），纵轴为接收功率（单位为![[公式]](https://www.zhihu.com/equation?tex=dBW)），横轴为发送和接收之间的距离（单位为![[公式]](https://www.zhihu.com/equation?tex=m)），其中蓝色为Two-ray Ground Reflection模型的信号衰减情况，绿色虚线为Free Space模型下的衰减情况。

上图中，我们可以看到在BP距离![[公式]](https://www.zhihu.com/equation?tex=d_%7BB%7D+)之前，Two-ray的结果是比较接近Free space的结果的，而在BP距离以外，Two-ray的衰减幅度快速下降，呈现指数为4的一个下降趋势，距离Free space的结果也就越来越远。

综上所述，所以802.11不仅定义了不同场景下的信道模型，也根据发送和接收者距离，分别给出了在视距范围内和外的衰减结果。在基本信道模型给定以后，我们可以从理论上去计算一个实际Wi-Fi节点的传输范围，以后我们再具体进行阐述。

# 无线传输范围（理论计算）

## **序言**

在前面两篇，我们接连讨论了链路模型和802.11协议中的信道模型以后。基于之前的讨论，本节，我们对无线信号的理论覆盖范围进行计算。在本节中，我们还是先以自由空间损耗模型（Free-space path loss）为例，然后扩展到之前的802.11标准的信道模型。

*注：本文的理论计算是笔者总结一些论文中相应的表述后，进行的总结，故如果有错误的地方，还请见谅。*

## **传输范围（基于Free Space Path Loss模型）**

首先我们定义传输范围![[公式]](https://www.zhihu.com/equation?tex=TR%5Cleft%28P_%7BTX%7D++%5Cright%29+)，其为一个发送功率![[公式]](https://www.zhihu.com/equation?tex=P_%7BTX%7D+)的函数，其表达式如下：

![img](https://pic3.zhimg.com/80/v2-841cf28c746c1440eff5807f954c2a52_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=C%3D%5Clambda%5E2%2F%5Cleft%28+4%5Cpi%5E%7B2%7D+++%5Cright%29++)，其可以视为一个常数。其中![[公式]](https://www.zhihu.com/equation?tex=%5Clambda+)为信号的波长，实际上与发送频率有关，在Wi-Fi中由于是固定的2.4G或者5G的某个频点。如果加上发送和接收增益的话，那么![[公式]](https://www.zhihu.com/equation?tex=C%3D%5Cleft%28+G_%7BTX%7D%5Ctimes+G_%7BRX%7D%5Ctimes++%5Clambda%5E2+%5Cright%29+%2F%5Cleft%28+4%5Cpi%5E%7B2%7D+++%5Cright%29++)。![[公式]](https://www.zhihu.com/equation?tex=G_%7BTX%7D)为发送增益，![[公式]](https://www.zhihu.com/equation?tex=G_%7BRX%7D)为接收增益。

![[公式]](https://www.zhihu.com/equation?tex=P_%7B%5Calpha%7D+)的定义如下：

![img](https://pic2.zhimg.com/80/v2-830d1f4fc5456728ef1d51a24001ae4d_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=P_%7Bthold%7D+)为接收灵敏度，![[公式]](https://www.zhihu.com/equation?tex=P_%7BN%7D+)是本底噪声的功率，![[公式]](https://www.zhihu.com/equation?tex=SNR_%7Bthold%7D+)为接收方能够解调发送方信号的最小信噪比。

不同的发送速率对信道质量的要求不同，就是越高的速率需要越好的信道质量。在802.11中，这个信道质量是需要同时参考接收灵敏度和信噪比。协议中，接收灵敏度的部分如下图（参考07版协议第617页），图中数值为RSSI：

![img](https://pic4.zhimg.com/80/v2-4accb0ec81a85d9c9a4255a4a05e866b_720w.png)

在上图中，第一行和第二行对应不同的MCS（Modulation and Coding），实际上代表了不同的传输速率，相关计算方法我们在[802.11协议精读12：初探协议性能以及物理层速率计算](https://zhuanlan.zhihu.com/p/21952348)中已经有过说明。第三列描述的是抗邻频干扰的容限或者可以翻译成邻频抑制，第四列是抗非邻频干扰或者交替信道的干扰。第五~第七列给出的是不同信道带宽下，不同速率所需要的接收灵敏度。

*注：该表出自于802.11a，其初始设置带宽有5MHz，10MHz以及20MHz，只是前两者比较少见，不过5MHz和10MHz信道在802.11p的网络中有不少应用就是。*

这里的接收灵敏度是被定义为物理层数据帧（PSDU）的长度为1000Byte时，分组错误率（PER）小于10%时，对应的RSSI值。抗领频容限和非邻频容限都是在最小接收灵敏度加上3dB的情况下，增加干扰进行测量的（即不断增加干扰，直到PSDU的PER大于10%为止，其功率差就是容限）。

抗领频容限和非邻频容限是基于最小灵敏度测定的。首先将收发链路链路调节为（最小灵敏度+3dB），发送方固定发送1000Byte的PSDU。此时添加一个干扰节点。由该干扰节点施加增加邻频或者非邻频干扰。测定收发链路的PSDU的PER为10%时候，对应的干扰功率（RSSI差值），该差值就对应的是抗领频容限或者抗非邻频容限。

协议中并没有给出不同MCS对应的SNR情况，参考《Next Generation Wireless LANs 802.11n and 802.11ac》第125页，其不同MCS对应的![[公式]](https://www.zhihu.com/equation?tex=SNR_%7Bthold%7D+)如下：

![img](https://pic2.zhimg.com/80/v2-d20eab9173a6570dc527c6b82caf7dd5_720w.png)

其中第一~二行为MCS，第三行是不同MCS所需要的SNR，第四行是SNR相对于最小灵敏度的增益。这个增益我们可以这样理解，即在[802.11协议精读15：链路模型（基于Free-Space Path Loss）](https://zhuanlan.zhihu.com/p/24332783?refer=dot11)中，我们叙述过本底噪声的大致估算，假设本底噪声为![[公式]](https://www.zhihu.com/equation?tex=-100dBm)，MCS（BPSK，1/2）的时候，其SNR为![[公式]](https://www.zhihu.com/equation?tex=1dB)，而本底噪声和最小灵敏度的差值为![[公式]](https://www.zhihu.com/equation?tex=18dB)。即后者的要求是大于SNR的要求的。由于SNR和最小灵敏度之间还存在一定的裕度，所以也才有了之前抗邻频干扰和抗非邻频干扰的容限，这也是协议中给出的主要是接收灵敏度而不是SNR的原因之一。

有了以上的参数，并且给定![[公式]](https://www.zhihu.com/equation?tex=P_%7BTX%7D)，我们只要将参数带回一开始的公式计算即可。在具体情况下，我们需要注意分别计算其![[公式]](https://www.zhihu.com/equation?tex=P_%7Bthold%7D+)以及![[公式]](https://www.zhihu.com/equation?tex=P_%7BN%7D+%5Ctimes+SNR_%7Bthold%7D+)，取其最大值作为判断传输距离的参数。

## **传输范围（其他情况）**

其他情况下，参考802.11中的信道模型：

![img](https://pic4.zhimg.com/80/v2-021eb245be5b92bf27459e31a050780b_720w.png)

将以上的信道模型进行反推成距离的函数即可，具体结果如下：

![img](https://pic3.zhimg.com/80/v2-9b834586a739166e75a4a66004558b1e_720w.png)

其中![[公式]](https://www.zhihu.com/equation?tex=C%3D%5Clambda%5E2%2F%5Cleft%28+4%5Cpi%5E%7B2%7D+++%5Cright%29++)，通过以上的式子，我们就可以估算一个无线节点的传输范围。

不过以上计算仅仅局限在单节点的工作状态，因为在多节点环境中，除了本身的传输范围外，还存在隐藏和暴露终端问题，所以不仅仅是一个覆盖问题，之后有机会的时候，我们再进行相应的扩展。

# 协议族框架简介

## **序言**

本节我们简单梳理一下当前整个IEEE 802.11协议族的整体框架。之所以将这个内容放在中途，主要是为了初始理解802.11的核心设计的时候，回避一些额外内容的引入。初始802.11的核心内容主要是PHY层发送传输过程，和MAC层的竞争机制这两个部分（即我们之前所讨论的内容都是局限于传统的802.11协议，802.11a/b/g部分）。由于应用场景增多，以及协议本身设计存在的一些缺陷，所以802.11协议不断进行的扩充。

那么在讨论当前802.11更新技术之前，我们有必要梳理下当前802.11的整体框架，以求对协议整体脉络有一个简单掌握。

## **IEEE 802.11中的2类协议文件**

在初读协议的时候，我们一般可以看到两类协议文件：

- 单独专题（比如IEEE 802.11a/b/g/e等等）
- 多个协议的总章（比如IEEE 802.11-2007，,802.11-2012）

这两类实际上是在协议制定的过程中出现的产物。我们所知IEEE 802.11是IEEE 802下的一个Task Group，这个组主要专门设置无线局域网的网络协议。在IEEE 802.11下还分了很多个子协议，每一个子协议实际上都是由一个独立的任务组（Task Group）进行制定，比如802.11a的Task Group。

在这些众多的任务组中，我们需要提及下“802.11m”这个协议组。802.11m（简称TGm）是一个维护802.11协议文档的任务组。该任务组负责将已经批准的修正案发布成文档，比IEEE 802.11-2007，IEEE 802.11-2012协议版本。

以802.11-2007协议版本为例，其在开头介绍部分，也说明了其包含的具体协议内容（参考07版协议第iv页）。

![img](https://pic2.zhimg.com/80/v2-a77780781e77aa85dec80b0a3746b249_720w.png)

故07版，12版协议实际上是整理当前802.11各个子协议内容之后的标准发行版，该内容较为全面，而且也是经过整理的。其实在各个子协议里面，经常会出现一些小疏漏，比如章节跳跃之类的，之所以没做修改，笔者估计也是这个原因。

那么在07版本以前发行的协议，按照IEEE 802.11的网站上而言，是属于失效协议的范畴。具体我们可以参考网站（[IEEE 802.11, The Working Group Setting the Standards for Wireless LANs](https://link.zhihu.com/?target=http%3A//www.ieee802.org/11/Reports/802.11_Timelines.htm%23tgmc)）。如果读过CWNA教材第5章的可能会有点奇怪，书中的失效协议只有802.11F和802.11T。这里原因是在于该网站上是把SUPERSEDED和WITHDRAWN都划在了一类上，而802.11F和802.11T是WITHDRAWN类型的，其他的是SUPERSEDED类型的。（PS：其实SUPERSEDED也有原型协议的意思，之所以笔者还是把其理解为失效，原因1为很多子协议存在一些小疏漏，比如格式问题，一直没有做修正很奇怪，原因2为其和WITHDRAWN平等放在一起，故存在这样理解）。

以上我们梳理了下协议版本中两类不同的协议文件，故很多情况下，我们关注最新的总章的发行版，比如07,12中，已经包含了各个子协议相应的内容了。

## **IEEE 802.11协议族框架**

讨论完了协议文件的内容以后，我们具体关注下协议具体的设计内容。我们可以参考《A Survey on High Efficiency Wireless Local Area Networks: Next Generation WiFi》中总结：

![img](https://pic3.zhimg.com/80/v2-c19da1eecfb609d959f45614f0a7a6ea_720w.png)

上图从时间顺序上，为我们总结了协议发展时期的一个个版本。最初始的是IEEE 802.11-1997的初版（即初始的PHY/MAC的协议设定），然后是a/b/g的具体物理层的修订案等等。

每一个协议具体的功能可以参考CWNA第5章的表述，笔者觉得还是挺全面的。为了更深入理解协议框架，我们还可以对协议内容做一个归类（参考PPT：Designing Wireless for BYOD devices in Stadiums by Cisco）：

![img](https://pic4.zhimg.com/80/v2-ca7ab1fdbedba915ae5f395774d1dfaf_720w.png)

- **Connectivity**：主要是标准无线局域网的协议，包含一个无线局域网的PHY和MAC层具体设计，一般路由器演进都是以这些协议作为主要标志，比如802.11a/b/g/n/ac/ad/ax。演进的内容也主要集中在PHY和MAC层上。
- **Spectrum**：有点偏向认知无线电的方向，主要是和同频其他设备共存的问题。比如802.11h主要是回避雷达，802.11af是回避TV，因为这些频段都已有别的协议工作，只是在空闲的时候，那么可以用作802.11协议接入。其主要内容演进集中于CSMA/CA过程以及其中的CCA部分（Clear Channel Assessment）。
- **Management**：这个主要是管理层面上的内容了，实际上主要是AP+AC或者多AP环境下，如何完成网络中的一些任务，比如TPC（Transmission Power Control）。其主要演进是在上层的交互内容上。
- **Security**：这个比较名确就是安全问题了。802.11i，即WPA2主要是接入层面的安全，802.11w主要是管理帧安全（避免一些无线攻击的方法，以及管理帧加密）。
- **Seamless**：其含义为无缝接入，主要是漫游和热点接入的问题。这一块也属于上层的交互内容的改进了。
- **Applications**：与应用有关的内容，更直接一些的话就是针对应用层的优化，比如802.11e是初始的优化版本，其主要针对数据帧进行分类，并修改802.11的MAC层接入机制，即在MAC层（即CSMA/CA机制上）提供了QOS机制。802.11aa是针对组播流量进行优化（即组播视频流）。实际上802.11ae也可以划入这一类，不过其主要优化的是管理帧（即为管理帧提供802.11e中的QOS功能）。
- **Others**：其实还有一些802.11版本，不过与无线局域网的应用场景有些区别，所以这页PPT就没有强调了，比如802.11ah（Sub-1G的低功耗网络），802.11p（车载网），802.11z（D2D的连接），802.11az（定位）等。

以上我们介绍了802.11当前的协议框架，以及其中一些主流协议的简单内容和关系。当前的最新的协议总章应该是（IEEE Std P802.11-2016），如果有兴趣可以自行阅读下（笔者还没有接触到这个最新的版本）。

# Wi-Fi的起源，诞生与发展

## **序言**

本来这一节打算开始讨论802.11e的内容，因为从无线局域网诞生到成型，尤其是演进的过程中，一个重要的起步点就是802.11e，很多在802.11n，802.11ac，802.11ah之中所引入的内容，实际上在802.11e中都可以发现其的引导，更一般而言，先行的802.11的MAC层协议基本都是按照802.11e中的EDCF，而不是传统的DCF。

然而，如果直接从802.11e开始谈及802.11协议的演进也有点冲突，因为从协议开始之初，或者说协议开始之前，实际上就一直处于演进的过程。所以本文就笔者个人所了解的部分，梳理下无线局域网协议WLAN的大致演进过程。

本文中的一些内容部分参考自下述引文：

1. 《The Innovation Journey of Wi-Fi (The Road to Global Success)》
2. “[THE HISTORY OF WI-FI](https://link.zhihu.com/?target=https%3A//getvoip.com/history-of-wifi/)”
3. 《Ethernet:The Definitive Guide》

其余为笔者目前的一些总结，如果错误之处，还请见谅。

## **Wi-Fi协议的起源**

Wi-Fi是一种WLAN（Wireless LAN）协议，即无线局域网协议。其历史或者说网络协议中的多址接入协议的历史都可以追述到1971年的ALOHAnet。

*PS：在ALOHAnet之前，还存在一个局域网架构University of California Irvine Ring，本文对此就不加以展开了。*

按照Wiki的说法，ALOHAnet是由诺曼·艾布拉姆森（Norman Manuel Abramson）带领团队在夏威夷大学构造的一个无线网络。由于岛屿之间不易布置有线链路，如果布置的话，其成本也会很高。故诺曼就希望采用相对成本比较低廉的无线设备，构造一个以Oahu岛为中心和其他夏威夷岛屿通信的无线链路。该项目于1968年9月启动，到1971年6月，第一个数据包以9600bps的速率发送成功。.该网络所设计出的通信协议，如今就被称为Aloha协议（更准确的说是pure-Aloha）。

![img](https://pic1.zhimg.com/80/v2-ecbc63fd6e1de06f2600ebe78675412c_720w.png)

- Aloha协议的思想如下：“一个aloha节点只要有数据的话，该节点就可以立即发送。当该节点数据发送完之后，其需要等待接收方反馈的ACK。若成功接收到ACK之后，那么这一次传输成功。如果没有收到ACK的话，那么这一次传输失败。该aloha节点会认为网络中还存在另外一个aloha节点也在发送数据，所以造成接收方发生了冲突。最后这些冲突的节点会随机选择一个时间进行回退（backoff），以避免下一次冲突。若冲突节点回退完成，其才可以重新进行发送"。

Aloha协议是首次讨论以共享介质进行传输的网络协议，这种共享介质的传输模式也就是最早局域网的雏形，也可以称之为多址接入模式。有线网络中的CSMA/CD，无线网络的CSMA/CA等等都是基于其思想优化而来。诺曼·艾布拉姆森主导提出了该协议，并且在此之后也对协议进行了理论分析以及改进，其也在2007年获得了“IEEE’s Alexander Graham Bell Medal”奖项。

![img](https://pic4.zhimg.com/80/v2-3b3e78279a4fb9ec8d07dd06a0c10d27_720w.png)

在ALOHAnet诞生2年后，参考[3]，1973年5月22日，美国加州施乐帕洛阿尔托研究中心的罗伯特·鲍勃·梅特卡夫（Rebert “Bob” Metcalf）构建了一个新的网络系统，该系统将一批名为施乐阿尔托的计算机连接起来，构建了一个高速局域网（LAN）。起初梅特卡夫将改网络命名为“Alto Aloha Network”，可见该网络也是源于ALOHAnet，后来梅特卡夫将其更名为“Ethernet”。Ether指的为“以太”，是曾经被电磁波传播的载体，根据[3]所言，梅特卡夫当初将其命名为以太网（Ethernet）就想指明其本质，即这是一种通过物理介质传播的网络。

![img](https://pic4.zhimg.com/80/v2-f3dabd209e05888aacff44c8661fd067_720w.png)

Ethernet设计了一个比较完整的局域网构架，其包含了具体的物理接口，传输介质的设计（如上图），以及其对应的网络协议（即CSMA/CD）。CSMA/CD（Carrier Sense Multiple Access with Collision Detection）是在Aloha协议之上引入了LBT（Listen Before Talk）的机制。协议名中的CS（Carrier Sense）也就是完成LBT的一种具体做法，“即先通过CS来监听，只有信道空闲的时候，那么才传输。”

- CSMA/CD协议的思想如下：“节点发送数据之前需要持续监听信道，一旦节点发现信道空闲，则立刻发送数据。在发送数据的同时，节点持续监听信道，"探测" 是否有别的节点也在该时刻发送数据。

- - 若传输过程中没有检测到别的节点的传输，那么成功传输。在成功传输后，节点需要等待帧间间隔IFG（interframe gap）时间后，可以进行下一次传输。
  - 若在传输过程中，探测到别的节点也在传输，那么则检测到冲突。发生冲突后，节点立刻停止当前的传输，并且发送特定的干扰序列（JAM序列），用以加强该次冲突（用以保证其余所有节点都检测到该次冲突），在JAM序列发送完之后，节点随机选择一个时间倒数进行backoff。当backoff完成之后，节点可以尝试再次重传”。

*PS：其余Ethernet早期设计的详细内容可以参考[3]或者《Ethernet: Distributed Packet Switching for Local Computer Networks》。*

1980年时由梅特卡夫发起将Ethernet构建成一个标准进行发布，即DIX协议。DIX名字分别包含了美国DEC公司，Intel公司以及施乐（Xerox）。DIX在梅特卡夫的主导下，其从一开始就就秉承着开放。DIX协议任何人都可以复制和使用，也因为此，Ethernet迅速成为了世界上首个开放，面向多供应商的局域网标准。梅特卡夫同时也是3COM公司的创始人。

PS：DIX协议目前比较难找到电子版，笔者所搜索到的资源如下《[DIX网络协议（包含V1和V2）](https://link.zhihu.com/?target=http%3A//download.csdn.net/download/fzxy002763/9936568)》：。

于此同时，还有另外一个组织IEEE也在对Ethernet进行标准化，参考[3]和[Overview and Guide to the IEEE 802 LMSC](https://link.zhihu.com/?target=http%3A//www.ieee802.org/IEEE-802-LMSC-OverviewGuide-02SEPT%202012.pdf)，这一次标准化也新构建了一个组织，也就是IEEE 802委员会。

![img](https://pic1.zhimg.com/80/v2-1299127302a579f0fdb955bf5f22d904_720w.png)

IEEE 802委员会所颁布的标准体系比较完善，其设置了多个不同的Group，用来指定不同场景下对应的协议。Ethernet对应的802.3，Token Rings是802.5，在1985~1986年间，这些协议被相继颁布。

![img](https://pic1.zhimg.com/80/v2-3fe92295acdb98fd21bdf0eed3bfcbe8_720w.png)

我们现在要讨论的主题，也就是无线局域网的Wi-Fi协议，也就是这个委员会下属第十一个Group所指定的具体协议了（即IEEE 802.11），在每一个Group下还有不同的Task Group（比如802.11a/b/g/n/ac/ax等等）。

在此，我们总结一下第一个时间轴，参考[1]。

![img](https://pic1.zhimg.com/80/v2-a3be147b12e34399d24c85bcb7005664_720w.png)

从上图中，我们还可以看到，随着时间的发展，网络产业的收入和相应的产品数目都一直处于稳步上升趋势。以上我们都是讨论无线局域网协议的起源，下面我们就要正式讨论下Wi-Fi协议的诞生了。

*PS：在网络发展中，无线通信不仅仅是无线局域网这一条发展脉络，其最主要还是通信网络。不过由于本文仅仅是讨论无线局域网，对于通信网络的发展，笔者涉猎有限，所以不进行展开。*

## **Wi-Fi协议的诞生**

![img](https://pic4.zhimg.com/80/v2-f02b28ffad516c5e97de7fb4a01fbbbf_720w.png)

民用网络的发展往往首先要通过政策许可这一关，在网络发展的起源地美国，其政策指的即是美国联邦通信委员会 (US Federal Communications Commission，FCC) 所派发的牌照（即无线电频段的使用许可）。考虑到避免干扰雷达所使用的无线电频段，于1985年，FCC颁发了为工业（industrial）、科学（scientific）和医疗（medical）行业颁发了ISM牌照，这一次的频段许可开放了900MHz，2.4GHz，和5.8GHz这三个频段，当时仅仅允许节点采用扩频技术（spread-spectrum）来进行通信。

在ISM频段之前，无线通信，比如无线电广播以及电视广播都是采用专用的频段，这可以避免一些有害的无线电干扰。而ISM频段之所以选择这些频段，是对于主要业务不重要，同时也是容易受到无线电干扰的频段，比如微波炉也是工作在2.4GHz频段，所以ISM的频段范围都是被业界视为一些“垃圾频段（garbage bands）”。

不过，无论如何，FCC开放了ISM频段，无线局域网才能得以发展。也正是因为ISM所存在的一些问题，才会影响无线局域网中一些具体协议机制的设计。不过如果展开讨论，为什么当时FCC要开放ISM频段，以及其限定为扩频传输（spread-spectrum），也是有产业界争取的结果，这也可以追述到1980年MITRE公司的一份可行性报告，其内容与FCC颁布的结果也是很对应的。

*PS：坊间也经常称海蒂·拉玛为Wi-Fi之母，也是由于FCC在ISM频段只允许扩频通信，从而Wi-Fi的原型设计就是基于扩频的。海蒂·拉玛更一般说来应该是扩频技术（实际上是扩频技术中的跳频技术，其根据钢琴或者说自动钢琴想到的灵感）的创造者，所以从这个意义上也是可以算说的通的。*

![img](https://pic4.zhimg.com/80/v2-a896dab9cf5b90f8816ee81b079b3427_720w.png)

在ISM频段开放之后，很快无线局域网就出现了第一个产品WaveLAN。WaveLAN是由Vic Hayes于1987~1988年设计的第一个无线局域网产品。当时替NCR Corporation工作的Vic Hayes为了构建一个无线收银系统（Cashier Systems），并参考了之前的Ethernet和Token Ring网络的思想构建了最初始的无线局域网WaveLAN，该设计是一个Ad-Hoc网络，同时，该设计也往往被认为是Wi-Fi设计的原型，即可以认为，从这个一个时刻开始，Wi-Fi的发展逐渐拉开序幕。

![img](https://pic4.zhimg.com/80/v2-979c4f6d41709b57a28bd4c4d7fd8c8f_720w.png)

在1989年时，NCR带头在IEEE 802组织下，开始打算构建一个无线局域网的专用协议。根据[1]中所言，实际上1987年开始设计WaveLAN之初，当时其思路为：基于OSI网络七层架构，仅仅修改与无线接入媒介有关的层面，即PHY和MAC层。

- MAC层初始设计时就存在两种声音，一种是由IBM所代表的中心式控制（Merits of Central），一种是由NCR代表（包含NCR/Symbol Technologies/Xircom）所代表的分布式控制（Distributed Control Architecture）。最终是由NCR所代表的分布式控制思路获得初步的胜利。从笔者的角度而言，这也是后来在Wi-Fi协议，始终存在分布式（DCF，EDCA）和中心式（PCF，HCCA）兼容设计的开始。
- PHY的初始设计中包含两种可能的扩频方式，跳频（Frequency Hopping）和直序扩频（Direct Sequence）。 这也是由于FCC一开始发放的ISM牌照，其仅仅允许扩频通信的方案存在。在协议设计之初，团队就无法在两者中仅仅取决一种，所以在初始协议最终颁布时，两种物理层扩频方案都是被支持的。

![img](https://pic1.zhimg.com/80/v2-c5830119bfee3fe7c53e4338871a4ad4_720w.png)

在1990年时，IEEE 802.11委员会被正式成立。作为WaveLAN的设计者以及802.11协议的主要推动者，维克·海耶斯（Vic Hayes）也被人们称之为“Wi-Fi之父”（Father of Wi-Fi）。

![img](https://pic1.zhimg.com/80/v2-358bc6a5be81cdf14ef2de2ef4434b94_720w.png)

同年，NCR也正式出品的第一个WaveLAN的产品，如上图，这是第一个为台式电脑提供WaveLAN功能的网卡，其工作在915MHz频段，能够提供2Mbps的传输速率。

![img](https://pic3.zhimg.com/80/v2-ff6f93f925a455ac7df801d8a2f9b63e_720w.png)

起初的WaveLAN是为了Ad-hoc的自组织网络结构所设计的，主要是构建一个无线通信的链路。而当前我们家庭中所广泛存在的无线路由器概念，其是在WaveLAN诞生之后诞生的。虽然[1]中没有提及，但是据WiKi所记录，这种热点（Hotspot）接入的概念是在1993年由Henrik Sjödin所提出来的，[1]中所述其概念可以追述到1993年，但是同时期也有很多人提出这样的概念。

而且据[1]所述，一开始所提出的Hotspot这个概念更直接应该被称为WISP，即Wireless ISP。ISP（Internet Service Provider）即网络运营商，所以初始设想就是通过无线网络协议，即类似WaveLAN这样的一个网络协议，在ISM许可范围内，自己构建一个小基站（也就对应Hotspot），通过这个小基站可以和ISP网络进行直连。这一点更直接而言，就是当下无线局域网基础架构的雏形，该Hotspot跟我们当下所讨论的Hotspot还是存在一些区别的，当下的Hotspot更强调是一共为公共区域提供网络服务的热点业务，而最初Hotspot就是我们当前无线局域网基础架构模式，即存在一个无线AP（即简单理解就是无线家用路由），然后通过其连接入公网的架构。

Hotspot的概念也是Wi-Fi协议能够成功的关键因素之一，其是Wi-Fi在商业应用中最重要的组成部分之一。Hotspot的需求也大大推进了Wi-Fi协议的发展，其中的漫游（Roaming），安全（Security），多AP扩展的ESS模式也都是由此发展而来。

![img](https://pic3.zhimg.com/80/v2-e894c7cb08c3e9e2573f632a73607352_720w.png)

同年，AT&T于卡耐基梅隆大学部署了第一个大型的WaveLAN网络，这是对于无线局域网在大范围传输内部署的第一次重要尝试。

![img](https://pic4.zhimg.com/80/v2-775711161eab2005d9e190de6b2f45a3_720w.png)

鉴于大型的WaveLAN网络成功部署之后，1994年时由Alex Hill博士带头，在卡耐基梅隆大学正式启动了“Wireless Andrew”的一个无线基础设施项目。该项目意在让学生在校园环境中，可以将移动设备通过WaveLAN接入网络，让学生可以在任意地点进行学习，这在早期也称为“移动学习”这一概念，该项目获得了很大的成功，也同时证明了无线网络接入的优越性。

![img](https://pic4.zhimg.com/80/v2-fd5efdabb40212e51efc4ef39c4a6643_720w.png)

前面我们所述都是WaveLAN，而目前我们称之无线网络都称之为Wi-Fi，如果用中文解释Wi-Fi的意思就是无线的高保真网络。如何真正在无线网络环境下做到高保真，有效的传输数据，使其跟接近我们如今Wi-Fi的使用需求。一般认为是在1996年时，由位于澳洲的CSIRO的John O'Sullivan领导的一个小组完成这样的研究（主要根据其在1996年时申请的专利US Patent Number 5,487,069）。坊间也有一些称“John O'Sullivan”为Wi-Fi之父，因为这一概念是从其开始提出的。Wi-Fi最初是一个完整的独立协议，其主要内容后来被IEEE 802.11接受，继而成为了802.11a的标准，实际上IEEE也就Wi-Fi协议的专利开放问题，也和澳洲政府进行过争论，Wi-Fi是存在专利费的。

![img](https://pic4.zhimg.com/80/v2-7b9cb6dad077968832236a9a9fdd88cb_720w.png)

在1997年时，经过了两次循环投票，802.11协议的第一版在9月被正式通过，并在1997年12月10日正式出版（即IEEE 802.11-1997）。第一版协议包含了跳频（Frequency Hopping）和直序扩频（Direct Sequence）两种模式，跳频支持1M bps的必选速率和2M bps的可选速率，直序扩频对于1M bps和2M bps都是必选支持的。

![img](https://pic2.zhimg.com/80/v2-509c7ceda2cffbfa3ec7b75c6a0c9d49_720w.png)

其实于此同时，除了IEEE 802.11协议之外，还有很多WLAN协议也在同时发展，有的是源于电话网，比如HomeRF，有的是源于ATM网络，比如HIPERLAN，其基本目的都是在ISM频段上构建一个无线通信网络。

虽然我们现在很多人都将WLAN，Wi-Fi和IEEE 802.11视为同一个概念，而实际上这几个含义还是存在区别的。WLAN是更大的一个概念，其包含了Wi-Fi，或者说IEEE 802.11协议，也包含了HomeRF以及HIPERLAN协议。而其余的一些协议，当下也因为各种各样的原因，成为了历史的一部分，当前WLAN的协议基本我们就可以等价认同为Wi-Fi协议了。

![img](https://pic2.zhimg.com/80/v2-82e72aba509fa1ce948fad860721ee69_720w.png)

通过上图中，我们对于Wi-Fi的起源和诞生做一个总结，我们可以明显的发现，Wi-Fi的诞生实际上是有一个较长时间的积淀的，也在不断地扩展其自身的功能，直到2001年开始，一旦存在了业务的需求，其就从一个技术积累转变为一个工程产业了，从而下面我们就正式讨论下Wi-Fi协议的迅速发展过程了。

我们也还是总结下，前面提到了有关Wi-Fi起源有三个重要人物：

![img](https://pic2.zhimg.com/80/v2-9492107ab40438ce63be358fda59e325_720w.png)

- Hedy Lamarr：很多媒介将其称为“Wi-Fi”之母，其主要是在钢琴实践中，创造了最初“跳频通信”的传输方式。跳频是一种扩频通信的基本方式。在1985年FCC开放ISM频段，并需求学界设计无线通信协议的时候，也限定一定要采用扩频通信的方式。所以Hedy Lamarr作为“跳频之母”就转变成了“Wi-Fi”之母。
- Vic Hayes：Hayes是学界和产业界比较公认的“Wi-Fi”之父，其打造了第一代的WaveLAN实践平台，并且积极促进并主导了IEEE 802.11委员会和最初802.11以及802.11a/b/g协议的构建，对Wi-Fi的整体发展做出了很大的贡献。
- John o'sullivan：John经常被澳洲媒介称为“Wi-Fi”之父，实际上这个也是有道理的。相比与Hayes，前者对于无线局域网通信更注重一些，后者John更主要在于提出“Wi-Fi”这一个概念，也就是高保真这一概念，并也实现了基于“Wi-Fi”概念的完整设计，从这个角度而言，也可以称其为“Wi-Fi”之父。

以上是笔者目前所读资料中，对于Wi-Fi起源的人物有关的一些总结，如有不恰之处，还请见谅。

## **Wi-Fi协议的发展**

![img](https://pic1.zhimg.com/80/v2-81937bd60ab3b82de45e02ab6c11da08_720w.png)

由于IEEE 802.11协议的正式颁布，以及前期无线网络技术的逐渐成型。在1998年开始，一家名为MobileSTAR的公司开始正式提供商业级别的无线局域网服务。其一开始的业务主要集中在机场，酒店以及咖啡厅。在2001年时候，Starbucks选择MobileSTAR做为其无线网络的服务商，随着商业模式的Wi-Fi Hotspot成功运营，Wi-Fi技术的技术研究与发展开始进入快速成长期。

![img](https://pic2.zhimg.com/80/v2-175da57d591ab4983004797b84594df1_720w.png)

在1999年时，Wi-Fi联盟（Wi-Fi Alliance）正式成立，实际上这个时期还不叫Wi-Fi联盟这个名字，其一开始的称呼为WECA（Wireless Ethernet Compatibility Alliance），其翻译过来就是无线以太网兼容性联盟。这是由工业届发起的非盈利团体，IEEE的协议偏重于理论设计，然而，真实生产环境下，所需要解决的一个关键问题就是不同厂家的互兼容性，产品测试之类，WECA联盟就是基于这个目的成立的，WECA早期集中于IEEE 802.11中的直序扩频（DSSS技术）。在2002年时，WECA正式更名为Wi-Fi联盟。

![img](https://pic1.zhimg.com/80/v2-0365e72aabf4aab00e7f951bf5a87b48_720w.png)

IEEE 于1999年同年，颁布了802.11b协议。802.11b协议在最初的IEEE 1997颁布上，在物理层增加了HR/DSSS（High-Rate Direct Sequence）模式，其引入了CCK编码，从而提供5.5Mbps和11Mbps两种新的速率，加上IEEE 2007规定的1Mbps和2Mbps两个速率（基于Barker码），一共提供了4种速率可以选择。

![img](https://pic1.zhimg.com/80/v2-c5442d23f3a8866622059ee5a0e38414_720w.png)

我们简单解释下直序扩频（DSSS）模式。直序扩频中有一个概念叫做扩频序列（如上图第二行Barker Sequence）。

- 如果网络没有采用扩频，当我们要发送一个数字信号“1”，我们需要发送一个Bit Sequence里面保持固定的信号幅度进行发送。
- 如果网络采用的扩频技术，当我们要发送一个数字信号“1”，我们发送的不是一个固定的信号幅度，而是在这个时间间隔内，发送对应的扩频序列。

在802.11中采用的Barker和CCK两种扩频编码机制，以及相应的匹配解码机制，能够以较低的复杂度抵抗噪声和多径效应。802.11b中所设计的传输模式，目前仍然是Wi-Fi中传输覆盖范围最远的方式。

*PS：有关802.11b采用的扩频技术，我们以后其他专题再进行详细展开。*

在1999年时，实际上也是HomeRF技术和802.11b技术白热竞争的时期，HomeRF采用跳频技术，802.11b集中于直序扩频技术。虽然最初的IEEE 802.11 1997规定了跳频和直序扩频两种模式，不过后来802.11以及大部分当时从事无线技术的公司更专注于实现简单直接的DSSS方式，也是因为这个原因，802.11在与HomeRF的竞争中获得了优势。

实际上大家开始接触Wi-Fi很多也是从802.11b开始的，802.11b是802.11协议中第一个里程碑，早期的带Wi-Fi功能的笔记本，或者PSP游戏机，其所带的无线功能都是基于802.11b的。802.11b协议是无线网络发展中的很重要的一步。

![img](https://pic3.zhimg.com/80/v2-2de24a62edc5c0b0102b698475bbb08a_720w.png)

同年，基于Wi-Fi原理的Airport技术也有苹果在iBooks中正式推出。

![img](https://pic4.zhimg.com/80/v2-5451b29dfe221ad501e8f3f32366665b_720w.png)

一年以后，另外一个802.11的版本，802.11a也正式通过。不过802.11a可以算是一个生不逢时的版本，802.11a在其时代并没有获得802.11b那样的成功。

![img](https://pic3.zhimg.com/80/v2-2d06b03b08d00f763eea89e741bb5cae_720w.png)

802.11a引入了一种新的物理层技术OFDM（Orthogonal Frequency Division Multiplexing）。OFDM技术是于20世纪60年代就提出的，但是当时其核心算法FFT复杂度较高，随着集成电路技术的发展，到90年代时OFDM技术开始通信工程具体采用。相比扩频技术，OFDM技术有更高的频谱利用率。如上图所示，OFDM是通过时频关系的映射，将多个数字信号搭载到多个频域子载波上（如上图所示），然后通过IFFT合成，将这些数字信号一次性发送出去。通过OFDM，能够获得更高的频谱利用率，提高传输速率。对于OFDM的细节，我们也会在以后进行展开，这里就不详细展开了。

802.11a当时没有受到很好的效果，主要还是频段的问题。因为当时FCC仅在5GHz频段上开放了OFDM技术，据《Next Generation Wireless LANs.802.11n and 802.11ac》一书所言，在1999~2000年间，美国非军事使用的5G频段仅仅只有几个指定的信道。而且由于802.11a和802.11b所在频段不同，所以新出的设备要同时兼容802.11b和802.11a就会造成成本增加，所以实际802.11a的实际应用很少。

![img](https://pic1.zhimg.com/80/v2-8b9e329de16d9ff9775f6db7ae5afcc4_720w.png)

802.11g和802.11a协议在整体上是一致的，更一般而言，802.11g是将802.11a搬到2.4GHz频段上，并加上了一些协议兼容性的设计。

当初实际上也是FCC不允许在2.4GHz频段上使用OFDM技术，仅仅只允许扩频技术。在2002年时，FCC发布了“The rules were changed in 2002 into a spectrum density and maximum total power specification versus a spreading gain specification, opening up the possibility of also using OFDM in the 2.4 GHz band ”，换言之，2.4GHz频段上也可以使用OFDM技术。所以仅仅一年之后，2003年，802.11g协议正式通过。

802.11g协议的物理层叫做增强速率物理层(Extended Rate Phy，ERP)，其为了与之前802.11b协议的兼容性，提供了5种工作模式：ERP-DSSS、ERP-CCK、ERP-OFDM、DSSS-OFDM和ERP-PBCC。802.11g是802.11协议中第二个里程碑，有关其协议的细节内容在我们之前的文章有部分提及，另外部分的内容，之后我们再进行专题总结。

![img](https://pic1.zhimg.com/80/v2-ff3b6f2a1ff9add24847861f60e49d58_720w.png)

鉴于802.11a协议中，可用信道很少的问题，在2003年时，在世界无线电通信大会上，由欧洲的无线电监管机构提出，在5GHz频段上增加455MHz的可用频段，用以给HIPERLAN有关的协议使用。这为Wi-Fi协议重新在5GHz频段上发展，提供了很大的资源空间，在5GHz频段上所增加的这个455MHz的ISM频段，日后成为802.11ac协议所使用的重要信道资源。

![img](https://pic1.zhimg.com/80/v2-d4680aee611173428fd53c8d9488db6c_720w.png)

同年，CALYPSO出品了一款可以基于Wi-Fi语音通信的手机，这为Wi-Fi的商业应用发展提供了更多的可能性。

![img](https://pic1.zhimg.com/80/v2-00e0cfbd856d1543b65743200c60986c_720w.png)

在2004年时，由于传统Wi-Fi的发展都在于其PHY层和MAC层的性能上，协议的安全性并没有得到很好的保证。故在04年时，专门针对Wi-Fi安全的协议标准802.11i正式颁布，实际上，这个时期也有一个中国尝试发起的协议WAPI，也是针对该问题而言的。

![img](https://pic3.zhimg.com/80/v2-605bbc1e5545d63a61cab54a84ac4d8a_720w.png)

在2005年时，802.11MAC的重要改良802.11e协议正式通过。802.11e协议提供了很多对于传统802.11协议网络性能改良的具体方法，比如MAC接入机制引入了EDCA/HCCA，TXOP，Block ACK等等。我们当下所使用的MAC协议以及协议目前的主要版本（比如IEEE 802.11 2007/2012/2016）之类，其MAC层都是直接基于802.11e中所规定的形式而来。之后我们会对802.11e的内容详加讨论。

![img](https://pic1.zhimg.com/80/v2-8b0f5e0fddb4081b944a85e78a2887c8_720w.png)

在2005年的时候，1亿个Wi-Fi芯片已经出产，无线局域网的发展已经初具规模，正式开始迈入繁荣期，于此同时，通信网络也开始迈向3G网络进行发展。

## **Wi-Fi协议的繁荣**

![img](https://pic2.zhimg.com/80/v2-1c9aeb2e642d6a8d161c37b1343082c5_720w.png)

在2009年时，Wi-Fi发展的第三个里程碑，802.11n协议正式通过。一般来说，产品发展会比标准化工作之后，很多产品都是标准公布之后才上市。实际上从802.11n协议开始，在协议通过之前，从2003年开始，各个厂家就基于为最终确认的草案，争先恐后的退出带有802.11n头衔的产品抢占市场，其中大部分产品都无法很好的最终标准兼容。在2007年时，802.11n草案演进为了802.11n 2.0版本草案，到2009年时，其3.0版本的草案最终被作为协议正式通过。在802.11n协议讨论时，实际上也出现了两个主要的提案阵营，TGn Sync（主要包含Intel，Cisco，Agere和Sony）和WWiSE（主要包含Broadcom，Conexant和Texas Instrument）。在投票过程中，TGn Sync一度占据优势，不过协议最终没有通过。直到最后，两个阵营中，Intel和Broadcom综合两个阵营彼此坚持的观点，组建了一个新的阵营增强无线联盟（Enhanced Wireless Consortuim，EWC），从而打破了之前僵局，在经过了多次修订草案后，最终2009年3月，协议得到批准。

![img](https://pic4.zhimg.com/80/v2-d908c5128e2fdfc9f1b63c9676a05d83_720w.png)

相比之前的Wi-Fi技术，802.11n的核心技术概念是MIMO。之前的无线通信我们都是单天线的传输系统，在MIMO的设计上，我们可以通过多根天线，并行传输多个不同数据（如上图，同时传输x1，x2两个信号至RX端），从而提高传输速率，提供更高的系统带宽。

![img](https://pic1.zhimg.com/80/v2-eef35edf097e00516c330e3ee9efc780_720w.png)

在2009年的时候，Wi-Fi芯片规模已扩大至10亿。

![img](https://pic4.zhimg.com/80/v2-3d30a9bcc613c9b6b473de01bd0e9177_720w.png)

同年，在Wi-Fi协议高速发展的同时，IEEE另外一个委员会IEEE 802.16也推出了一个新的W-WAN协议，WiMAX。WiMAX与Wi-Fi不同，其注重更远覆盖范围的无线网络接入。

![img](https://pic2.zhimg.com/80/v2-306d6b4a5dd6818763575656cd53733d_720w.png)

实际上在网络发展中，各个不同源头的技术实际上也是时有交互（如上图）。然而是否成功，还是要根据市场和时机的检验，好比Wi-Fi虽然获得了比较大的成功，而WiMAX则没有被广泛采用。

![img](https://pic3.zhimg.com/80/v2-0a59c57c8b82e1144036a1332b0f41ee_720w.png)

2009年时期，另外一件关注的事情就是CSIRO有关Wi-Fi技术的专利纠纷，该纠纷最终以CSIRO获取2亿的赔偿结束。

![img](https://pic2.zhimg.com/80/v2-1b78a969238897efd1a0022131f8a581_720w.png)

2010年时，基于Wi-Fi的无线热点已经达到了一百万个。

![img](https://pic4.zhimg.com/80/v2-9fee064afcb22f7a481d25912b8ae3cb_720w.png)

在2010年时候，在时任美国总统奥巴马的支持下，FCC同意在未来增加500MHz新频段用以无线通信，该500MHz是分散在多个不同的频段下，具体是根据具体的功能需求进行的设定。

![img](https://pic2.zhimg.com/80/v2-adff43b53b3dd95ff1c857f952a23c8d_720w.png)

在2012年时，CSIRO就拥有的技术专利，导致了第二次有关Wi-Fi技术的专利纠纷。

![img](https://pic2.zhimg.com/80/v2-78337872cd87b1475396a7f820796471_720w.png)

在802.11ac时期后，大众已经对于Wi-Fi技术已经熟悉很多，也有越来越多人需求并从事无线业务。在2014年时，Wi-Fi的第四个里程碑802.11ac技术正式通过，802.11ac的关键词是MU-MIMO。

![img](https://pic3.zhimg.com/80/v2-91c88c0f6adbf62fd45e4f951f8927d2_720w.png)

如上图所示，传统的单波束网络，同一个时刻只能有一个设备进行发送（如左图蓝色区域，一个时刻只能有一个人发送）。而MU-MIMO技术下，通过波束的细化，如右图蓝色部分，路由器发送两个波束，分别对准笔记本和手机，从而达到同时传输的目的。在802.11ac中，只存在下行MU-MIMO，上行不支持。对于802.11ac技术其他技术内容，我们这里就先不进行展开了。

![img](https://pic2.zhimg.com/80/v2-dd2520bcacaa079a24764dcb0f6596c5_720w.png)

在2014年时，第一个802.11ac路由器进行了发布。802.11ac的协议指定过程中，也是存在产品先行的现象，所以在当下802.11ac的产品中，也存在wave 1和wave 2的区别。

![img](https://pic1.zhimg.com/80/v2-67142a13d5c9e565eccf879b252d0cf0_720w.png)

2015年时，基于Wi-Fi的无线热点已经达到了七千万个。

## **Wi-Fi协议的将来**

![img](https://pic2.zhimg.com/80/v2-798ea589c3ae76bf5622f2dbc2c1ccf1_720w.png)

到当下，Wi-Fi发展已经成为了一个新型的无线生态圈，其功能已经不仅仅局限于标准互联网数据的传输。根据其不同的工作场景和不同的需要，其存在不同的协议版本。

Wi-Fi作为一个经过了46年发展的成熟技术，其还在不停的发展中，我们也无法单纯的去分析某一个具体的场景，判断其的发展趋势和价值。对于Wi-Fi协议的将来，应该还是挺好的，以上的讨论主要还是追述一个Wi-Fi发展至今的历史，希望能给大家一个借鉴的作用。

# 初探802.11e（WMM）

## **序言**

最初的802.11协议是没有考虑QoS（Quality of Service，服务质量保证），后来随着802.11b/g版本逐渐在商业场景中获得成功，Wi-Fi的应用场景越来越多。WiFi被更多的用于传输高带宽，低延迟的应用，这也导致无线QOS需求也越来越多。

本文我们就简要介绍802.11协议中的QoS部分，之后几篇我们会对于细节进行展开。

## **QoS in IEEE 802.11**

当前的主要网络架构都是基于“best-effort”的思想设计的，“best-effort”的一种理解即尽力发送，但是无法保证业务流量的QoS，影响QOS的包含延迟，丢包率，抖动等等。

初期在设计802.11协议时，是没有考虑到数据QoS的。但是万事没有绝对的，实际上在初始协议中，有一种帧已经体现出了QoS，该帧也就是Beacon帧。我们通过Beacon这个例子，说明一种802.11协议提供QoS的方法。

802.11中Beacon的时间间隔是TBTT（Target Beacon Transmission Time），其对应的QoS也就蕴含着，在TBTT这个时刻范围，AP需要立刻抢占到信道，发送Beacon帧。而我们知道，802.11协议中，任何一个节点（无论AP还是节点）都是需要竞争信道的，如果是公平竞争的话，那么AP有可能没有办法抢占到信道，从而就会造成很大的延迟，故无法保证QoS，为了保证QoS，所以我们要让AP拥有最高的优先级抢占信道。

我们以下图为例，简单回顾802.11的竞争过程。

1. 节点要等待DIFS时间，在该时间片内，节点首先通过SIFS时间片切换天线的发收状态，然后监听2个Slot（这两个slot是在DIFS内部，不算入CW倒数部分），如果2个Slot都是空闲的话，那么意味信道是空闲的，那么节点可以发起随机接入。
2. 节点在[0，CW]范围内选择一个随机数，作为backoff倒数过程的初始变量（即backoff counter）。该图中，节点选择的是4。每经过一个slot，倒数1次（如图所示的3->2->1的倒数过程）。当倒数到0时，节点获得了信道，从而发起数据传输过程。
3. 节点一次竞争，传输一个数据帧。当传输结束后，节点等待SIFS时间（实际上是进行天线的收发切换），进行ACK帧的接收。ACK是接收方反馈给发送方的确认帧，若发送方接收到该确认帧，那么本次传输完成，反之，传输失败并发起重传。

![img](https://pic4.zhimg.com/80/v2-220c165473be92fbcdb78734f4c0a82b_720w.jpg)

*Remark：其余竞争过程的细节参考（[802.11协议精读2：DCF与CSMA/CA](https://zhuanlan.zhihu.com/p/20721272)）。*

以上的一个传输过程中，等待时间DIFS和backoff counter是影响传输概率的主要影响参数。所以在Beacon的传输过程中，协议设置AP的等待时间为PIFS，并且设置CW=0（具体是设置CWmin=CWmax=0），从而AP选择的倒数时隙直接为0，即不用倒数，立刻发送。

![img](https://pic4.zhimg.com/80/v2-995ccc5ccb1d7c53bec2ed13ee11b3a7_720w.jpg)

以上图为例，我们简述AP发送Beacon的竞争过程：

1. AP发送Beacon时候等待的时间片为PIFS，PIFS实际上就是SIFS加上一个SLOT，即监听一次信道空闲即可。由于PIFS<DIFS，AP能够更快的进入接入过程。
2. 此时又因为AP选择的backoff counter为0，所以立刻占据信道，发送Beacon。在AP发送Beacon时，信道变为busy状态，所有节点都需要接收该beacon。
3. 由于Beacon是一个广播帧，所以没有反馈ACK的环节。当Beacon发送完后，该轮传输完成，节点再次等待DIFS时间后，再次竞争信道。

以上，就是一种802.11中提供QoS的具体方式。基于这种方式，IEEE 802.11协议组定义了802.11e，该协议中将传统的DCF和PCF更替为EDCA和HCCA，后者能够提供QoS。在802.11e中，统一了提供QoS的MAC层接入机制，比如IFS，或者Backoff counter如何控制，除此之外，802.11e还增加了一些关于节能，WiFi直连等额外功能，其所包含主要功能如下：

- **TXOP（Transmission Opportunity）**
- **EDCA（Enhanced Distributed Channel Access ）**
- **HCCA（HCF Controlled Channel Access）**
- **APSD（Automatic Power-Save Delivery）**
- **Block Ack（Block Acknowledgement）**
- **DLS（Direct Link Setup）**

## **802.11e和WMM**

无线QOS的产品实际上是从2002年就开始有了（参考Cisco《端到端QoS网络设计》），在2004年中期IEEE 802.11 Task Group通过了802.11e协议，同年，Wi-Fi Alliance也颁布了WMM（Wi-Fi MultiMedia）。

一般情况下，我们可以粗略认为802.11e和WMM是同一个事物，只是来源于不同的定义。如果考虑细节的话，实际上WMM是802.11e中有关EDCA这部分的分支，关于HCCA部分，WMM是没有兼容实现的。如下图所示，参考《[The IEEE 802.11 Universe](https://link.zhihu.com/?target=http%3A//download.csdn.net/download/fzxy002763/10124178)》。

![img](https://pic1.zhimg.com/80/v2-11c411e46e485b173284d9d6dac3ef60_720w.jpg)

802.11e中，其e的含义即是增强的MAC层（enhancements to the MAC layer，参考《The Innovation Journey of Wi-Fi》）。

## **802.11e的发展**

802.11e协议也在进一步演进，其主要的一些设计，也被802.11项目组进一步演进，成为后续协议的重要组成部分：

- 802.11n：其在802.11e所设计的TXOP和Block ACK基础上，进一步演进协议的MAC层效率，以及还有节能模式上，比如PSMP，SMPS之类的引入。
- 802.11s：该协议规范了mesh网络下802.11的工作原理，其现在所采用的多信道的MAC层接入方式，就是基于802.11e中的EDCA所规定的。
- 802.11aa：该协议主要是视频/语音的组播/广播流的优化，因为在标准的802.11协议中，单播流都是包含ACK的，比如速率适配，ARQ这些，也是基于ACK的反馈进行调节的。缺少了ACK的反馈，那么如何保证这一类流量的QoS性能，就是802.11aa进一步设计的内容。
- 802.11z：这一部分是继续深化802.11e中的direct link setup的相关内容，802.11e中开始提及到的direct link实际上和通信网所提的D2D是相同的概念，而且现在应用很广泛。
- 802.11ae：初始的802.11e仅仅涉及数据帧的QoS优化，对于802.11协议中出现的一些控制帧，是在802.11ae协议中规定的，以此完善整个802.11协议的QoS体系。

本文目前初步介绍了802.11协议中QoS示例，以及简单介绍了802.11e协议的框架和演进，后面我们针对协议的具体运作，一步步再进一步展开。

# 802.11e的优先级

## **序言**

我们在思考如何实现QoS的时候，一般可以把QoS模型简化为二个步骤（Remark：我们这里关注的是区分服务的QoS模型）。

1. **抓取流量**，即对流量进行优先级分类，打标签，存储。
2. **设置策略**，按照不同的传输规则对不同类型的流量进行传输调度。

在上一篇文章中，我们仅仅简介了IEEE 802.11e其QoS的一种基本示例（类似于上述的设置策略）。本文我们关注802.11e中的抓取流量，进行优先级分类的方法。同时本文也着重梳理很多资料中，关于802.11e优先级，802.1q，802.1d和802.1p的关系。

## **802.11e的优先级**

802.11最初没有提供服务区分，所有的流量都被视为best-effort流量。现在为了提供优先级，我们要对数据流量进行分类。

当数据包到达MAC层时，根据802.1d的映射关系（目前看到的官方指南都是这种写法，实际上是802.1p的映射），将原始数据包中的优先级映射到802.1e的不同优先级队列中。如下图（参考自Generation Wireless LANs 802.11n and 802.11ac教材，第8.6节“Enhanced distributed channel access”）：

![img](https://pic3.zhimg.com/80/v2-929d5d72b3104cb3527c39f5018595d6_720w.jpg)

802.11e一共可以提供4个不同的优先级，也可以称为接入类别（Access categories），从高到低排序分别是：

- **语音服务（Voice，AC_VO）**：一般为VoIP流量类型，对延迟最为敏感，同时也是优先级最高的流量。
- **视频服务（Video，AC_VI）**：视频流量的优先级低于语音服务，高于其他两项。视频服务也是延迟敏感类型的服务，所以具有一定的优先级。
- **尽力传输（Best-effort，AC_BE）**：默认的无线流量类型就是best-effort类型，比如网页访问的数据流量类型。对于延迟有一定需求，但是没有那么敏感。
- **背景流量（Background，AC_BK）**：对于延迟要求最不敏感的流量，比如文件传输，打印作业的流量。

## **802.1d，802.1p和802.1q**

按照802.11相关的参考书中所述，实际上仅仅提到的是802.1d。而我们一般认知上，802.1d在说的都是生成树协议，而没有包含优先级之类的内容。所以这里实际上我们要接受一个观点，也就是802.1p和802.1q都是802.1d一部分。故802.11协议中所涉及QOS部分提到都802.1d实际上所指为802.1q和802.1p，这也是从协议发行版的角度而言，可能目前的发行版中已经将802.1q和802.p并入到802.1d到最新发行版中了。这种关系在802.11的一些协议版本中也有体现。

802.11e的优先级实际通过802.1p的优先级映射的，802.1p的优先级实际上是放在802.1q定义的Q-Tag中的。802.1q是关于VLAN的协议，其定义了VLAN的Q-TAG格式。

802.3 with Q-Tag（即802.1q）是一种扩展形式的有线帧数据结构（初始的有线帧格式是在802.3中定义的），其在传统的802.3数据帧结构的Length/Type字段前面增加了一个Q-Tag字段，

![img](https://pic2.zhimg.com/80/v2-14aff3b3923fa8a6f2fb84c77bcc3b65_720w.jpg)

该字段初始是为了VLAN的功能设计的。Q-Tag的具体结构如下（下图中是VLAN TAG）：

![img](https://pic3.zhimg.com/80/v2-8fb65363150791e482b5c5fdb3e9acc2_720w.jpg)

TPID（Tag Protocol Identifier），这个字段是16位，对应原来的802.3的Length/Type字段，其固定值为0x8100。TPID是为了协议的兼容性设计的，支持Q-Tag的节点可以解析，不支持的节点会将其当做Length/Type字段进行解析。在Ethernet中，如果Length/Type小于0x0600的时候，会被当做Length字段解析，如果Length/Type大于0x0600的时候，会被当做type字段解析。由于TPID的固定值为0x8100，所以不支持Q-Tag的节点会无法识别该type，从而不接收，不会导致误识别的问题发生。

TCI（Tag Control Information）包含了3个部分，分别是PCP，CFI/DEI（注：802.1Q里面），VID。

- PCP（Priority Code Point）：该字段就是**优先级字段**，通常我们也将该字段描述为**cos（code of service）**字段，**cos**这种说法更常见一点，同时cos的说法也是对应**tos**的说法**（type of service）**。PCP一共是占据3个字节，能够表示**2^3=8**个优先级，802.1d也就是基于这三个字节定义优先级的。
- CFI（Canonical Format Indicator） / DEI（Drop Eligible Indicator）：CFI字段是由于演进过程中，指示Ethernet和Token Ring的兼容。到了QinQ（802.1ad）中，CFI字段演进为了DEI字段。QinQ也可以说是一种二层VPN的技术，既然是二层VPN，那么就会存在公网穿越的问题，从而在传输数据帧的过程中，就需要考虑丢弃优先级了，从而DEI字段就是为了这个目的。
- VID（VLAN Identifier, VID）：该字段标识了VLAN ID，一共是12位。由于我们关注的是优先级问题，所以关于VLAN的具体内容，我们不进行扩展。

802.1q中规定了cos字段，这个cos字段具体如何使用的，如何标识优先级的，就是在802.1p协议中进行固定的。（图参考Network Warrior第425页）

![img](https://pic1.zhimg.com/80/v2-8673b5a112857cb5fe3b63400b2e6958_720w.jpg)

在上图中，实际描述的是在区分服务场景下，不同cos对应的服务类型。该图本来是描述的是cos和tos的对应关系的，tos现在是属于dscp的一部分。有关cos，tos以及dscp由于我们这里是讨论802.11e的问题，所以就不过多展开了。

我们可以大致理解下这个流程，首先是抓取数据流，这个抓取有可能是在二层上做，也可能是在三层上做。如果是在二层做分类，那么就是抓取流量后，在不同数据包的cos上，添加上相应的标识。如果在三层上做的话，就是在dscp的位置上，做相应的标识。二层和三层的分类标识，也就是cos和tos是可以互相映射的，上一个表格就是一种映射关系。

## **802.1d与802.11e之间的优先级传递**

在802.1d中，优先级是标识在cos位中的，并且和tos（dscp）互相映射的。在802.11e中，也是会存在的这样的映射关系，也就是cos映射到802.11e到优先级，其映射关系如下图：

![img](https://pic2.zhimg.com/80/v2-2ee0969a349e0edd2a6a4196faab60a1_720w.jpg)

图中，802.1d user priority就相当于cos，也就是有线数据帧中的优先级标识。在一个802.11终端中，其会将有线端的优先级首先转义到本地到发送队列，这里也就是不同的AC所表示的发送队列，从而对流量进行分类。由于802.11数据帧不仅仅可以工作在单跳的基础架构模式下，其还可以工作在mesh以及扩展服务集的模式，所以协议中还需要设计qos的传递属性。

![img](https://pic3.zhimg.com/80/v2-5b9098eb99463da202c184c5044679b2_720w.jpg)

qos的传递属性也就是说，在有线qos传递到无线以后，无线需要将这种qos传递到无线relay到场景下，最终保证目的节点接受的时候，这个qos是一直被保障的。在后面发送的过程中，这些信息再次映射到802.11e中所增加的qos control字段内（如上图，参考Cambridge.Next Generation Wireless LANs 802.11n），从而达到优先级传递的目的。其映射关系如下图（参考CWNA书）

![img](https://pic3.zhimg.com/80/v2-bc106e2b30f0934f0acfe1a0ee94a1aa_720w.jpg)

从而我们以上大致介绍了802.11e的优先级，以及其优先级的映射关系（包含有线和无线部分），其余一些别的内容，比如上图的ACK policy，txop之类的，我们之后的内容再进行讨论。

# CCA (Clear Channel Assessment)

## **序言**

在之前介绍802.11中DCF工作模式时，我们讨论过信道检测的部分问题。在802.11中，信道检测包含两个部分，物理载波监听和虚拟载波监听，其中物理载波通常我们所述为CCA (Clear Channel Assessment)机制，本文就关于CCA的机制做一些介绍。

***Remark：由于本文部分内容比较细节，建议是先阅读《[802.11协议精读2：DCF与CSMA/CA](https://zhuanlan.zhihu.com/p/20721272)》后，进而理解本文的一些内容。\***

## **802.11的需求**

我们知道802.11协议是基于半双工的物理层进行设计的，半双工的物理层在设计时会有很多的细节问题需要考量，包含单根天线如何切换，如何识别收发时机等。有了这些基本因素的考量，我们才能够进一步设计802.11的MAC层协议，很多情况下，我们对802.11的MAC层协议理解不够彻底，也是因为对于其物理层的设计以及限制了解的不够多。基于此，我们首先谈谈在半双工情况下，802.11协议有什么需求：

- **需求1： 监听网络中是否有数据包正在发送，并该数据包的信号进行准确的截取。**

![img](https://pic4.zhimg.com/80/v2-a6379e81fb97bc12ca18a804d3227083_720w.jpg)

该需求实际上是从下行的角度考虑的。我们首先考虑一个更简单的场景，一个AP发送，一个节点接收。节点仅仅接收数据包，没有任何的发送功能，从而就不需要引入CSMA/CA的竞争过程。

节点需要接收由AP发送过来的数据包，此时节点仅仅有一根天线接收无线信道，其需要从茫茫信号的海洋中，找到一个数据帧，并且**准确的抓取到数据帧的头部以及尾部**，然后保存下来进行解调。

- **需求2：监听信道是否空闲，避免发送数据包的时候发生冲突。**

![img](https://pic3.zhimg.com/80/v2-c7a7fd538c0f365d93452d8d545e9f82_720w.jpg)

该需求的场景是从上行的角度考虑的。假设现在有一个AP负责收数据，有多个节点负责发送数据。此时，我们考虑采用CSMA/CA的机制，也就是所有节点发送之前都需要监听信道，即LBT (Listen Before Transmission)机制。

那么节点就需要先通过天线采集一小段信号，并从这段信号中分辨有没有人正在传输，**无论传输的人是正在传输，还是刚刚开始传输**，都需要监测到信道忙。

其实以上两点需求是作为发送方和接收方分别提出的，也是由于802.11协议本身是基于半双工的网络，并且是基于分布式的网络进行设计，也就是节点没有一个固定角色，有可能发送，也有可能接收。这样就会导致协议在设计的时候，需要同时考虑以上两个需求，并且引入到协议设计中。

## **CSMA/CA和半双工**

CSMA/CA中很多细节设计，都是考虑到物理层半双工这样的原因。现在基于以上的需求，我们深入理解下。CSMA/CA的基本机制我们已经在《[802.11协议精读2：DCF与CSMA/CA](https://zhuanlan.zhihu.com/p/20721272)》里面介绍过一次。

![img](https://pic4.zhimg.com/80/v2-1a0a9bf8882f19c3e9bd34c53542a177_720w.jpg)

简单回顾下，在CSMA/CA过程中，每个节点首先监听DIFS时间，然后选择一个随机数进行倒数，其中倒数的时间的最小间隔我们称为一个slot（即图上的Slot Time）。首先倒数到0的节点可以发送数据包，而其他的节点会检测到信道是Busy的，所以就悬挂倒数计数器。当发送完数据帧后，等待SIFS时间后，接收AP反馈来的ACK。如果接收ACK成功，那么本轮传输完成，如果失败，那么重来一次竞争，然后再次发送。

展开这个过程：

- **DIFS**（Distributed Inter-frame Spacing）：其翻译成分布式时间间隙，实际上关于几种IFS的命名并不是特别好，没有从其物理意义上命名，而是从概念上命名了。其本质上实际上都是最基本的SIFS和Slot的一个组合。一个DIFS由一个SIFS时间，和两个Slot时间组成。
- **SIFS**（Short inter-frame space）：短时间间隙，在802.11n之前，这个是最短的时间间隙，其包含了aRXRFDelay（射频延迟）＋aRXPLCPDelay（物理层头部接收延迟）＋aMACProcessingDelay（MAC层处理延迟） + aRxTxTurnaroundTime（发送接收天线转换时间）。
- **Slot**：可以理解成竞争过程Backoff的最小时间间隔，其包含aCCATime（CCA时间）＋aRxTxTurnaroundTime（发送接收天线转换时间）＋aAirPropagationTime（传播延迟）＋aMACProcessingDelay（MAC层处理延迟）。

我们用下图具体描述上述三个时间间隙之间的关系，



![img](https://pic1.zhimg.com/80/v2-1b4f059a5b256eae92a41bd5a68e7b38_720w.jpg)

上图出自于802.11协议中的DCF timing relations一节 ，其中D1=aRXRFDelay（射频延迟）+aRXPLCPDelay（物理层头部接收延迟），D2=D1+aAirPropagationTime（传播延迟），M1=aMACProcessingDelay（MAC层处理延迟），Rx/Tx=aRxTxTurnaroundTime（发送接收天线转换时间），CCAdel=aCCATime（CCA时间）-D1。

SIFS通常两种用法，一种是用作RTS/CTS或者DATA/ACK之间的，另外一种是用在DIFS内的。上图我们仅仅关注的是DIFS内的用法。参考上图，SIFS时间内经过了D1，M1后，进行Rx/Tx的转化，这个Rx/Tx的转化从时间上是属于SIFS的一部分，从工作顺序上，已经属于Slot Time的一部分，在Slot Time部分中，节点首先是工作在接收状态，然后经过了D2的延迟后，开始监听信道，也就是CCA过程（即图上的CCAdel），在每一个Slot Time中，节点都会做一次CCA的检测，判断信道中有没有数据帧正在传输。在一个DIFS中，需要连续做两次Slot Time，也就是连续检测两次信道，如果都空闲的话，那么才可以进入backoff过程。若在Slot的CCA过程中，发现有数据正在传输，那么节点转入接收状态。当DIFS结束后，节点进行第一次的Backoff，此时，节点在做完CCA之后，如果信道是空闲的，那么backoff counter-1，如果此时恰好倒数到0，那么此次天线从Rx切换为Tx之后，那么直接进行数据发送了。

若SIFS用于DATA/ACK之间的话，那么在SIFS时间之前，节点是处于发送状态，其现在需要“等待”SIFS时间来接收对方反馈过来的ACK帧。当其经过D1和M1两个处理时间后，其需要切换为接收状态。当切换为接收状态后，其开始接收ACK。

在整个802.11的backoff和IFS中，实际上是不停的进行收发状态的切换，因此来实现我们前面所述的一些802.11中的需求。以上讨论中，已经出现了本文要讨论的主要目标CCA (Clear Channel Assessment)，以下我们具体展开CCA的具体内容。

## **CCA (Clear Channel Assessment)机制**

前面我们讨论了，半双工的机制下802.11中的需求，因此在整个802.11过程中，就一直存在收发过程的切换，而且在Slot过程中的每一次切换，实际上都包含了一次信道检测CCA的机制。在协议中，CCA主要分成了两种方法，Energy Detection（能量检测）和Carrier sense（载波侦听）。

- **载波侦听（Carrier Sense）**：**载波侦听用作检测数据包的Preamble，可以识别一个数据包的起始边界。**简单的说，802.11中的preamble部分采用特定的序列所构造，该序列对于发送方和接收方都是已知的，监听的节点会不断采样信道信号，用其做相关运算，其计算值需要与一个阈值进行判断。若大于，则认为检测到了一个信号，若小于则没有检测到。节点在识别到数据包头部以后，对数据包进行接收并进行解调，并通过解调出数据包内部的Length字段来识别数据包的终止边界。
- **能量检测（Energy Detection）**：**能量检测采用硬件积分能量，其无法识别数据包的边界，但是能够识别数据体中的能量，已经来自其他异构网络的能量（比如蓝牙设备，微波炉之类）**。是直接用物理层接收的能量来判断是否有信号进行接入，若信号强度大于ED_threshold，则认为信道是忙，若小于ED_threshold，则认为信道是闲。

**能量检测的阈值要大于载波监听，按照协议规定要大于20dBm**。协议中规定，两种检测方式同时采用，且只要两者检测方式中，有一种判断信道是busy的话，那么就认为信道是busy的，只有两者都认为信道空闲时，那么再判断虚拟载波监听机制是否为0，以上条件都满足时，那么才可以进行backoff倒数。

在802.11中（以802.11a/g为例），**载波侦听阈值为-82 dBm，能量检测阈值为-62 dBm**。协议原文（参考2007第17.3.10.5 CCA sensitivity节）如下。

![img](https://pic2.zhimg.com/80/v2-eca6c48562a6c7d510ce50010a375e85_720w.jpg)

***Remark：由于关联到primary channel和secondary channel的问题，本文不对802.11n以后的CCA进行展开，故只引用2007版本的协议。***

在802.11协议中，并没有直接给出-82 dBm和-62 dBm阈值的计算方法，我们所知-82 dBm实际上和最小的MCS灵敏度（minimum modulation and coding rate sensitivity）是相等的。以笔者目前所知，可以有以下几种理解方式：

- 关于-62 dBm实际上是从RLAN时期开始就存在的了，这个是一个能量阈值，是根据发送功率所设定的，目前802.11协议中，关于能量检测的阈值默认是设置在-62 dBm，相比笔者在上一篇《[802.11协议精读2：DCF与CSMA/CA](https://zhuanlan.zhihu.com/p/20721272)》所提的要大一些。这个阈值是假设区域内，干扰的发送功率是在100 mW以下或者EIRP是在 200mW 以下时，能量检测的一个阈值，该阈值可以被用作Energy detection的threshold以外，还可以用作DFS的threshold，在主动回避雷达干扰上也有所用到。

![img](https://pic4.zhimg.com/80/v2-8d95e9ed45734e30af21905fa010df57_720w.jpg)参考《TV White Space Spectrum Technologies: Regulations, Standards, and Applications》，第294页

![img](https://pic3.zhimg.com/80/v2-abaea318665fa20831422d0bb49fa36e_720w.jpg)参考《New Rules for Unlicensed National Information Infrastructure (U-NII) Bands KDB 789033, KDB 644545》

- 关于-82 dBm是基于识别Preamble的检测阈值，在802.11a中，检测preamble是通过数据帧的STF字段，参考之前一篇《[802.11协议精读7：802.11a/g的发送过程与接收过程](https://zhuanlan.zhihu.com/p/21485216)》

![img](https://pic4.zhimg.com/80/v2-5f629f801529f73100014126b64e19b3_720w.jpg)

其中STF的t1-t7这个部分是用作载波侦听检测的，采用相关计算的方式，通常采用自相关。我们可以从-62 dBm是单个能量检测的阈值，又因为我们知道相关检测实际上是可以带来信号单位能量的增益的，这里一共相当于16*7=112个采样点，所以大约能提供20dB左右的增益，所以我们可以通过-62 dBm-20 dB=-82dBm这种方式来理解，也就是说载波侦听检测可以在更低的信号强度下识别出目标。

还有一种关于-82 dBm的理解方式，参考IEEE 802.11-17/1479r1《CCA sensitivity》一文，其中给出了如下的计算方法：

![img](https://pic4.zhimg.com/80/v2-aaa9a6de33ec34a01d2ddb359d1d19ef_720w.jpg)

第一部分是Noise floor，也就是本底噪声，这个数值的计算我们在《[802.11协议精读15：链路模型（基于Free-Space Path Loss）](https://zhuanlan.zhihu.com/p/24332783)》介绍过，这里是采用通常16.25MHz下的本底噪声-102.1 dBm，这个和CWNA书中第3.4节以及第3.6节指出，一般2.4G信道的本地噪声为![[公式]](https://www.zhihu.com/equation?tex=-110dBm+%5Csim++-100dBm)是相符合的。第二个部分是在最小MCS的接收灵敏度上所带来的一个信号的增益，然后是Noise figure (噪声指数)，这里是通常表述为RF接收放大所带来的增益，然后最后是Implementation marigin，实际上是实施中的一些裕度所带来的增益，这一块理解不多。最终计算出大约是-82.4 dBm，约等于-82 dBm。

![img](https://pic2.zhimg.com/80/v2-b6571f5d905675de00ac0e4227400a09_720w.jpg)

其中关于Noise Figure（NF）和Implementation margins是早期802.11a协议中所指定的，目前我们就直接延续使用-82 dBm这个阈值了。

# 再论APSD节能模式

## **序言**

在很早之前我们介绍过了传统的802.11的节能模式，以及其扩展的APSD，PSMP，SMPS（可以参考：[802.11协议精读10：节能模式（PSM）](https://zhuanlan.zhihu.com/p/21623985)，[802.11协议精读11：节能模式（APSD，PSMP，SMPS）](https://zhuanlan.zhihu.com/p/21927713)。），当时在理解APSD的工作模式时，仅仅说明了其工作的方法，从理念上理解较浅，以及为什么这个工作模式会在802.11e中被定义，其和QoS的有什么关系，这些问题都一直困扰笔者。笔者最近在阅读《[Aruba 802.11ax White Paper](https://link.zhihu.com/?target=https%3A//www.arubanetworks.com/assets/wp/WP_802.11AX.pdf)》时，发现对这个问题有很好的解释，所以这里总结一下。

*Remark：由于APSD分成S-APSD和U-APSD机制，本文以U-APSD作为代表，重新说明下，S-APSD类似于PCF这样的调度形式的机制，基本目的和U-APSD相同，只是一个是基于AP下行调度（即S-APSD），一个是基于节点上行触发（即U-APSD），有兴趣可以参考之前的精读11的文章。*

## PSM机制（**Power Save Mode**）

自从802.11b的设备问世以来，节能模式就已经被真实的802.11设备所采用了。在最初的802.11中，节能模式（PSM）的工作模式较为简单。当时PSM分别对应DCF和PCF有不同的工作模式，虽然大体上是类似的，但是细节上有一些差异。PSM的基本工作思想大致如下：每一个终端可以在一个或者多个beacon周期间（beacon周期又称TBTT）进行休眠，该周期是一开始终端和AP关联时就商量好的。这是一个确定的休眠周期。AP每一回合都会通过beacon传输DTIM信息（Delivery Traffic Information Map），通过DTIM中的bitmap，每一个节点都知道是不是有下行数据需要进行接收。若本周期节点正好苏醒，并且通过DTIM获知本轮有数据待接收，或者本地有数据待传递给AP，那么其本周期保持苏醒，并触发并向AP接收或者反馈数据。反之，那么本周期终端短暂苏醒后，就可以继续进入睡眠状态，从而节能。

![img](https://pic2.zhimg.com/80/v2-5701f3beec0e7bf2f2c46c5ac6843b59_720w.png)

我们结合上图，举例说明下PSM-DCF的工作机制。图中一共标识了终端工作的三种模式，其中蓝绿色代表其工作在睡眠模式（sleep mode），灰色代表接收模式（listen or receive mode），蓝色代表发送模式（transmit mode）。终端一开始是工作在睡眠模式下，当其睡眠周期到达时，其会提前苏醒，并接收AP发送的Beacon帧，进一步解析Beacon帧中的DTIM字段，看本轮中AP有没有缓存其对应的下行数据。若本轮有数据待接收，那么终端会保持苏醒，并执行信道竞争。当竞争胜利后，其会发送一个请求帧（实际上是Poll帧，图中标识为Trigger）向AP请求下行数据。AP接收到后，反馈下行数据给终端。当终端成功接收到下行数据后，其反馈ACK，此时若终端本身也有上行数据的话，那么也会一次反馈（如图上所示）。当这一次上下行传输后，节点进入睡眠状态。我们需要注意，在该beacon周期内，仅仅存在一次特定终端的上下行数据帧交换。在下一轮beacon周期内，由于DTIM中没有指示终端有数据，那么就保持睡眠状态。直到第三个beacon周期，那么终端才进行苏醒，并和AP执行一次上下行的数据帧交换。

PSM模式是一种有效的节能模式，但是其仅仅允许终端在多个Beacon帧周期间进行休眠，终端通常需要唤醒多次才可以成功收发数据，这点在于一些QoS所需的业务流量上，会有比较大的延迟开销。因此在后续的802.11e协议上，就需要对这一点进行改进。

## U-APSD机制（Unscheduled Automatic Power-Save Delivery ）

IEEE 802.11e是针对传统802.11没有提供QoS的问题上，做的一个改良。在802.11e中引入了多种流量类型，尤其是明确了对voice-over-WiFi，即语音流量的支持。通常语音流量的间隔大约为20ms左右，而标准的PSM工作周期是基于beacon周期的，该周期一般为100ms左右，因此标准的PSM是无法用于语音流量的，从而在802.11e中为了改善这一点，提出了一种新的节能方式APSD（Automatic Power-Save Delivery），APSD包含S-APSD（Scheduled Automatic Power-Save Delivery）和U-APSD（Unscheduled Automatic Power-Save Delivery）两种具体机制。

我们这里理解下U-APSD的工作机制。其实简单来说，PSM关注的是beacon周期间的节点节能，终端在一个beacon周期内，要不是睡眠，要不是苏醒。U-APSD关注的是在一个beacon周内的间隔睡眠问题，即在一个beacon周期内，终端会不断切换睡眠和工作的状态，从而达到节能的目的。和传统的PSM一样，AP会为终端缓存下行的数据流量，当终端间隔苏醒后，会主动向AP发起请求，尤其是像语音这种对称流量的场景，终端可以在beacon周期内不断的触发发送和接收语音数据帧。

![img](https://pic4.zhimg.com/80/v2-49b6c521a04b8cd0c17f0c095a8bf3af_720w.png)

如上图所示，终端仍然有三种工作模式，睡眠（sleep mode），接收（listen or receive mode）和传输（transmit mode）。在一个beacon周期内，终端首先休眠很短的间隔（此时由于没有数据帧），当上层语音数据帧到达时，节点苏醒会进行发送（即触发一次上行发送），AP接收到该数据帧后，进行下行的语音流反馈。当一次语音帧交换后，终端进入睡眠状态，当然这个睡眠状态很短。当新的一个上层语音帧到达后，节点又会在本beacon周期内，立刻苏醒，然后进行发送，并获取一个AP传输的下行语音帧，如此类推。

U-APSD能够有效在一个beacon周期内进行节能，对于具有QoS需求的流量而言，这种节能方式更适合一些。S-APSD的工作方式类似于U-APSD，主要区别在于是下行先触发（即AP先发送Data），还是上行先触发的（即终端先发送Data），其余大体类似。因此我们能够更好的理解APSD的工作场景和其实际意义。

# 学习资料整理补充（开发相关）

## **序言**

笔者在之前已经整理过一些关于802.11协议的相关内容，包含理论部分和实践的部分。其中关于驱动开发这一部分，笔者在自己的学习过程中又整理了一些资料，个人觉得还是比较有帮助的。所以记录在这里。（PS：其中有的附上的下载链接均为网上搜索而言，仅为学习使用而已)。

*Remark: 上次的书目 - 《[802.11协议精读1：学习资料整理](https://zhuanlan.zhihu.com/p/20716157)》*

## **驱动开发类**

**1. Programming with Libpcap - Sniffing the Network From Our Own Application**

pcap开发的学习资料，我们一般都是直接用抓包软件进行抓包，或者如果编程之类的，在无线侧也是直接配合python+scapy或者lorcon之类的软件，很少有直接关注pcap库的，本篇文章是对libpcap做一个简介，对于深入了解抓包原理是比较有帮助的。目前收集到资源如下，【[Programming with Libpcap](https://link.zhihu.com/?target=https%3A//download.csdn.net/download/fzxy002763/11981346)】。

**2. Linux Wireless架构总结**

这份资料没有一个明确的名字，主要是关于无线架构方面，包含了关键数据结构,各层间关键数据接口,USB 无线适配器枚举过程等过程的缩略图，可以参考下。目前收集到资源如下，【[Linux Wireless架构总结](https://link.zhihu.com/?target=https%3A//download.csdn.net/download/fzxy002763/11981349)】。

**3. linux 无线网络系统**

该资料实际上还没有写全，可能是当作作者没有持续更新的，作者大致整理了Cfg80211的一些过程，因为这方面的资料比较少，所以笔者还是把资源整理到这里。目前收集到资源如下，【[linux 无线网络系统](https://link.zhihu.com/?target=https%3A//download.csdn.net/download/fzxy002763/11981351)】。

**4. The mac80211 subsystem for kernel developers**

这份资料比较好，标题就是适用于内核开发者看的802.11开发指南，主要关注的是内核侧关于802.11开发的资料。之前我们介绍过一本资料《Linux Kernel Networking》，这本书对于Wi-Fi内核开发虽然也有解读，但是信息没有这份资料全。目前收集到资源如下，【[The mac80211 subsystem for kernel developers](https://link.zhihu.com/?target=https%3A//download.csdn.net/download/fzxy002763/11981355)】。

**5.Linux Wi-Fi open source drivers-mac 802.11**

这一份资料上一次就整理过的，这次因为是关于驱动开发方面再整理下，所以又放了一遍。该材料比较完整的叙述了从kernel到802.11驱动底层的一个函数调用过程，用来学习802.11具体驱动过程是一份比较好的材料。该资料的资源如下，【[Linux Wi-Fi open source drivers-mac 802.11](https://link.zhihu.com/?target=https%3A//download.csdn.net/download/fzxy002763/11981358)】。

**6. The mac80211 TX Path**

这是关于mac80211部分具体发送过程的流程图，虽然资料的信息不多，但是这个流程图还是挺有用的，有的时候用数据包inject之类出问题的时候，可以参考做进一步调整。该资料的资源如下，【[The mac80211 TX Path](https://link.zhihu.com/?target=https%3A//download.csdn.net/download/fzxy002763/11981362)】。

**7. Analysis of Open Source Drivers for IEEE 802.11 WLANs**

这是一篇paper，虽然作为学术论文而言，创新点不大，仅仅是一个知识总结。但是作为一份入门的802.11驱动开发资料，还是可以的，文中基本列举关于802.11驱动开发的一些基础知识，苦于这个范畴一直都没有特别好的教材，所以这一份资料也可以参考下。【[Analysis of Open Source Drivers for IEEE 802.11 WLANs](https://link.zhihu.com/?target=https%3A//download.csdn.net/download/sony_zhang/3794827)】。

## OpenWRT开发类

在上次的书目到现在之间，又出了基本关于openwrt开发的中文书，所以这里总结下。

**1. 智能路由器开发指南**

这本书实际上内容不是很深，都是关于一些基础的openwrt开发知识，不过内容倒是很实用了，作为一个openwrt上层的开发者，后者入门的话，还是很适合的，不过对于细节，比如说驱动之类的，信息就很少了。更加适合新手学习。

**2. OpenWrt智能路由系统开发 - 跟hoowa学智能路由**

这本书在面世之前，笔者已经读过其word版本的，不过当时并不知道这个是准备出版的书哈。这本书相对比上面一本，信息会多一些。不过可能还是偏向于openwrt的开发者。整体架构还是不错的，内容也比较广，比较适合入门开发使用。

*Remark: 因为上门两个都是出版的书籍，可以自行购买阅读哈。*

# 静态帧分片（Frame Fragment）机制

## **序言**

静态分片机制是802.11一开始引入的一个机制，早期的作用是为了DSSS模式下，一个帧长度太长，同时因为传输较慢，所以被干扰概率大，所以采用分片一段一段传。随着OFDM的Wi-Fi技术主流后，分片技术逐渐用处变弱，目前主要是为了一些和其他网络兼容的情况，才进行分片，因为802.11的最大PPDU大小实际上是大于二层以太网数据帧（1500B）或者其他网络的MTU的，所以这里也会用到分片。同时，针对于帧分片的传输机制，实际上我觉得应该是TXOP传输机制的前身。

那么这一次我们单独把静态分片拿出来回顾一下，主要是为了对应802.11ax中的动态分片技术。在802.11ax（Wi-Fi 6）中，为了优化UL-OFDMA/DL-OFDMA接入机制，其协议引入了动态分片的机制。所以本文我们先回顾下静态分片机制。

## 静态帧分片机制

Fragment分片机制是802.11早期就已经存在的，这里的分片指的是二层分片，是基于无线MAC帧进行分片，然后重组。请注意，这个和基于IP的分片机制不是同一个，在网络协议中，每一个层面都可以引入分片机制，但是不能够将其混淆。

在802.11协议中，引入分片技术目的在于：减少BER所带来的损失，由于初期的无线传输容易收到干扰或者噪声影响，所以不适合传输较长的数据帧。如果数据帧越长，那么发生错误的概率就越大。反之，通过分片技术，将一个长帧切分成多个小帧，由于每一个小帧长度较短，从而就不容易发生错误。因此，最后在接收端合并，从而实现成功传输。

相比于有线网络，IP层需要分片主要是由于有线MAC层的MTU大小限制，相对于有线网络，无线的MAC层MTU会大很多，而应用层以上的分片的原因就更多，比如说负载均衡之类。故无线分片和有线的分片还是有本质的差别。

在直到802.11-2016版本中，802.11协议仅仅支持静态分片技术，即通过设置的一个固定threshold阈值（dot11FragmentationThreshold），如果数据帧（一般指的是MPDU）大于threshold，那么就会把数据帧分片。

## 静态帧分片的标志位

帧分片技术的实现主要有两个标志位，一个是位于Frame Control中的More Frag字段，其与分片模式下的传输机制有关，另外一个是用于维护分片序列片段的序列号，位于Seq-ctl字段。

![img](https://pic1.zhimg.com/80/v2-12c458f63d3a3bebfc7f12160c59617c_720w.jpg)

在802.11中Seq-ctl字段主要包含了两个部分。一个部分是用于分片的序列号（Fragment Number），其初始为0，每新增一次分片其会增加1。另外一个部分是Sequence Number，这个序列号主要是为了维护ACK的，也是从0开始计数，如果满了以后那么循环为0，重新计数。

![img](https://pic1.zhimg.com/80/v2-ac457b4ab5aeee8ebe5214cac8ef35f8_720w.jpg)

## **静态帧分片的接入机制**

静态帧分片的传输是早期802.11引入的，其早期的传输是一种连续传输的机制。如下图所示：

![img](https://pic3.zhimg.com/80/v2-921b1daa319a492a305c8124a1fff5d2_720w.jpg)

一个完整的MAC层数据MSDU，被帧分片技术分成了多个帧，其中每一个帧就是一个独立的MPDU。每一个MPDU按照背靠背（back-to-back）的顺序依次传输，每一个帧都会反馈ACK。直到所有的MPDU都在接收方接收到以后，接收方才会根据frag number，也就是分片序列号进行重组，获取完整的MSDU。

![img](https://pic3.zhimg.com/80/v2-82831884985e1397040d8f0d0dda4e0a_720w.jpg)

背靠背（back-to-back）的传输方式可以认为是TXOP机制的一个前身，这是一种典型的突发传输（Burst Transmission），意思为当某个STA竞争获取到信道以后，接连传输，直到整个帧被全部传完。该技术的实现是通过NAV技术实现的。

如上图所示，节点Station 1抢占到信道后，发送了Data frag 1，该帧中的Duration被设置了Data 2+2×ACK+3×SIFS，通常情况下，经过静态帧分片的几个PPDU，在传输时都会采用相同的物理层参数（即传输速率设置），由因为Station 1有整个帧分片的全部信息，所以该Duration的时间设置可以包含了完整MSDU在物理层传输所需的全部时间。同时，该分片帧中，还需要进行More Fragment字段的置位，代表还有分片字段待传。

在该帧传输后，接收方反馈ACK，并在ACK中继续通过Duration字段进行NAV设置。其设置方法就是在Data frag 1的Duration参数上减去SIFS和ACK的传输时间，如上图，ACK1是设置为Data 2+1×ACK+2×SIFS的时间，并在More Fragment字段置位。以此类推，直到最后一个ACK的传输，此时由于整个帧分片被传输完成，所以最后的ACK的Duration设置为0，同时More Fragment也被置0，代表整个传输过程完成。

![img](https://pic3.zhimg.com/80/v2-99a61f3dbcd1640a8c92fca7772546de_720w.jpg)

另外，如果RTS threshold的设置小于帧分片的大小的时候，那么只有第一个帧在竞争胜利后，先采用RTS进行设置。由于RTS/CTS的基理和分片不同，所以RTS/CTS交换时，其NAV仅仅会设置首个Fragment 0的片段的，其后的背靠背传输是利用帧分片本身设置的Duration参数来实现的。

由于二层帧分片关联到Duration的参数设置，一般是由硬件实现的，通常Fragment Threshold（dot11FragmentationThreshold）的设置和RTS Threshold是一样的。因此，关于重传机制，也是立即重传的。也就是如果某个帧分片传输错误，那么就立刻进行该帧分片的重传。重传时，Duration设置的NAV时间也会被增加，会把重传的时间重新加入在内，该点也是和TXOP传输机制的区别。

因此，802.11协议中规定了两个参数dot11MaxTransmitMSDULifeTime（发送方）和aMaxReceiveLifetime（接收方），通过这两个参数，维护了帧分片传输的最大时长，避免了帧分片在错误模式下无止尽的传输。当发送或者接收方传输时间大于这两个参数，都是进行直接丢包，放弃这一次帧分片的传输。

在后来的802.11协议中，由于OFDM物理层技术的应用，帧分片的原来使用场景基本上不太存在了，主要是为了和其他协议的数据帧长度兼容，所以要用到帧分片。同时，由于引入了帧聚合技术，所以帧分片大多都仅仅是一种分片的结构，其传输机制依赖于其他的传输方法，比如帧聚合的传输机制。

# 802.11e（TXOP，Block_ACK）

## **序言**

802.11e是802.11协议中，一个阶段性的改良版本。我们目前绝大部分802.11协议用到的MAC层接入机制，都是基于802.11e时期开始定义的。在802.11初期，仅有的PCF和DCF两种机制，不能够满足网络不同业务的增长，所以才有了802.11e诞生。在此之后，关于QoS问题也俨然成为802.11中的一个典型问题被进一步讨论，在实现上有ATF，在协议上还有802.11aa和802.11ae等相关版本，都是针对QoS而言的。

本文针对802.11e的相关功能做一份阐述。之前我们有一篇关于《[802.11协议精读21：802.11e的优先级](https://zhuanlan.zhihu.com/p/31408247)》阐述了802.11协议中的QoS映射关系，本文着重讨论的就是802.11中的协议规则，也就是当给数据包标记后，如何为其在无线端口提供QoS保障的功能。

***Remark：**以下几篇有关802.11e的文章，参考《802.11 QoS Overview》 by Philippe Klein，该资料笔者也备份如下，[802.11e slide (Philippe Klein)](https://link.zhihu.com/?target=http%3A//download.csdn.net/download/fzxy002763/10113890)。*

## 802.11e和WMM

802.11e于2004年正式通过，是802.11协议中关于QoS的一份重要补充。802.11协议最初是为了数据的无线通信，而针对于语音等相关有QoS需求的业务没有考虑。所以随着802.11发展的越来越快，比如基于Wi-Fi的语音设备也就诞生了。不过由于初始的802.11协议没有QoS功能，所以都是厂家自己实现一些QoS机制，我们可以看《802.11权威指南》中给出的一个事例：

![img](https://pic4.zhimg.com/80/v2-1669723b8faa13e4b88a9ffaa20dcf9f_720w.jpg)

翻译如下：

![img](https://pic2.zhimg.com/80/v2-1fa6e1be4c0c62698c56e880227561d9_720w.jpg)

可见，实际上在802.11初期，随着业务的需求，已经有个别公司开始进行QoS的设计。但是由于协议的限制，其只能够采取一种非常特殊的设计，也就是“零退避机制”。由于大部分的业务厂家都没有涉及的IC层面，此时芯片上只能设置一个种非常特殊的backoff初始值，也就是CWmin=CWmax=0，通过这样的设置，可以保证backoff本来所选择的随机数一定是0，因此如果节点这样选择，代表不再进行802.11的竞争，直接可以发送。这种基本本来存在是为了发送802.11的beacon帧的，beacon帧的发送机制实际上就是“零退避机制”，然而如果滥用这种机制的话，虽然可以提供更高的优先级，但是这会对于该网络内其他节点的传输造成影响，所以其不再是兼容802.11的。

因此，在2004年时候，802.11e的协议指定让这个问题可以从协议上直接解决。协议上主要在MAC层引入了EDCA和HCCA的工作模式，同时为了优化网络性能，还引入了Block-ACK等相关机制。

![img](https://pic4.zhimg.com/80/v2-32dd8be5e4b25a45012e1771aa58487b_720w.png)

另外，我们在这里还需要谈谈WMM和802.11e的关系。其实Wi-Fi联盟也有一份关于QoS的协议，WMM（Wi-Fi-WMM-Specification）和WMM-PS，笔者这里提供一份该协议1.2版本的（[Wi-Fi-WMM-Specification-v1.2.0](https://link.zhihu.com/?target=https%3A//download.csdn.net/download/fzxy002763/12231014)），大家可以对比下WMM协议和802.11协议的区别。

可以简单而言，WMM就是802.11e的一份工程性更好的子集（主要是包含了EDCA和U-ASPD机制，分别对应WMM协议和WMM-PS协议）。为什么会出现WMM呢，在802.11权威指南里面说过，WMM和802.11e的关系类似于WPA和802.11i的关系，主要是802.11e在制定当时，迟迟没有定案，所以产业界提取了其中最需要的部分，形成了WMM。WMM基本对应了EDCA，WMM-PS基本对应了ASPD。

现在我们在设备上可以控制的，通常还是叫做WMM，而没有称呼为802.11e技术。

![img](https://pic3.zhimg.com/80/v2-f76ed09059d4c950783ee422817cc5f6_720w.jpg)

如上图所示（额，最近手头就一个DD-WRT的了，就拿这个截图了），这是DD-WRT里面关于WMM的设置，目前绝大多数的路由都可以设置WMM。上图中，我们可以看到一些可以设置的参数，比如说NO-ACK，CWmin，CWmax，AIFSN等等，这些都是与802.11e的技术有关。802.11e中包含了多个技术功能，比如说EDCA，HCCA，Block-ACK，TXOP，TDLS，ASPD等等，以下我们逐个进行一个介绍。

## EDCA和HCCA（概略）

EDCA和HCCA是802.11协议中，对于MAC层技术的改进。在早期的802.11中，仅仅只有DCF和PCF两种接入模式。在802.11e中，为了引入QoS的考量，新引入了两种接入模式，HCCA（HCF Controlled Channel Access）和EDCA（Enhanced Distributed Channel Access）。

![img](https://pic2.zhimg.com/80/v2-5649e92578fefc26be1266415df03611_720w.jpg)参考：802.11-2016

参考上图，在802.11-2016版本的总章中。在标准的802.11MAC层协议中（目前协议除了标准的802.11以外，还有DMG，即802.11ad），其在物理层以上，首先是基于DCF接入模式。在DCF接入模式以上，还包含了PCF，HCCA，EDCA和MCCA。其中PCF是802.11协议最初就包含的，HCCA和EDCA是802.11e中所包含了，目的是为了解决QoS问题，MCCA是在Mesh模式下提出的。

在HCCA和EDCA中，最重要的元素就是TXOP。HCCA相比EDCA较为简单点，其实际上是PCF+TXOP的一个版本。而EDCA也支持TXOP，在此基础上，由于EDCA是支持竞争的协议，所以在竞争过程时还引入了AIFS和CW优先级相关元素。因此，我们首先整理TXOP的相关内容，在分别讨论两种接入模式。

## **TXOP与ACK模式**

Transmission Opportunity（TXOP），在CWNA中文版上，将此翻译为竞争传输机会。

- 在802.11e之前的协议中，都是“**竞争一次，传输一个帧**”，用协议的说法，即是“length based transmission”，length指的就是每个帧的长度，当节点竞争成功后，其就传输其对应数据帧的长度，也就是获得单个数据帧的信道传输时间。
- 单个帧（非TXOP）的传输是通过**物理载波监听**来保证的。
- 在802.11e中引入的TXOP，实际上是“**竞争一次，获得一段传输时间**”，协议的说法为，“duration based transmission”，即节点竞争成功后，其获得了一段信道使用时间，在这段时间内，其可以传输多个数据帧。这种传输方式也经常用“Burst ”这个词描述。
- TXOP的传输时间是通过**虚拟载波监听**来保证的。

**Remark**：*有关虚拟载波监听和物理载波监听，可以参考[802.11协议精读2：DCF与CSMA/CA](https://zhuanlan.zhihu.com/p/20721272)中的描述。*

在TXOP之前，也有一种传输方式类似于TXOP的机制，不过也有区别，其就是静态分片的传输模式（[802.11协议精读25：静态帧分片（Frame Fragment）机制](https://zhuanlan.zhihu.com/p/109842637)）。该模式也是可以做到单个节点竞争成功后，连续发送帧的。但是其目的和TXOP不同，TXOP目的是发送多个帧，而帧分片是将单个帧（MSDU）切分成多个片段，然后一次性传输。

![img](https://pic2.zhimg.com/80/v2-d5c32c30a0a064c2243ef75d3e930e61_720w.jpg)参考：Cambridge.Next Generation Wireless LANs.802.11n

如上图描述的是两次TXOP的传输，STA1是第一次TXOP的发送者，STA2是第二次TXOP的发送者，第三行为两次传输的接收者（图例中再次标注STA2实际有点问题）。当STA1竞争成功信道后，其发送一个QoS Data开启一段QoS时间，该时间足够传递三个数据帧。在该TXOP时间内，STA1逐个发送Data，当发送完一个Data后，如果接收方反馈了ACK，那么就发送。此TXOP时间实际仅仅改变了802.11中一次竞争一次传输的规则，现在可以一次竞争多次传输了。并且每一次TXOP传输时间内，实际采用的物理层速率是不同的。那么意味着在该TXOP时间内，究竟能够传递多少个数据包是不等的，如上图所示，在第一个TXOP时间内传递了3个Data，在第二个TXOP时间内，传递了2个Data。


在TXOP中，**通常开启是采用四种帧**，分别是：

- 1）Qos_Data，利用普通QoS数据帧起始TXOP时间，
- 2）QoS_Null，有PHY_Header和MAC_Header，没有MAC层的SDU，
- 3）QoS(+)_CF-Poll，用于HCCA中的TXOP机制，
- 4）RTS/CTS，多功能的控制帧。

然后对应**TXOP的传输模式（ACK模式）**，其实都是与ACK有关的，分别是

- 1）Normal ACK：一个包一个ACK反馈，
- 2）无ACK反馈，
- 3）无显示的ACK反馈，这个比如PCF里面会用到的多功能帧，ACK+Poll这样的组合帧，
- 4）突发传输（Burst Transmission），Block ACK反馈，。其实我们一开始看到的DD-WRT下面可以设置的无ACK也是基于802.11e的特性。

![img](https://pic3.zhimg.com/80/v2-5c136a811870879c07c5706cd80a8d96_720w.jpg)参考：cambridge 802.11n的书

这个ACK反馈的字段设置是在QoS Control field里面。下图是参考cambridge书里面的，由于协议里面关于Qos-Control的内容与subtype有联系，所以内容很多就没有直接用协议的图。

![img](https://pic4.zhimg.com/80/v2-1b6fc2dcb1e4fd27dab45908247db89f_720w.jpg)参考：cambridge 802.11n的书

根据不同的ACK策略，导致在TXOP传输时的形式会不同。比如下图所示：

![img](https://pic4.zhimg.com/80/v2-935fbfd1e7c8ccdf13921df62b0760af_720w.jpg)参考：cambridge 802.11n的书

图a显示了节点以RTS/CTS开启一段TXOP时间，然后节点发送数据帧，这种就是一种突发传输（Burst Transmission），在802.11n里面还引入了PIFS可以缩减突发传输的帧间隔。而且在此时候，突发传输就演变成了帧聚合，最大化提升无线传输效率。

在TXOP传输过程中，不一定要在本TXOP时间内获取ACK的反馈，比如上图STA1在第一个TXOP传输结束后，没有立刻要求回复ACK，其在第二个传输时间结束后，才通过BAR申请ACK的反馈。

**TXOP的冲突问题**：通常normal ACK的情况和普通802.11的差不多，影响不大。但是如果是burst的传输模式下，当节点竞争到信道后，其就会在整个txop时间内做突发传输，这个时候如果有冲突的话，那么就是冲突整个TXOP时间。所以上图中，才会起始用RTS/CTS保护。不过如果不用RTS/CTS，也可以在第一个数据帧时候做DATA_ACK的交换，本质上和RTS/CTS是相同的。

## 块会话（ADDBA）和块确认（Block_ACK，BA）

本节我们讨论Block_ACK机制，在TXOP Burst传输模式里面，可以用Block_ACK代替传统的Normal ACK模式，一次性回复多个帧的ACK，从而提升资源利用率。在802.11里面，Block_ACK是有连接形式的会话。如下图所示：

![img](https://pic4.zhimg.com/80/v2-dafe4640d2efb49f09090e954a4a28ef_720w.jpg)参考：802.11-2016，10.24 Block acknowledgment (block ack)

会话一共有三个过程：1）会话建立（Setup），2）数据传输（Data & Block ACK），3）会话关闭（Teardown），以下我们分别说明下：



由ADDBA Request和ADDBA Response帧的握手，发起一个会话。Block ACK对应的会话是单向的。需要注意的是，ADDBA Request和Response在协议中都是管理帧，具体是以Action帧的形式存在。管理帧是需要通过ACK确认的，而且每一个管理帧发送前都需要经过Backoff竞争信道。所以ADDBA的握手过程流程是ADDBA Request，ACK，然后ADDBA Response，ACK。Remark：其实ADDBA这个名字会很让人不适应，为什么不起一个类似于Inital开头的名字，这样可以见名识意。ADDBA的全称就是ADD Block Acknowledgment，中文笔者还没有想到一个很好的翻译，有时间再思考。

![img](https://pic3.zhimg.com/80/v2-b5b5054f6f691fadd2292e778c39a92e_720w.jpg)

我们这里可以抓包看一下这个ADDBA的握手过程。（这里抓包解析的参考[CWAP – 802.11 : Block Ack](https://link.zhihu.com/?target=https%3A//mrncciew.com/2014/11/01/cwap-802-11-block-ack/)，虽然我也抓过ADDBA的过程，但是上下报文比较多，没有这写的清晰）

![img](https://pic2.zhimg.com/80/v2-53fc40b37b668fa91e004d8469b17349_720w.jpg)

上图中，序号284就是ADDBA Request帧，具体如下：

![img](https://pic4.zhimg.com/80/v2-adb780ca3afb1bd221a62566fb7bb1e3_720w.jpg)

其中标识了该帧是一个Action类型的ADDBA帧。然后其包含的参数有：

- - Dialog token：该会话的ID号，应该是随机的。
  - A-MSDUs：代表该会话是否支持帧聚合。
  - Block Ack Policy：代表ACK反馈是立即反馈，还是延迟反馈。
  - Traffic Identifier：用来标识会话对应流量的TID。
  - Number of Buffers：代表帧缓存区的大小，用来做帧重组用的。
  - Block Ack Timeout：用来代表会话的超时设置，如果该位有设置时间，代表如果多少时间没有数据交换，则该会话失效。该参数Request和Response里面都有，以Response的为准。
  - Fragment：代表是否有分片，不过这个功能笔者没有很研究。
  - Staring Sequence Number：代表会话起始数据帧的序列号。

这里ADDBA还有一点要注意的是，ADDBA的request和response是连在一起出现的。中间没有参杂别的帧抢占信道。但是前面我们提到这两个帧都是Action帧，所以要不然是按照VO最高优先级反馈response（这点是猜测是类似于延迟ACK时候的BA反馈），或者就是在ADDBA Request中设置的Duration参数进行保护。从我目前的抓包记录而言，我估计是Duration保护机制生效的。

![img](https://pic4.zhimg.com/80/v2-cad17478789a71703fd257e76b6313f7_720w.jpg)

不过这个保护时间不一定准，这个保护时间是发送者根据自己的物理层速率进行评估的，但是接收者反馈的时候，物理层速率不一定会与发送者相同。如下图记录，是一个重传帧，这里的Duation参数就与物理层速率有关了。

![img](https://pic3.zhimg.com/80/v2-7fb120e5aa8a992fe460d7367420da66_720w.jpg)

而且上图我们还可以看到，ADDBA如果有重传，那么也是直接重传，没有BEB过程。猜测的能够实现的原因也应该可以前面的类似了。

然后是序号286的ADDBA Response，如下图

![img](https://pic3.zhimg.com/80/v2-83b11bc18ee50273dc0b12beb02c8822_720w.jpg)

该帧也是一个Action类型的帧，类型可以看出来是Add Block ACK Response，Status code说明这个会话被成功建立。然后就是具体的参数了Block Ack Parameters，其实这些参数是和ADDBA response是一样的。这里有一个参数我们第二个阶段要说明，即Block Ack Policy，Block_ACK的反馈是立即反馈还是延迟反馈。

以上就是ADDBA的一个握手过程，握手完成后就可以开始第二个阶段，数据传输。

- 2）**第二个阶段**是数据传输的部分，这一块需要结合我们之前说明的TXOP机制来理解。在传输阶段时，数据按照TXOP进行突发传输（802.11e），或者是按照帧聚合形式传输（802.11n以后），当数据传输结束后，需要进行Block_ACK（BA）反馈。

![img](https://pic2.zhimg.com/80/v2-0ddbbfdcd1b0b245969b3c61a1c0d8e9_720w.jpg)

此时Block_ACK反馈有两种机制，一种是立即ACK反馈，另外一种是延迟ACK反馈。

![img](https://pic3.zhimg.com/80/v2-f4c4f6169b63ee31c0e6fe07339b0c86_720w.jpg)

我们下面分别说明下两种Block_ACK反馈机制。

A. 立即Block_ACK反馈。

![img](https://pic2.zhimg.com/80/v2-e86fb3e7dfe5675f06b8d6506fc77c51_720w.jpg)

我们结合这两张图来看。前面已经解释过了Block_ACK的场景，在802.11e中，由于可以在TXOP时间内进行帧的突发传输。此时如果在该TXOP内部，把整个会话内的数据都传输完的话，那么在最后一个QoS Data传输后，会话发起的节点会发送BAR（Block ACK Request），此时节点会立刻反馈Block ACK（BA）。这里的BAR和BA帧都是作为控制帧存在的，所以其可以直接构成一个握手。也就是BAR之后，接收方会在SIFS时间后反馈BA。

在802.11n以后，协议中还有一种立即块回复的模式，叫做隐式的BAR（Implicit BAR）。也就是在发送方发送完最后一个QoS Data后，节点直接可以反馈BA，而不需要BAR的请求。如下图所示，不过这种隐式BAR是应用在帧聚合模式下的，我们本文关注于802.11e模式下的Block ACK机制，对于帧聚合模式下的，也即是HT模式下的Block ACK不加以展开。

![img](https://pic1.zhimg.com/80/v2-223c9d9bc89a06c7a726f7641ad4a86c_720w.jpg)

A. 延迟Block_ACK反馈。

![img](https://pic3.zhimg.com/80/v2-856be2f49ecb19d48e9eb30ceb63cb66_720w.jpg)

如上图所示，是一个延迟的BA反馈。如果在本TXOP时间内，发送者已经发送了BAR请求BA帧，但是接收者还没有重组或者校验好，那么其可以先回复一个ACK，代表其接收到了发送者请求的BAR。然后过了一段时间后，其会发送BA跟发送者确认，此时发送者也需要反馈ACK。从而以上实现了延迟Block Ack的反馈。需要注意的是，在延迟反馈的时候，BA会被按照最高优先级安排。

那么我们现在看下BAR和BA这两个帧：

![img](https://pic1.zhimg.com/80/v2-28c4535b74406b9a7b71fac456c25284_720w.jpg)

BAR是一个控制类型的帧，其内容不是很多，包含了BAR的ACK策略，这个需要注意下，BAR是可以反馈ACK确认的，也就是我们前面在延迟模式下，需要用ACK确认，也可以不用ACK确认的，这个就可以通过BAR Ack Policy控制，这里的ACK Policy指的是针对于BAR帧的，而不是ADDBA会话的。其他还有是不是有多个TID（Multi-TID），压缩Bitmap（这个是在802.11n里面Block ACK的改进），后面主要就是一个Starting Sequence Numebr，用以请求范围。

![img](https://pic3.zhimg.com/80/v2-2c050767aafecef9c92657e8ce27fdd2_720w.jpg)

对应的BA反馈中大部分控制信息和BAR相同，主要就是多了一个Block Ack Bitmap，这里是直接显示的解析结果，里面显示了有部分帧是没有收到的。关于BA/BAR具体的确认机制，由于后期其都兼容到了HT模式下的Block ACK机制，所以我们在HT模式，也就是802.11n的时候在进一步讨论。

- 3）**第三个阶段**就是Block ACK确认完成，此时可以关闭这个块确认会话了。

![img](https://pic2.zhimg.com/80/v2-234ed61d16041039df49e894795c5005_720w.jpg)

这个部分比较简单，就是ADDBA会话的起始者发送一个DELBA帧给接收者，然后反馈ACK即可。这个帧比较难抓，参考Aruba的Blog，找到一张别人抓的图

![img](https://pic1.zhimg.com/80/v2-6fc9b2325a8d99e07b88fea16387ef30_720w.jpg)

以上就是Block ACK的大致机制，不过Block ACK的内容实际上还有不少，主要关于其计分板bitmap策略，以及其和帧聚合的结合。这是因为在802.11e初次定义Block ACK之后，在802.11n里面进一步完善，我们目前通常用到的Block ACK机制都是基于802.11n时候定义的了。802.11n后来定义的我们叫做HT模式下的Block ACK机制，这是向前兼容的，我们后面在讨论802.11n的时候再补充。

我们本文主要整理了TXOP和Block ACK，下面文章再继续进一步整理EDCA和HCCA。

# 再谈802.11e的优先级（Admission Control）

## **序言**

本文按照顺序是应该讨论EDCA/HCCA的，但是在此之前，我们需要重新回顾下802.11e中的优先级部分。我们知道802.11协议实际上是一个纵深很长的协议，因为802.11既需要考虑到商业级WiFi的场景和需求，又需要考虑到低成本轻量级的终端。所以其设计的部分实际上有很多潜在内容，很不好让别人理解。

好比前面我们说了802.11e的优先级有默认的4种类型，但是实际上情况下，用户能不能根据自己需求自定义呢。这里就是本文讨论的Admission Control机制了，所以本文我们要说明下802.11e中几个非常容易混淆的概念，**TID**，**TC**，**TS**，**TSpec，TClas**。

## 再谈802.11的优先级

在我们前面的说明中，我们知道在802.11e中一共定义了4种流量种类。分别如下：

![img](https://pic1.zhimg.com/80/v2-2b4118e0cc7ccafd7744c38dcfac7ab4_720w.jpg)

上图说明，当流量MSDU到达802.11e定义的MAC层时，会根据其802.1D的tag标识被分别存放到4个不同的queue里，分别是AC_VO，AC_VI，AC_BE，AC_BK。这里对应关系我们在《[802.11协议精读21：802.11e的优先级](https://zhuanlan.zhihu.com/p/31408247)》一文中梳理过。

但是如果结合下图，估计很多人会比较晕，前面是4个优先级队列，然后下图变成了8个优先级队列了，笔者在这个点上也晕了很久。

![img](https://pic1.zhimg.com/80/v2-a83bf2a9ca1ec66d6a16e1b975d7ff08_720w.jpg)

这是802.1D（802.1p）和802.11的QoS对应关系，因为前者是8个优先级，后者是4个。所以在数据到达MAC层的时候，每2个优先级队列还需要汇总一下，这个时候的汇总是采用队列调度的方式，最后按照802.11e的物理层参数发送出去。802.1D和802.11e的优先级对应关系如下：

![img](https://pic4.zhimg.com/80/v2-34529b97bb74893f334e3a4b919a71fb_720w.jpg)

不过实际上还不止如此。要理解好这个问题，我们需要重新看一下QoS Control字段了。

## QoS Control

![img](https://pic2.zhimg.com/80/v2-44d1458db9e89773b7c56e8f7968a815_720w.jpg)

QoS control是802.11e中新增的一个MAC层的字段（Remark：802.11协议在演进的时候，MAC头部也会增加东西，如上图QoS Control是802.11e增加的，HT Control是802.11n增加的）。

QoS Control包含的内容如下：

![img](https://pic2.zhimg.com/80/v2-ddf6055919a3596b04f15fbb18338481_720w.jpg)

我们这里关于TID字段，**TID**字段的全称是**Traffic identifier**。我们可以注意到这个TID有4个Bit（即上图的B0-B3），所以一共可以表示16个类型。这里就要和我们前面发现的TC的问题关联起来了，这里TID一共可以表示16个，里面8个是对应TC，另外8个对应的是TS。

![img](https://pic2.zhimg.com/80/v2-7e54220bf3872b417e0f62d35065e7c9_720w.jpg)

- **TC（Traffic Category）**：这个是对应的默认的QoS类型，也就是前面我们说的0~7，这几个TC类型。
- **TS（Traffic Stream）**：这个是自定义的QoS类型，节点可以通过ADDTS过程和AP（WLC）协商，从而特定设置一些对应的QoS参数。

我们可以看到一些材料上，802.11e是可以进行流量准入控制的Admission Control，这个就是针对TS类型而言的，而TC是设置用于默认传输的，其会按照默认的传输参数进行竞争信道，并传输数据。

![img](https://pic4.zhimg.com/80/v2-7b68e9f4b8344d6f014332af72f42e23_720w.jpg)

可以具体看下抓包记录，里面有标识TID，这里默认的TID为0就是Best effort流量类型。放上图还有一个原因是看下优先级下面这一位：

![img](https://pic1.zhimg.com/80/v2-f7338ffd972a63977bb03841a599fca0_720w.jpg)

第B4位，这一位解析会复杂一点，与上下行有关。如果是下行的那么就是EOSP的标志位，EOSP为End Of Service Period。而如果是上行的话，这是一个标志位，如果是0，那么代表TXOP Duration Request，如果是1，那么代表Queue size 。

另外这给出几个抓包的结果，可以参考下有个直观的感觉。

![img](https://pic2.zhimg.com/80/v2-d2260a0592b9f4f221a58d7ac80e13a5_720w.jpg)

其实就是协议一共支持16个类型，其中8个是默认的TC（对应默认的4个优先级），这里对应8个主要是对应了EDCA/HCCA使用时的参数，另外还有8个是以TS的形式，这个是节点可以和AP协商配置的。下面我们讨论下TS的接入方式。

## Admission Control

我们以下图讨论一下Admission Control机制。

![img](https://pic3.zhimg.com/80/v2-6183c96e74b9f848ba096a22c33fe4be_720w.jpg)

Admission Control实际上是一个会话的建立过程。其实很类似于前面我们说的ADDBA会话建立过程，这里是一个ADDTS的会话建立过程：

![img](https://pic3.zhimg.com/80/v2-7136bead14f890dcaba468b0d873995a_720w.jpg)

实际上过程也很简单，而且类似于ADDBA的过程。STA首先发送一个ADDTS Request给AP，然后AP需要做AC（Admission Control），这个有的时候也被称呼为CAC（Call Admission Control），应该是与其主要与语音业务有关。AP接收到之后，会反馈给STA一个ADDTS Response。STA发送过去的ADDTS Request中的参数是具有协商意味的，所以最终的QoS参数是以AP反馈过来的ADDTS Response为主。这里的QoS参数就是TSpec了，另外在Status中会告知AP这个TS会话是否建立成功。由于这个会话是经过“AP”判决的，所以就叫做Admission Control机制。

通常情况下，Admission Control的开启与否是在WLC上面配置的，如下图Cisco的WLC上面可以配置开启。

![img](https://pic4.zhimg.com/80/v2-48340b4d23cc56af525fc5a2728ec283_720w.jpg)参考：https://www.cisco.com/c/en/us/td/docs/solutions/Enterprise/Mobility/vowlan/41dg/vowlan41dg-book/vowlan_ch2.html

我们可以看下Cisco教材那里给出的ADDTS的抓包记录（额，这个我自己没抓到过，所以就直接复制了），这里需要注意下，ADDTS Request和ADDTS Response都是两个Action帧。

![img](https://pic4.zhimg.com/80/v2-96e5546a806a8c8da4205ff894dda56f_720w.jpg)ADDTS Request - 参考：https://www.cisco.com/c/en/us/td/docs/solutions/Enterprise/Mobility/vowlan/41dg/vowlan41dg-book/vowlan_ch2.html

![img](https://pic1.zhimg.com/80/v2-bb9dba8df68551100cf459c5c54f9e40_720w.jpg)ADDTS Response - 参考：https://www.cisco.com/c/en/us/td/docs/solutions/Enterprise/Mobility/vowlan/41dg/vowlan41dg-book/vowlan_ch2.html

然后前面是建立会话的，和ADDBA类型，ADDTS也有一个结束会话的，DELTS帧。这个帧我们就不贴上了，其实我也没有找到抓包记录。

另外关于ADDTS帧的接入交换过程，包含ACK反馈，接入优先级之类的都和ADDBA一样的，可以参考前面的描述，这里不重复了。

以上我们仅仅描述了Admission Control框架，现在留下的问题就是，如果利用这个框架自定义一个TS，并对其做QoS了，所以下面我们要讨论TSpec和TClas两个参数。

## 配置TS类型（TSpec和TClas）

学过QoS的童鞋都知道，QoS简单起来就是两个部分，1）抓流量，专业点就是定义一个流量，2）给流量配置参数。所以针对这两个需求，我们就需要理解TClas（对应定义流量），TSpec（定义配置QoS参数）。*Remark：这个部分参考台湾一个廖冠雄老师的PPT，其实里面写的还比较清楚。*

TClas和TSpec都是Element字段，TClas如下：

![img](https://pic3.zhimg.com/80/v2-44b7356d2ffb7aff62d25f6a92372dc6_720w.jpg)

其中Classifier Parameters对应如下：

![img](https://pic4.zhimg.com/80/v2-5c681bea48e1fa1fddc83022f119a317_720w.jpg)

上面是什么意思呢，实际上是给出了一种定义数据包种类的格式。通常我们定义数据流，比如用ACL来抓流量，然后Class-map做匹配。不过这个是在无线环境下，STA需要用一种特殊的方式去定义有线对应的数据流量，所以就是这个TClas字段。TClas字段实际上简单的就是三个部分，Type，Mask和Parameters，其中我们关注下Parameters，由于我们定义的流量有可能是Ethernet类型的（比如Type 0），有可能是基于TCP/UDP数据包的（比如Type 1，其中包含了IPv4和IPv6两种，不过公用一个Classifier Type），还有可能是802.1Q的（Type 2，实际上就是基于VLAN Tag的）。通过以上这种结构来定义流量。

我们用下图的抓包结果可能清楚点：

![img](https://pic3.zhimg.com/80/v2-bf8da0f5d9353e664bb33b3e8e2f1ed2_720w.jpg)Ref：https://mrncciew.com/2013/03/19/tspec/

这个也是一个ADDTS Request的帧，但是因为wireshark解析的问题，其显示的类型是Management Notification（17）。这个里面的Traffic Classification字段就是对应的TClas部分。

这个定义流量的部分，还有一个部分就是配置QoS参数了，此时需要用到TSpec部分。TSpec如下图所示：

![img](https://pic3.zhimg.com/80/v2-224891b605bcb10571697df38468fcf6_720w.jpg)

TSpec实际上对应到图中的TS Info部分，这里参数比较多，可以看一下下面的解析：

![img](https://pic1.zhimg.com/80/v2-14e1a6558be6482ff0bb12ed023bc6e0_720w.jpg)

以上部分图中已经写的很清楚了，所以笔者就不进一步展开了。

当TSpec和TClas都以Element的形式，添加在ADDTS Response发给AP后，AP（或者转给WLC）会进行Admission Control判断。

如果现在网络中的资源是够的，那么就允许这个TS类型接入，如下图的抓包反馈：

![img](https://pic4.zhimg.com/80/v2-53191b784ae73aa234cfd063296114f3_720w.jpg)Ref：https://mrncciew.com/2013/03/19/tspec/

可以看到Status code是Admission accepted的。如果此时AP发现资源不够，那么会拒绝这个TS进行接入，那么这个TS的业务就会被按照默认的TC类型进行接入了。

![img](https://pic1.zhimg.com/80/v2-ce1bab5f63a828b73d9b9806d67b8104_720w.jpg)Ref：https://mrncciew.com/2013/03/19/tspec/

上图就是一个被拒绝的ADDTS Response反馈。

本文我们讨论802.11e中关于优先级定义的额外内容，以及对应的Admission Control机制。这个部分目前只有一些商业WLC+AP的架构可能才会用的上，而且需要一些专业的语音设备配合之类的。但是这个确实是802.11e中非常容易混淆的部分，重点是理清楚，TID，TC，TS，TSpec，TClas这几个概念以及Admission Control的机制。

# 802.11e（EDCA/HCCA）

## 序言

在说明完了TXOP机制和802.11e中的Admission Control机制后，我们本节说明下802.11e中针对MAC层的改良，即EDCA/HCCA。在初始的802.11协议中，有DCF和PCF两种工作模式。但是由于其不支持QoS，所以在802.11e中，支持QoS的DCF就变成了EDCA模式，支持QoS的PCF就变成了HCCA模式。两者最大的共同点就是都支持TXOP，所以在上一节中，我们阐述了TXOP机制。其实HCCA相对简单点，可以简单理解成PCF+TXOP，而EDCA会复杂一点，其除了支持TXOP外，还需要对竞争参数有一些修改。以下我们具体说明。

## EDCA（Enhanced Distributed Channel Access）

如果对DCF的机制有比较好的理解话，那么理解起来EDCA应该很容易。DCF的机制可以参考《[802.11协议精读2：DCF与CSMA/CA](https://zhuanlan.zhihu.com/p/20721272)》。

EDCA想对比DCF实际上就可以几个参数加以了控制，一个是竞争backoff前“等待”的IFS时间，另外一个是backoff时候选择随机数的CW大小。

标准的DCF中，每一个节点在竞争前都需要“等待”DIFS时间，DIFS实际上是包含了1个SIFS和2个Slot时间，其实每一个Slot都包含了1次检测信道的CCA时间，所以DIFS实际上是连续2次通过CCA确认信道是idle以后，才进行backoff。

**AIFS（arbitration interframe space）**：在EDCA中，为了提供优先级，所以这里等待几个Slot时间是可以配置的，这个就是EDCA里面的AIFSN（arbitration interframe space number）。如下图所示

![img](https://pic2.zhimg.com/80/v2-b8c603d33e8e440cc2eaa2102b6d8865_720w.jpg)

其实802.11里面的IFS时间基本都是同一个架构，从SIFS这个基本时间片开始，PIFS=SIFS+1*Slot，DIFS=SIFS+2*Slot，**AIFS=SIFS+n\*SIFS。**如果n越大，那么意味着每一次接入信道前需要等待更多的时间，从而优先级更低。

*Remark：IFS还有两个EIFS和RIFS结构有点不同，EIFS是error之后的时间，RIFS是进一步优化SIFS里面，减少天线切换时间。*

AIFS的计算公式按协议而言为：AIFS[AC] = AIFSN[AC] × aSlotTime + aSIFSTime。这里AIFSN[AC]其实就是我们前面说的n，这个n是与我的优先级设置有关的。

这里有一个细节还需要注意，在802.11e对应的优先级队列中，除了backoff开始前是AIFS以外，在发生传输错误时，其需要等待的“EIFS”时间也需要更新为AIFS相关的，即EIFS–DIFS+AIFS[AC]。

**CW（Contention Window）**：除了backoff前的AIFS时间以外，还有一个部分就是对应的竞争Contention Windows的选择范围了。传统的DCF中，CWmin=15，CWmax=1023，这个是所有的竞争节点都是相同设置的。但是在EDCA中，由于节点的优先级与CW值关联起来，所以针对不同的AC，其CWmin和CWmax设置会不同。

![img](https://pic2.zhimg.com/80/v2-90e5ca6cf6107ed6f9677db52a4dd30d_720w.jpg)参考：Cambridge 802.11n的书

上图可以看出来，当经过不同的AIFS后，每一个AC类型的节点，其采用的Backoff随机数范围也是不同的，这里Backoff的随机数范围是与AC有关的，比如AC_BK流，也就是背景流，其随机数范围比较大，接入延长会多一些，而AC_VO，也就是语音流，其随机数范围比较小，接入时延会短一些。在802.11e中是提供一种基于概率上的QoS保障，在长时间的情况下，可以发现高优先级是明显比低优先级有更高的传输效率的。

在802.11e中，有给出默认的EDCA模式下，节点所采用的竞争参数，如下图

![img](https://pic3.zhimg.com/80/v2-085856b3ffd4e833feab5098147fd66a_720w.jpg)

这里给的参数实际上和DD-WRT里面的默认参数是一样的，上图中aCWmin=15，具体CWmin的数值可以基于aCWmin计算。

*Remark：注意上图中的参数也与上下行有关。*

![img](https://pic1.zhimg.com/80/v2-014a03a23eb38da5b8eba502a17053a8_720w.jpg)

这里还有一个需要注意的就是重传限制了，在802.11中，默认的重传是7次，如果最后一次失败才进行丢包。而在802.11e中，这个也是一个可以控制的参数，默认情况下是和802.11相同的，但是实际情况下，这个是可以控制的。

**TXOP**：还有一个部分就是TXOP传输部分了，TXOP也是EDCA的一个重要部分。在EDCA中，当节点获得采用优先级参数进行竞争并获得信道后，其可以采用TXOP的形式进行传输。由于TXOP的部分我们前面已经讨论过了《[802.11协议精读26：802.11e（TXOP，Block_ACK）](https://zhuanlan.zhihu.com/p/31710770)》，所以这里就不展开了。TXOP也是有给定一个最大的默认大小的，节点在传输QoS Data内，也会在QoS Control部分的字段中携带关于TXOP时间的具体参数。

从原则上而言，AIFS[AC]和CW[AC]这两个是保障节点优先级的，TXOP一开始是作为优先级保障的机制，但是后来其主要是在协议中用来提升MAC层传输效率和兼容机制的。所以TXOP在其他的方面还有不少功能，包含我们在ax文章中所述的OFDMA接入过程，我们在有用到TXOP的时候再提及。

## HCCA（HCF Controlled Channel Access ）

HCCA是802.11e里面关于PCF的一个改进，相比于EDCA，HCCA会简单一点。HCCA中由于没有竞争部分，所以主要是和TXOP技术的结合。

在理解HCCA之前，需要对PCF有深入理解，虽然相对于PCF而言，HCCA很简单，但是PCF本身的内容还是比较复杂的，PCF可以参考前面写的《[802.11协议精读4：PCF工作模式](https://zhuanlan.zhihu.com/p/20750579)》。

![img](https://pic2.zhimg.com/80/v2-60af9be3dc2c801bf0a91b913afa1055_720w.jpg)

如上图所示，上面的是PCF，下面的是HCCA。大体上看两者都差不多，主要看来有两点区别：

- 区别1：在CFP时间内，PCF只允许通过CF-Poll轮询1个数据，HCCA允许通过QoS（+）CF-Poll开启一个TXOP时间进行传输。

在传统的PCF中，轮询节点是采用CF-Poll帧，该帧每一次只可以轮询一个数据。在HCCA中，发送的是QoS（+）CF-Poll的帧，该帧可以直接起始一个TXOP时间。是由AP发送的。这里AP是扮演者HC（Hybrid Coordinator）的角色，HC的功能实际上是用来调度CFP和CP时间的，CFP时间是无竞争，完全由AP调度的，而CP时间是基于竞争的。

- 区别2：PCF仅仅允许在CFP时间内发送CF-Poll，而HCCA允许在CFP和CP时间内都可以发送QoS（+）CF-Poll。

在HCCA中，调度规则会更加复杂一些，默认情况下是和PCF相同的，但是节点也可以通过TSpec来和AP协商一个更复杂的轮询机制。因为在传统的PCF轮询机制下，轮询周期至少是一个TBTT，这个时间很长，很多有QoS业务需求的节点是无法承受的。所以为了提供更短的轮询周期，在CP时间内，HCCA也可以发送QoS（+）CF-Poll进行轮询，用于减少延迟。

综上就是EDCA和HCCA的主要内容了，通常大家在初始接触802.11e的内容的时候，可能认为主要内容是EDCA和HCCA，其实不然。EDCA和HCCA的工作机制实际上是在802.11e中比较简单的，但是由于与CSMA/CA技术关联比较大，所以比较让人关注。更为复杂一点的部分主要集中在ADDBA和ADDTS两个会话上面。不过直至目前，802.11e的功能只有一些商业级别的路由才有比较好的支持。在我的映像里面，早年有看到过思科和苹果合作的FastLane是关联802.11e的。其实驱动部分都是支持802.11e，主要是业务的打标和ADDTS之类的定义流的业务是否支持了。随着802.11的发展，尤其是在802.11be中，低延迟是一个解决的目标，我们相信QoS的支持应该是越来越广泛了。

# 802.11e（Direct Link Protocol，DLS）

## 序言

802.11e的主体部分前面已经整理完了，主体实际上包含了优先级定义，竞争优化EDCA/HCCA，然后是传输优化TXOP，Block ACK，自定义流量的Admission Control，还有节能模式ASPD。以上主体部分前面整理如下：

- [802.11协议精读20：初探802.11e（WMM）](https://zhuanlan.zhihu.com/p/22993136)
- [802.11协议精读21：802.11e的优先级](https://zhuanlan.zhihu.com/p/31408247)
- [802.11协议精读26：802.11e（TXOP，Block_ACK）](https://zhuanlan.zhihu.com/p/31710770)
- [802.11协议精读27：再谈802.11e的优先级（Admission Control）](https://zhuanlan.zhihu.com/p/113836199)
- [802.11协议精读28：802.11e（EDCA/HCCA）](https://zhuanlan.zhihu.com/p/114160231)
- [802.11协议精读11：节能模式（APSD，PSMP，SMPS）](https://zhuanlan.zhihu.com/p/21927713)
- [802.11协议精读23：再论APSD节能模式](https://zhuanlan.zhihu.com/p/79686876)

在802.11e里面还有一个比较冷门的技术-DLS（Direct Link Protocol）技术。DLS技术是802.11中关于D2D的一种具体实现，而且如果对VPN技术比较熟悉的人可以发现，其实802.11的DLS和DMVPN的第三阶段差不多，本质上还是一个加密会话切换的问题。在802.11e中定义的DLS目前在协议总结中已经被802.11z定义的TDLS所取代，所以我们本文仅仅简单介绍下DLS，而不做扩展。

另外，我最后简单总结一下802.11e部分的内容，这篇搞定802.11e的部分就算结束了。

*Remark：我目前的整理是按照协议版本来的，而不是按照技术单个整理，比如说TXOP，我们仅仅整理的是802.11e中规定的TXOP机制，在802.11n中还有改进，比如引入了RD机制。由于协议目前纵深已经很长了，所以不采用单独技术整理，而采用了协议版本整理方式。*

## DLS（Direct Link Protocol）

在通信技术下面有一个典型的技术叫做终端直通（Device-to-Device，D2D）。由于蜂窝网是需要基站负责数据的中转的，但是有时会出现节点与节点间距离比较近，通信质量比较好，而节点与基站间都距离比较远，通信质量比较差的情况。所以此时，如果能让节点与节点间直接形成链路，那么就最好的了。那么解决这个问题的技术就是D2D技术。

在802.11中，由于本身就存在支持节点与节点间连接的Ad-hoc模式（IBSS模式），所以D2D技术需求并没有很大。所以直到802.11e才开始定义这样的场景。不过时至今日，不少基于802.11的directlink技术，倒是往这个场景上偏向。

![img](https://pic3.zhimg.com/80/v2-bca0fb16a5b0ffb536441154a03c8026_720w.jpg)

本文就简单介绍了DLS，由于DLS基本没有被商业实现过（实现过的是TDLS），所以我们就大致看下其传输过程了，下次整理TDLS的时候再具体讨论中间握手的数据包特性。

DLS的过程实际上还是一个握手过程，不过是两边都要和AP握手了。握手完成后建立连接，最后如果连接需要结束，也需要发送Teardown帧。DLS是按照Action结构定义的，如下对应的Action帧类型：

![img](https://pic3.zhimg.com/80/v2-11e026db8d79067eefb551d22731aa56_720w.jpg)

我们按照图上的4个过程大致描述下：

**1) QoS STA1发起DLS，其向QoS AP发送DLS Request帧。 DLS Request帧中包含了其所支持的物理层速率集合，物理层的支持能力，STA1的MAC地址和想要建立DLS链路的目的MAC地址（即STA2的MAC地址）。**

**2) 如果QoS STA2是和AP关联上的，并且AP和目标节点（STA2）是支持DLS的。则QoS AP会向QoS STA2发送DLS Request。**

Remark：如果AP或者目标节点不支持DLS，那么AP在接收到STA1的DLS request后，会直接反馈response，指示无法建立连接。（具体是在result code里面指示）

**3) 如果QoS STA2允许DLS连接， STA2会向AP发送DLS Response帧， Response中包含了其所支持的物理层速率集合，物理层的支持能力，以及STA1和STA2的MAC地址。如果QoS STA2不允许DLS连接，那么其反馈的DLS Response帧则指示拒绝连接。**

**4) 当QoS AP接收到QoS STA2的Response后，其会向QoS STA1转发DLS Response的帧。**

**5）当QoS STA1收到AP的反馈后，如果指示链路成功（result code中为success），DLS链路建立成功。STA 1可以和STA 2直接以DLS进行双向会话，这里对应的MAC地址会被放入DLS List存放。如果指示链路失败的话，那么DL无法建立。**

以上就是802.11e中关于DLS链路的内容。在802.11e协议中，我们并没有发现关于秘钥交换的内容，也就是安全特性。这一个部分在TDLS里面都有所改善，所以DLS整体结构还是很简单的，这里作为一个记录。

## 总结802.11e

如果说802.11的物理层模块是有一些考通信原理的功底的话，MAC层部分很多设计是考灵活性，这一点我都有点感觉是类似于学法律条文，标准协议的改进很多都是考虑怎么钻空子的思路了，很多地方是显示的很灵活的。802.11e是一个纯粹的MAC层改进。在之后的802.11协议中，针对纯MAC改进的还有802.11aa，802.11ae，但是从主体而言，MAC的改进已经是密切关联到物理层技术的改进了，比如说802.11n到802.11ax，都是由物理层技术改进而改进MAC的。

关于802.11e可以作为一个理解MAC的典型事例吧，尤其是特性具体是如何使用的。可以说在802.11ax以前，整个协议框架都还是顺着802.11e的框架来的。在协议原本上，可以把802.11-2012做一个分界线，2012版实际上是整理到了802.11n，另外就是kvr一些协议的引入，802.11s也引入了，不过还没变的特别复杂。还没有引入802.11ac/ad，到802.11-2016版本以后就开始有了802.11ad（DMG），协议框架着实开始复杂，下一次的整理版本中不可避免还会加入802.11ah/ax/ay，这样协议的复杂性会更加增加。所以我们目前理解到的802.11e部分，对于直到协议的802.11ac这一块，很多基本思想都是互通的。而在往后，还需要继续更多的协议的细节。

以上就差不多整理结束了802.11e部分，目前还有关于802.11a/b/g部分还有一些关于兼容性，以及协议区别的内容待整理，有时间搞定以后就是开始802.11n了。

# IEEE 802.11-1997

## 序言

本文倾向为个人笔记。IEEE 802.11的发展是从1990年左右就开始立项了，到1997年出了第一个802.11的版本。对于IEEE 802.11-1997而言，虽然是目前802.11协议的基石，不过协议中定义的很多物理层技术，我们现在早已不用了，比如或IR（红外收发）和FHSS模式，甚至DSSS/CCK模式都已经逐渐只停留在兼容状态使用了。不过虽然这些技术已经不怎么主流，但是我们还是有比较记录学习一下，所以本文笔者做一个笔记。

*Remark：本文偏向于自己的笔记，所以都是零散的内容组合。*

Ref：[Intelligent Transportation Systems](https://link.zhihu.com/?target=https%3A//www.sti-innsbruck.at/sites/default/files/courses/fileadmin/documents/its-ss10/06-its-WLAN.pdf)

## IEEE 802.11-1997

IEEE 802.11-1997是最初通过的802.11版本，这个版本目前看到的资料是1990年就开始起草，直到1997年才正式通过。

目前其实在802.11协议中，最早的物理层机制已经不用了，包含了FHSS模式和IR的淘汰，以及DSSS模式已经在802.11b中进行了扩展。不过为了完整了解802.11，本文我们就简单总结下802.11-1997版本的内容。目前在802.11协议中，这部分的内容还依旧存在。

![img](https://pic1.zhimg.com/80/v2-0ddff59c09cf59577e45632ac289e5f4_720w.jpg)

如上图所示，802.11-1997定义了802.11目前的结构框架，直到现在，该框架还一直被采用。802.11协议分为了PHY和MAC层。MAC层实际上就是MAC和LLC，802.11里面关于LLC的内容不多，主要部分是定义了MAC层的接入规则，在初始的802.11中定义了DCF和PCF两种接入模式。然后就是定义了物理层（PHY），这里物理层实际上包含了两个子层，分别是PLCP和PMD。PMD主要是物理层传输层面的技术，而PLCP实际上是管理了物理层的传输信息。

![img](https://pic3.zhimg.com/80/v2-f214923e8d556a0e2d23c8ff2da1ce72_720w.jpg)

802.11-1997最初定义了三种制式，分别是FHSS，DSSS还有一个就是IR。FHSS和DSSS都是工作在2.4G频段，然后IR是采用标准的红外线。可能红外传输现在接触的人不多了，在2G手机时代，手机和笔记本通信主要就是用红外传输的。

![img](https://pic2.zhimg.com/80/v2-f0ba8406111f2ebcf34d69737dc6c441_720w.jpg)

上图列举了FHSS模式和DSSS模式的差别，可以看到FHSS的调制方式是FSK，DSSS采用的是PSK，这个是与制式有关的。然后FHSS的信道带宽会更大，然后每一个跳频的子频带为1MHz。两者的物理层速率是相同的，不过FHSS要有更长的时间去做Slot和SIFS，两者Preamble结构是不同的，后面有给出。

**关于为什么最后FHSS会失败**：FHSS实际上是有一定优势的，其虽然占据了79MHz的带宽，但是其单个子带宽仅仅是1MHz，只不过是要在79MHz的连续带宽上变化。子带宽更小意味更低的采样率，**FHSS的硬件成本会更低**。但是**DSSS模式的稳定性会优于FHSS**，以及DSSS的覆盖面会更大，覆盖的面积会更广。所以最初的802.11协议中，最终是稳定性和覆盖性战胜了硬件成本。

![img](https://pic4.zhimg.com/80/v2-e9b412df1227933a7c4662cb7c9541ef_720w.jpg)

具体看一下FHSS的PMD层调制方式，FHSS采用的是GFSK的调制方式，可以采用2GFSK和4GFSK，其一个信道带宽为79MHz，其中每一个子带宽的大小为1MHz。FHSS的主要扩频方式是跳频，意思就是说节点会在不同的子带宽（子信道）上不断跳变，其中每一个子信道的停留时间为400ms，其子信道不是按照顺序进行跳变的，是按照一种伪随机序列，所以我们称之为跳频通信。那么前面也提到过了FHSS的样本频率（发送方我喜欢称样本，接收称采样）只需要1Msps就可以了，这与其子带宽大小一样，这样成本也会低一些。

![img](https://pic3.zhimg.com/80/v2-8e464f342f476382ef3037a5394132b6_720w.jpg)

FHSS的PLCP也就是整个PSDU的结构如上图，最初的802.11是定义了PLCP Preamble和PLCP Header，然后Preamble里面还分为SYNC和SFD。这个结构是典型的类似有线网络，SYNC是一个特殊的同步序列，用来做时频同步的。然后SFD是一个帧起始的分界线，是一个很特殊，不会随机出现的序列。只要接收方检测到SFD序列就知道现在是一个帧起始片段了。然后PLCP Header部分包含了PLW，PSF和CRC，在最初的802.11实际上已经存在了不同速率，所以需要在Header中PSF部分指示后面的数据速率，另外在PLW中显示PSDU的大小，用来在物理层截取整个PSDU的采样点。

![img](https://pic4.zhimg.com/80/v2-54ac95d8b2e9284339e76ac2879629cf_720w.jpg)

DSSS的调制方式是采用Barker，Barker码是一个特殊的序列，其具有非常好的自相关特性，如果有任何一位循环移位的话，相关结果都是-1，可以用来解决多径问题。DSSS模式定义了信道带宽为22MHz，信道间的间隔为5MHz。这里上图中写了一个Symbol rate为1Msps，这里的说法有点歧义，这里的一个Symbol rate指的是由一个Barker码构成一个symbol，1个symbol的组成实际上是chip，比如说barker码是11位，所以虽然Symbol rate是1Msps，但是Chip rate为11Msps。DSSS支持BPSK和QPSK的调制方式。

![img](https://pic2.zhimg.com/80/v2-2934466e8e290810e349a29bbad59c39_720w.jpg)

DSSS的物理层帧结构实际上一直沿用到了802.11b，其也是PCLP Preamble和PLCP Header，其实结构和FHSS也一样，这里就不重复了，我们在讨论802.11b的时候再说明一下。这里的length字段值得看一下，其实比较特殊，是标识的SDU的时间长度而不是length。

## DFIR（Diffused Infrared）

主流的红外通信协议当年是由IrDA定义的，IrDA有点类似于现在的Wi-Fi联盟，成员主要是工业界的公司。IrDA当时定义的红外通信面向的场景主要是点对点的数据传输，速率最高能到16Mbps。

不过IrDA没有定义好多点间通信的场景，所以802.11才有面向这个方向的版本，不过最终这个版本已经没有在用过了。

红外光能够被早期通信采用一个比较重要的原因就是其不直接受FCC管辖，因为红外光接近可见光，其照样也不好穿墙，所以不会对大范围的通信造成影响，这导致红外是一个相对使用自有的光波段。不过红外光的缺点在于容易受可见光的干扰，所以一般红外光的通信范围在1m左右。

红外当时设置的场景一共有三种，1）最简单的就是点对点，2）搞一个具有多个红外模块的“交换机”，每一个模块面向一个通信设备，这样可以做到多个节点间的数据交换，3）允许散射和反射的红外信号传输。但是无论哪一种，其都不免受到可见光的影响，所以红外渐渐是被淘汰掉了。就目前趋势而言，红外被蓝牙取代的概率比较高，蓝牙芯片的价格已经可以相当低了，对于占据红外最后一块市场（遥控器），目前可能是有希望的。

802.11中其实模型还是基于点对点的模型，因为其MAC层的DCF和PCF设置是通用的，也就是即使在红外下面，也要跑CSMA/CA。这点现在802.11bb的可见光版本中还会继续。

最初红外通信的物理层是采用了PPM的调制方式（Pulse Position Modulation, PPM），PPM是采用脉冲的位置来传递信息的，在802.11中，IR采用的是4-PPM实现2Mbps的传输速率。其中每一个Symbol是1us的时间，包含了4个250ns的slot。然后每一个symbol传递2个bit的信息，如下图所示，图中跳变记号1就是描述了其跳变的位置。

这里注意下协议中关于IR下slot的含义，协议原文是“The basic L-PPM TU is the slot.”，所以这是一个在802.11协议中非典型的slot定义，需要注意下。

![img](https://pic2.zhimg.com/80/v2-b560ef66ead839365d5cb92b2c848da9_720w.jpg)Ref：http://www.tsnien.idv.tw/Network_WebBook/chap15/15-2%20%E7%84%A1%E7%B7%9A%E7%B6%B2%E8%B7%AF%E4%B9%8B%E5%82%B3%E8%BC%B8%E6%8A%80%E8%A1%93.html

所以IR的4-PPM的传输速率计算为2 bit/ (4slot × 250ns) = 2 × 106 = 2 Mbps。另外802.11也支持16-PPM，不过这里就不列举了。

![img](https://pic1.zhimg.com/80/v2-5aa7ab7e176e63fb6dac670944832b28_720w.jpg)

IR模式的帧结构如上，没有什么太大的特殊性，其实和前面的FHSS和DSSS是很像的。然后图中的DR是data rate，DCLA是dc level adjustment。

关于红外为什么会失败，权威指南里面有写过

![img](https://pic4.zhimg.com/80/v2-9fde95db068dba7e7971ca81699eb937_720w.jpg)

贴一个翻译版的，这里我就不写了

![img](https://pic1.zhimg.com/80/v2-ab461874f55a001aeb657e9dd786a5fc_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-76d7f89efe650674e1b7f95b05b0673c_720w.jpg)

不过上述说的是没有芯片做IR的原型实现，不过我查过倒是有芯片的Datasheet是有支持IR的。

## 802.11-1997协议版本的实例化（商用IC）

我虽然没有查到有802.11-1997版本的产品单独出现（估计当时是商业项目的定制方案才用到802.11，所以没有零售产品），但是我们可以查到有典型的IC是支持当时所有的802.11制式的。

比如AMD Am79C930 PCnetTM-Mobile

![img](https://pic1.zhimg.com/80/v2-1fd8efbbef5790161f953ad41bad3bac_720w.jpg)

该芯片的物理层是支持所有的802.11制式的，我们可以看到该芯片实际上1995年就有了，当时802.11的初版还是draft的状态，所以这块网卡上实际上支持的名字还是WaveLAN，而不是Wi-Fi。当时除了AMD，Wi-Fi芯片还有一家非常经典的公司，Harris，不过现在这些公司很早就不继续做了。

![img](https://pic3.zhimg.com/80/v2-7f24fa46879823edcb53f7d87c09c76e_720w.jpg)

从他的datasheet上面我们可以得知该芯片如何和主机进行连接的，并且该芯片的radio或者IR的发送模块需要另外补充接入。

用这块芯片做成的网卡就是当时很有名气的“朗讯金卡”，那个时代的做Wi-Fi的厂家基本留到现在的没有几家了。当时为什么叫“金卡”实际上还与加密机制有关，“朗讯银卡”支持标准级别，使用64位WEP，“朗讯金卡”支持增强到128位，使用RC4加密。其他还有不少网卡是这个芯片的，比如说Leichu ALPHALAN-2000。

当时的产品长这个样子

![img](https://pic2.zhimg.com/80/v2-b565156eedd9fbd35c21ba6f4b81039d_720w.jpg)

802.11b-1999和802.11-1997时间差距不是很大，所以当时IC在做的时候，实际上是可以支持802.11b制式的，所以该网卡可以认为已经是一块802.11b的网卡了。不过关于IR和FHSS的部分，虽然芯片是支持，但是没有看到采用802.11做IR的这种商品出现过哈。

## 802.11协议考古

这里另外记录一个关于802.11协议从初始到802.11a/b-1999版本的文档库，基本是早期802.11制定时候的相关文档。当时的协议指定实际上有明显的学术风格，尤其是中后期的提案，写法基本上都是一篇一篇的paper。跟目前协议组讨论的PPT风有很多差异。

[IEEE 802.11 ARCHIVE DOCUMENTATION](https://link.zhihu.com/?target=http%3A//www.ieee802.org/11/Documents/DocumentArchives/)

在802.11协议中实际上定义的都是规则，规则是怎么来的，尤其是参数值的设置，很多时候是只能够考古获得答案的。这里仅仅作为个人笔记记录下。

# IEEE 802.11a/b

## 序言

802.11a/b是802.11协议的第二个阶段的版本，都是在1999年发布的，用现在Wi-Fi的新的命名方式来说的话，802.11b对应的是Wi-Fi 1，802.11a对应的是Wi-Fi 2。本文还是偏向于个人的技术笔记，主要是记录关于802.11a/b两个协议的内容。

Ref：[Intelligent Transportation Systems](https://link.zhihu.com/?target=https%3A//www.sti-innsbruck.at/sites/default/files/courses/fileadmin/documents/its-ss10/06-its-WLAN.pdf)

## 802.11b（HR，High Rate）

首先我们谈一谈802.11b。802.11的命名法一直是有些无章法的，比如说802.11b就是802.11-1997的正统后续版本，所以在后来定义的时候也被称为Wi-Fi 1。另外802.11b是有代号的，High Rate DSSS，用以和802.11-1997的DSSS模式做一个区分。

802.11-1997定义了三种不同的工作模式，即FHSS，DSSS，IR，其实802.11在1990年就起草了，在其发展过程中，实际上在95年左右开始，就有很多Wi-Fi产品了，不过当时不叫Wi-Fi，而是叫做WaveLAN。所以在经过了5年左右的市场选择后，802.11b最终选择是扩展了DSSS的模式，DSSS模式最后取得成功主要是因为其稳定性最好。

![img](https://pic4.zhimg.com/80/v2-142050770f675136e19aacd59144d61f_720w.jpg)

在前面一篇已经描述了802.11-1997的DSSS模式了，802.11b是这个模式的一个扩展，主要引入了CCK这种编码方式，chip rate还是11M，但是经过了CCK调制后其数据速率可以提升到5.5Mbps和11Mbps。

同时这里我们还需要知道一点，就是5.5Mbps和11Mbps并不是单纯只有CCK调制模式，我们通常说802.11b支持DSSS/CCK因为这是协议中固有的机制，协议中还定义了一种可选的调制模式，PBCC（Packet Binary Convolutional Code），不过PBCC最后没有商用化就是了。

![img](https://pic2.zhimg.com/80/v2-0e2a9dcce6092b773c4437630d80121d_720w.jpg)

另外在PLCP帧体的部分，我们可以关注下，802.11b和802.11-1997有两个地方的区别，1）802.11b引入了Short Preamble的结构，传统的802.11-1997只有Long Preamble（128bits的Sync），而802.11b除了Long Preamble以外还有Short Preamble。

还有一个是802.11b的PLCP Header的Service字段，在802.11-1997中，service字段全部是保留字段。

![img](https://pic2.zhimg.com/80/v2-a339b35186329ddf03268aa962286ead_720w.jpg)

在802.11b中，service字段已经被使用了三个位，这里Locked Clock bit翻译过来是锁定时钟，实际上表示的意思是frequency和symbol是不是来自于同一个振荡器的，Mod selection bit就是指示调制的时候是用CCK还是PBCC的，还有一个Length extension bit我们需要注意下。在DSSS/CCK模式的帧结构中，PLCP Header中的length字段标识的是数据包的时间（单位us），而不是bits，这个很特殊，而且时间敏感。在802.11b支持了11Mbps以后，由于大于了8Mbps的速率，所以原有的length字段表达的时间精度就不够了，所以要进行补位提升精度，这个length extension bit实际上就是这个功能。

![img](https://pic1.zhimg.com/80/v2-52bc153088a8e3e0ecd22591de363e14_720w.jpg)

802.11b世代中，由于没有采用Beamforming的定向技术，其都是全向覆盖的，所以我们能够给出的一般的覆盖范围示意。

## 802.11a和HyperLAN

802.11a的协议版本也是1999年出的，现在大家基本都是把802.11a采用OFDM，802.11b采用的DSSS/CCK作为一个基础知识记忆。但是如果详细考虑的话，可以发现802.11a并不是802.11-1997的一个正统的后续版本。感觉就是凭空冒出来的，无论是OFDM的调制方式，以及其帧结构，进而到同步方式等等，其实都没有太多802的影子。

在我的目前读协议的理解中，802.11-1997实际上是结合了802.3的技术框架和IS-95中采用的CDMA技术的结合，不过实际上802.11-1997参考CDMA的部分不多，主要是扩频的模式，参考最多是802.3，一个很典型的例子就是PLCP Preamble的SFD字段，很直观的感觉就是在802.3的帧结构扩展一下，在PLCP Preamble的部分增加了同步用的SYNC字段，然后为了变速率引入了PLCP Header，剩余字段的构架实际上和802.3是一样的。

所以802.11-1997的溯源应该是802.3框架，但是802.11a就是另起一路了。这个问题实际上我考虑了很久，目前觉得802.11a的溯源应该就是HyperLAN。HyperLAN是早于802.11协议的，而且也是同时期802.11的最主要竞争对手，其是比较早采用OFDM传输技术的商业协议了。不过该协议最后没有成功，主要其是参考移动通信框架构架的。

移动通信框架有两个主要特点，1）有明显的AP和节点的区分，也就是协议构造的时候，AP的角色是抽离出来的，从协议层面，AP就具有更强的控制平面，而节点脱离了AP就不好工作，需要听从AP的指挥，2）面向连接的网络，移动通信协议基本上都是面向连接的，需要完成一个rach过程和AP连接上，然后在根据这个连接状态分配资源。

而802.11a实际上就是基于802.11的特点，改变了一下HyperLAN。首先从物理层的发送机而言，或者用802.11的概念，其PMD子层实际上和HyperLAN是非常一样的，除了一些编码速率上有差异，其他结构基本差不多。但是PLCP子层变化就比较多了。我们先对应上面两个特点对比下：1）802.11没有AP和节点的区分，在802.11的概念里面大家都是节点。竞争信道是公平的，采用同一种机制来竞争。这也是因为802.11的前身WaveLAN一开始设计目标就是Ad-hoc的一类场景，在Ad-hoc场景下面就是没有AP这样的角色的。没有角色划分实际上意味着简单，简单就意味着802.11是一种best-effort的协议，AP和STA可以采用同一个芯片去构架，只不过后期管理层面加点程序就行了。同时这样做还有一点就是轻量，其实单纯的按照802.11的DCF接入模式而言，整个协议还是挺轻量的，不需要跑太复杂的控制层面，所以对于配套的MCU要求很低，应用面广，从这个层面而言，也可以说是DCF最后成功，PCF失败的一个原因。2）802.11的接入流程不是面向连接的，是best-effort的，也就是每一个数据包尽量发，而且大家采用同一种机制来竞争，不搞太复杂的调度。虽然802.11中有关联过程，但是这种关联仅仅是分配AID，然后认证的时候分配下秘钥，其他关于无线接入的过程，不会进行控制。

所以802.11a实际上的来源是HyperLAN，而且是一种符合802.11精神的hyperLAN设计，不过802.11a也是没有成功，一方面是5GHz的信道原因，另外一方面是还是协议比802.11b要复杂，所以市场一开始没有接受。这种机制直到802.11g世代以后，才重新变为了主流。

另外为什么不一开始就把802.11a定义到2.4GHz上呢？这里可能协议组本身是想的，不过法规没有过，而且也是前面说的，802.11a的对比对象就是HyperLAN，而HyperLAN就是工作在5GHz频段上的。

## 802.11a

我们下面记录一下802.11a的协议特点：

![img](https://pic2.zhimg.com/80/v2-645d92943959c979830122c2fa138b41_720w.jpg)

802.11a是采用OFDM模式来进行调制的，在OFDM中，每一个信道包含很多个子载波，每一个子载波上可以进行调制，比如QPSK，QAM。在时域上，OFDM的传输是由OFDM Symbol构成的，为了避免Symbol与Symbol间的码间串扰（ISI），通常需要加入保护间隔。在802.11a中，保护间隔是填充了CP循环前缀，这是因为如果留空会导致ICI。另外在子载波中，还有部分子载波被用作了Pilot，这里是导频子载波的意思。OFDM具有高的频谱效率，而且可以很好的抵抗窄带干扰以及减少多径效应的影响（因为码率低）。

![img](https://pic2.zhimg.com/80/v2-d16e964389eeb0140d838c6c06c832c9_720w.jpg)

在802.11a中，每一个子载波带宽为312.5KHz，symbol时间是4us，所以symbol rate是250ksps，其最大的传输速率为54Mbps。这里有很多内容在《[802.11协议精读7：802.11a/g的发送过程与接收过程](https://zhuanlan.zhihu.com/p/21485216)》，《[802.11协议精读8：再论802.11a/g的发送过程与接收过程](https://zhuanlan.zhihu.com/p/21496609)》里面提到过了，就不展开了。

![img](https://pic4.zhimg.com/80/v2-7226a8092d3cb8fe90d257412e6f7a8f_720w.jpg)

然后上图是802.11a的一个帧结构，其PLCP部分只有一个PLCP Preamble，里面包含了STF，LTF，SIG字段，上图中由于是比较早期的描述方式，所以Preamble里面只包含了STF和LTF，然后SIGNAL是分开的，不过目前的802.11a是把SIGNAL也放在Preamble里面。

![img](https://pic2.zhimg.com/80/v2-c180f8e278a25fc8c26d0fa4cded4c59_720w.jpg)

我们可以定量观察下802.11a的覆盖范围，上图中是802.11b和802.11a覆盖范围和传输速率的对比，图中802.11a的传输范围尽量取小，图上最大的范围可能有点大了。

## 802.11a/b的产品

在802.11a/b世代已经有不少产品了，产品也逐渐迈入民用场景了，这里我们列举一些当时世代的产品。

![img](https://pic1.zhimg.com/80/v2-3d076c424a768eb0cd31cd7265af00bc_720w.jpg)Aironet PCI352, CB20A, or PCM 352 Client Adapter Network Interface Card

![img](https://pic1.zhimg.com/80/v2-b5e05b9b66404d45021372bf0444b150_720w.jpg)Cisco Aironet 1100/1200，WRT11

![img](https://pic4.zhimg.com/80/v2-17b6ee828bce20462f57fe089aaffea3_720w.jpg)WGB350/1400 Series Bridge

综上，我们整理了802.11a/b内容，以上还是作为个人笔记多一些。

# IEEE 802.11g

## 序言

802.11g是一个非常经典的802.11版本了，我们大部分人接触Wi-Fi网络其实都是从802.11g的世代开始的。不过802.11g的世代其实协议还是挺繁杂的，本文笔者就是做一个个人笔记。记录经典的Wi-Fi协议版本实际上就是为了更好的读懂协议，毕竟现在802.11协议的内容量确实很大，而且很多都是历史问题了。

另外值得一提的是，802.11g有时候我也喜欢称之为802.11-2003版本。在802.11的发展历史中，初代是802.11-1997，然后后来有其了一个任务组TGm，TGm是用来整理协议总章的，每一个协议制定完后，隔一段时间会被并入总章， 之后协议的单行本就失效了。第一个总章实际上是TGma，a代表第一个，对应的是802.11-2007版本，然后是TGmb，对应的是802.11-2012版本，然后最新的是TGmc，对应的是802.11-2016版本。802.11g的协议实际上是单行版，但是其却是有总章的体量和框架，导致802.11g的制式是整个802.11协议里面最多的一个了。

## 802.11g的发展历程

这个部分参考TI的一份早期文档《[IEEE 802.11g - New Draft Standard Clarifies Future of Wireless LAN](https://link.zhihu.com/?target=http%3A//www.sss-mag.com/pdf/802_11g_whitepaper.pdf)》。802.11g是802.11a/b的一个正统续作。

在802.11g的设计中，不是一开始就往着OFDM方向发展的，当时一共有两份提案，一份是TI的PBCC-22，含义就是基于PBCC的22Mbps速率，还有一份是Intersil公司（这个公司实际上是当时并购了Harris的半导体部门，前面说过Harris在早期无线网络发展的时候，非常壮大的公司）提出的CCK-OFDM技术，其实802.11b中的CCK就是Harris和朗讯搞的，而PBCC是TI那个阵营的。然后在投票缓解中，虽然有过半数的公司认同CCK-OFDM的方案，但是协议通过是需要75%的赞成比例，几经商榷之后，最后采取的是一个折中的方案，就是PBCC和CCK-OFDM都会被纳入到802.11g的协议版本中，最后才以76.3的比例通过协议。

其实这个故事到802.11n的世代里面继续上演，还是会分阵营的。等什么时候整理802.11n的时候再整理。

## 802.11g的协议框架

其实802.11g世代中，MAC层部分其实没有什么改进，主要都是物理层技术的发展。而且参与协议指定的公司都可以发现是一些半导体IC公司，网络设备公司其实参与度倒还没有那么高。所以MAC和更上层的业务部分并没有太多的变化。

802.11g在协议里面的代号为**ERP（Extended Rate PHY）**，扩展物理层速率。

802.11g支持4种物理层制式，分别是**ERP-DSSS/CCK**，**ERP-OFDM**，**ERP-DSSS-OFDM（图上为CCK-OFDM）**，**ERP-PBCC**。如下图所示

![img](https://pic2.zhimg.com/80/v2-940387d89504deb25875499868a7a029_720w.jpg)

这里协议默认的是CCK和OFDM两种制式，还有两个扩展的CCK/OFDM和PBCC调制版本（这两个在协议中是可选的）。

我们可以先直观的看一下不同协议版本间的速率差异：

![img](https://pic3.zhimg.com/80/v2-babd7b2618126b45935a8f49e4268546_720w.jpg)

上图中，我们可以看到802.11g的兼容范围确实很大，其即包含了802.11b的支持速率，也支持了802.11a的支持速率，在此基础上，还增加了PBCC的22Mbps速率和PBCC的33Mbps速率。

我们之前在协议起源中提到过，802.11g相比于802.11a大部分内容是照搬的，这个是从最后商业市场的应用而言的，从协议的角度而言，802.11g还是有不少内容增加的。

## 802.11g-Beacon中的ERP元素

从802.11g开始，由于是一种新的物理层协议，所以需要在Beacon中添加ERP元素。

![img](https://pic1.zhimg.com/80/v2-73003558822df3d136447096ceb6b1d0_720w.jpg)

其中主要是三个Bits，Non-ERP Present，Use Protection，Barker Preamble。前面两个是与保护模式有关的，我们谈兼容的时候再说。还有一个Barker Preamble，这个命名虽然是Barker Preamble，但是讨论的问题是Short Preamble还是Long Preamble，如果设置1，那么代表全网可以采用Short Preamble，从而提升一点效率。

## 802.11g的帧结构

我们前面说了802.11g有4种制式，分别是**ERP-DSSS/CCK**，**ERP-OFDM**，**ERP-DSSS-OFDM**，**ERP-PBCC**。以下分别列举一下（图来源于权威指南，比协议的图清晰点）

**ERP-DSSS/CCK，ERP-PBCC**

![img](https://pic4.zhimg.com/80/v2-6da7a03cb6f2f313f36ff41e100d98eb_720w.jpg)

这个帧结构是继承了802.11b的帧结构，基本上内容都是和802.11b一样的，可以直接做到和802.11b的STA兼容。所以从这个层面而言，802.11g算是重新定义了一次802.11b的帧结构，并包含在其协议内容中。所以我们目前用的最低速率实际上的可以算是“802.11g”的，不过名义上还是属于802.11b定义的。另外，Length字段这里表示的还是时间，单位us。

ERP-DSSS/CCK和ERP-PBCC的帧结构是相同的，只是编码方式不同，这点两个标识在service字段里面的modulation标识。

另外，802.11g的service字段和802.11b还有点小区别，

![img](https://pic2.zhimg.com/80/v2-bd4dd1d058e4984ece7528fd7c68d87d_720w.jpg)

主体部分和802.11b的service字段相同，但是由于协议进一步提升了直扩模式下的传输速率，PBCC-22Mbps和PBCC-33Mbps，那么length字段的精度会进一步需要提高。所以在service字段里面增加了两位，一共三位用来提升length字段的精度。

**ERP-OFDM**

ERP-OFDM实际上来源与802.11a的帧结构，基本上是一样的。

![img](https://pic2.zhimg.com/80/v2-5667f6b7727b2170d0064a653371d2d5_720w.jpg)

然后上图有一个地方标识错了，最上面的Logical PDU的部分描述的是从Signal信号开始的。另外需要注意的是，在802.11g-OFDM世代，其STF和LTF合并称为Preamble，这也是Preamble的原意，然后Signal字段实际上对应的是PLCP Header，代表了物理层相关的解调信息。从802.11n开始，STF，LTF，Signal三个部分合并组成了Preamble，这个是一个定义的问题了。

**ERP-DSSS-OFDM**

按照协议而言，这种工作模式被命名为DSSS-OFDM，也有时候可以直接称为CCK-OFDM。

![img](https://pic2.zhimg.com/80/v2-41a47f7a35763de8a3f5f71561e1ee25_720w.jpg)

这个格式比较特殊，是为了DSSS模式和OFDM模式兼容而设计的。由于802.11g工作在2.4GHz的信道上，这个信道原来只有802.11b的节点，所以向前兼容只需要兼容802.11b就可以了（这里802.11b是和802.11-1997基本是一样的，所以兼容802.11b即可）。

那么为了兼容，在一个ERP-DSSS-OFDM的帧头部，最先要加上802.11b的帧头部，那么包含了PLCP Preamble和PLCP Header，这里的意义实际上是和802.11b的帧一样的。这个扩展的802.11b的头部实际上是给同BSS内，802.11b的节点看的，这些节点看到后就可以主动回避，那么回避时间是记录在PLCP Header中的Length字段，注意这里还是us，同时由于后面的传输速率最高能到54Mbps，所以service里面的扩展字段还是需要用上。

然后针对于兼容802.11b的PLCP Preamble和PLCP Header传输后，那么是802.11a的LTF字段。这里直接是LTF了，因为STF的基本功能，比如帧同步，粗频率同步之类的，可以通过PLCP Preamble来完成，所以就不需要重复做了。然后需要重新传输一遍物理层信息，即Signal字段，这里面也有MCS和Length，注意这里的Length是给802.11g-OFDM的节点看的，所以单位为bits。

**另外需要补充的是Signal Extension字段**：这里需要注意在ERP-OFDM和ERP-DSSS-OFDM这个部分，PPDU的结构最后还有一个Signal Extension字段，这个字段也是为了OFDM和DSSS兼容性设计的，属于比较细节的内容了，我们在讨论802.11b/g兼容的时候再说。

## 802.11g的CCA机制

802.11g只支持能量检测，如果信号的能量大于-76dBm，则会检测到信道Busy。其实这点的定义应该是为了当时那个世代好实现吧，因为只做能量检测的话比较简单，而如果在能量检测上做载波检测的话，那么在802.11g世代中需要检测Short Preamble，Long Preamble和STF三种可能性，所以当时为了简化，只定义了能量检测。那么不同Slot时间其对应的参数如下：

![img](https://pic2.zhimg.com/80/v2-7c9e1b51f3571326d3d86589a34c3dfd_720w.jpg)

这里补充记录下，关于RxTxTurnaroundTime的时间，因为笔者的一些设计类的paper需要考虑到该时间

![img](https://pic2.zhimg.com/80/v2-d1f9971263677fc4bdc4d4749d8c2d15_720w.jpg)

其实可以发现在半双工的收发切换里面，单纯的天线Switch切换时间是很短的，图中显示<<1us，但是收到发的切换大约为5us，发到收的切换大约为10us，这里的参数是802.11g世代的，每一个世代可能还会有点不同。这里说明了收发切换需要考虑的时间不仅仅是天线的切换时间，应该还包含了RF和基带的切换时间，所以总体时间才“较长”的。

另外，虽然802.11g只采用了能量检测。但是802.11g这个兼容问题一直到现在（2020）还是存在的，所以当下的话应该是能量检测载波检测同时都做的，当时是为了避免复杂，但是后来从802.11n开始，为了协议的稳定性，还是都要做一遍的。

## 802.11g的Slot和SIFS

最后还有一个Slot时间的兼容问题和SIFS，这两者都是影响到DCF的工作机制的，所以我们需要理清楚。

![img](https://pic2.zhimg.com/80/v2-6f3f18cfc5950473d1762532067653b5_720w.jpg)

如上图所示，这里直接截的协议的图，在802.11b/g共存的场景中，Slot时间用长的，即20us，只有802.11g-only（当时叫做Pure-g）的场景下，才用9us的Solt时间。

另外两者的SIFS时间都是一样的，都是10us。

## 802.11g的ACK

802.11g的ACK根据前面的数据帧类型来，如下图：

![img](https://pic4.zhimg.com/80/v2-35c55eef8bf8aa123bb3f342068e5797_720w.jpg)

如果前面的数据是采用CCK/Barker的话，那么ACK也采用CCK/Barker，其实默认是Barker的，这里PBCC也是这种模式。如果数据体是OFDM的，包含ERP-OFDM和ERP-DSSS-OFDM，那么ACK的反馈都是OFDM形式。

# 细考802.11b/g的兼容机制

## 序言

前面几篇文章已经分别列举了802.11b技术和802.11g技术，作为2.4GHz信道上相继发展的两个技术，其物理层是采用了不同的机制，一个是DSSS/CCK，一个是OFDM。为了保证其在2.4GHz信道上的稳定工作，就需要做兼容的处理。802.11g需要向前兼容802.11b。本文就对该两种机制如何兼容做一个详细的记录。802.11b/g兼容实际上是整个802.11兼容机制里面最复杂的，相比后来的802.11n往前兼容802.11g，802.11ac兼容802.11a，802.11ax兼容802.11n和802.11ac之类，其实都是物理层头部增加一个Preamble的问题，而802.11b/g兼容则是多个方面需要考虑到。

## 802.11g工作模式

在单AP场景下，802.11g一共有三种工作模式：

![img](https://pic2.zhimg.com/80/v2-f1289f068ad7794ea0f8f1091de75521_720w.jpg)Ref: http://www.icg.isy.liu.se/courses/tsin01/material/802.11g-WP104-R.pdf

- 1）802.11g-only，也就是AP和节点都是802.11g的工作模式，这个时候跑ERP-OFDM就可以了。
- 2）Mixed Client，AP是802.11g的，然后节点是802.11b和802.11g都有的，这个时候实际上要跑兼容模式。*Remark：这里一个细节需要注意，按照目前的习惯应该是AP支持802.11b/g才可以跑兼容的，但是在802.11g的资料里面，跑兼容的时候仅仅支持802.11g即可。这个就是前面说的802.11g重新定义了ERP-DSSS/CCK的工作模式。这个属于一种理念了，对应到IC产品上，就是IC产品只要做了802.11g的设计即可，不需要再做一个802.11b了。*
- 3）802.11b AP，802.11g Client：这个模式也很特殊，按照现在的802.11设计里面是不存在的，但是在802.11g世代还是存在过。为什么说现在不存在呢，因为按照现在协议设计理念的话，节点是802.11b/g兼容的，所以在该场景下，就都使用802.11b的传输模式即可。而由于802.11g重新定义了一遍802.11b的内容，即DSSS/CCK，所以直接可以用802.11g的节点向前兼容AP。

综上是802.11g在单AP下的三种工作模式，我们主要关心的是第二种，就混合模式下的兼容机制。

## ERP-Element的兼容位

![img](https://pic1.zhimg.com/80/v2-73003558822df3d136447096ceb6b1d0_720w.jpg)

Beacon里面实际上三个字段都是与兼容机制有关的。前面两个Non-ERP present和Use protection是802.11b/g兼容的问题，还有一个Barker preamble实际上是802.11-1997和802.11b的兼容问题，其实在802.11b里面没有直接解决。

**Non-ERP Present**和**User Protection**：在该场景下，如果该BSS内是存在了802.11b的节点的话（即Non-ERP），那么Non-ERP Present将会被置位，同时也要开启User Protection的。按照协议的原文是“If one or more NonERP STAs are associated in the BSS, the Use_Protection bit shall be set to 1 in transmitted ERP Information elements.”。

这里需要关注到AP设置Non-ERP Present其实都是通过管理帧触发的，AP不会通过去识别物理层到底有没有节点用802.11b的传输模式，只会通过关联/解关联的过程去判断。虽然看起来比较局限，但这个是802.11的构架造成的设计问题。我们知道PMD子层负责具体的物理层发送和接收，当然PLCP Preable这些物理层的识别也在PMD子层。不过PMD子层的功能都是在芯片段完成的，当时这些信息还没有通过RadioTap可以反馈给上层，都是通过MAC层的内部变量传输上去的，即RxVector。而管理层的内容实际上都是跑在内核上，两个部分的信息沟通实际上比较孤立。所以管理层触发一些信息就需要管理帧，因此只有当802.11b的节点去关联802.11g的AP的时候，才会触发Non-ERP Present的位，接着触发User Protection的位。

这里前面说明，只有管理层的信息才会触发Non-ERP Present，不过除了关联/解关联的帧以外，如果该BSS的AP接收到另外BSS的AP的Beacon帧，识别到Non-ERP Present置位的话，这里也会被置位。与此类似的还有几个情况，但是都是管理帧触发的。

还有一点就是Non-ERP Present和User Protection不是同时置位的，为什么要用两个位设计这点上可能是存在一些问题。我估计原始协议设计的理念是，Non-ERP Present关心的是BSS内关联的节点有没有802.11b的，然后User Protection关心的是本覆盖范围内，有没有802.11b的节点。因为有的节点在本覆盖范围内，但是没有关联到我的BSS。这样思考更合理一些。但是目前理解的802.11g的执行不是这样，这里触发机制是先触发Non-ERP Present才会触发User Protection，会有一个滞后反应时间，当然在解除User Protection的时候也会这样，这点在抓包记录中可以看到过。

这里我的考证实际上和802.11权威指南里面有一句话有点不同，这里记录下：

![img](https://pic4.zhimg.com/80/v2-6628cdc394613e50a93d9dbefb6429ef_720w.png)

这里实际上是把非ERP关联到AP和非ERP在该BSS内传输（as well as我理解是并列），两件事情并列列举了，但是AP到底会不会在物理层上识别非ERP节点，然后触发Non-ERP Present，这点我目前对802.11g版本协议是没有看到这样说明的。

**Barker Preamble**：另外说明一下barker Preamble的问题（对应前面说的802.11-1997 DSSS和802.11b的兼容问题）

![img](https://pic1.zhimg.com/80/v2-d449e634b7b4f3ce3436a63406c0f6e0_720w.jpg)802.11-1997 DSSS

![img](https://pic3.zhimg.com/80/v2-34cb960fbc95f27578d57a4d76ed7dda_720w.jpg)802.11b HR DSSS/CCK

对比一下我们可以清楚的发现802.11b增加了一个Short Preamble的构造，并将原来的模式命名为Long Preamble。这个在802.11b的世代里面是做为可以可选的配置项，让人手工可以调的。但是在一个BSS内部，这个最好是同步，否则的话就会有兼容问题，比如说有的节点如果只用Long匹配，那么short的就接收不到，会误认为信道是空的。

这点解决实际上思路很简单，让AP把信息公开一下即可，如果网络内全部都是short那么就用short，否则的话要用long。但是在802.11b里面，实际上都是更新的物理层技术，关于Information Element这个部分没有添加，也就是我们找不到HR Information Element。所以直到ERP Information Element的Barker Preamble位才解决这个问题。

## RTS/CTS和CTS-To-Self兼容

**1）**首先先看一下**RTS/CTS**模式，如下图

![img](https://pic2.zhimg.com/80/v2-807c3a0abbb756a0859210ac2eb68779_720w.jpg)

RTS/CTS帧从802.11-1997就有定义了，一开始是用来解决隐藏终端问题的，这里是用来做兼容模式的。如果附近有802.11b节点的话，802.11g节点发送首先要发送一个RTS，该RTS是采用CCK/DSSS模式，从而802.11b的节点可以接收RTS帧，从而设置NAV。然后这里802.11b的节点接收到RTS后，会采用CCK/DSSS模式反馈CTS。从而设置了一段保护时间。在该保护时间内，802.11g的节点就可以采用OFDM形式进行传输，而且不会影响802.11b的节点进行DCF过程了。*Remark：这里反馈CTS的是802.11b的节点，因为协议是兼容ad-hoc模式的，如果是AP的话，工作机理一样。*

**2）**然后我们看一下**CTS-To-Self**，这里需要注意的是**CTS-To-Self这个概念是在802.11g里面首次被引入的，**就是为了做兼容模式，在802.11-1997版本中是没有这个概念。不过CTS-To-Self还是属于CTS帧（只是目的地址RA写的是自己），没有CTS-To-Self该帧类型。

![img](https://pic3.zhimg.com/80/v2-f2c63a6003b387ffbd4f359b7b30b1c6_720w.jpg)

实际上和RTS/CTS模式很类似，只不过802.11g的节点直接发送CCK/DSSS模式的CTS帧，这个CTS的地址写的就是自己，所以就是CTS-To-Self帧。该CTS帧802.11b可以收到，并被设置为NAV状态，这样802.11g的节点就可以采取OFDM形式发送了，发送完接收ACK即可。注意ACK的传输机制和数据体相同，比如这里ACK和Data都是OFDM传输的。

## ERP-DSSS-OFDM结构

在前面一篇我们已经写过了，在802.11g里面还存在一种ERP-DSSS-OFDM的帧结构，这是要一个可选的结构，这个结构被设计就是用来兼容802.11b的节点的。

![img](https://pic2.zhimg.com/80/v2-41a47f7a35763de8a3f5f71561e1ee25_720w.jpg)

按照前面的逻辑，一开始是RTS/CTS，然后就简化到CTS-To-Self，那么再一步简化就是把CTS-To-Self的机理放到了数据帧的前面，这样的机制就是ERP-DSSS-OFDM了。具体格式的解释就直接照抄前一篇的了。

在一个ERP-DSSS-OFDM的帧头部，最先要加上802.11b的帧头部，那么包含了PLCP Preamble和PLCP Header，这里的意义实际上是和802.11b的帧一样的。这个扩展的802.11b的头部实际上是给同BSS内，802.11b的节点看的，这些节点看到后就可以主动回避，那么回避时间是记录在PLCP Header中的Length字段，注意这里还是us，同时由于后面的传输速率最高能到54Mbps，所以service里面的扩展字段还是需要用上。

然后针对于兼容802.11b的PLCP Preamble和PLCP Header传输后，那么是802.11a的LTF字段。这里直接是LTF了，因为STF的基本功能，比如帧同步，粗频率同步之类的，可以通过PLCP Preamble来完成，所以就不需要重复做了。然后需要重新传输一遍物理层信息，即Signal字段，这里面也有MCS和Length，注意这里的Length是给802.11g-OFDM的节点看的，所以单位为bits。

## Signal Extension（SIFS同步）

另外，由于OFDM和DSSS的制式不同，所以为了时间上的同步，还需要引入一个额外的片段，即Signal Extension。如果不同步的话，那么对DCF的机制造成影响，从而造成碰撞。比如RTS/CTS之类的ERP兼容机制时间上是基于时隙同步的基础上，如果时隙不同步，那么就无法真正做到兼容。

Signal Extension是用来解决SIFS的同步问题的，在802.11a的协议中，SIFS的时间是16us，而802.11g中，SIFS的时间是固定的10us，两者相差了6us。但是我们知道802.11g的OFDM制式实际上和802.11a是一样的。所以现在问题是10us和16us之间差了6us，如何补上。

在802.11协议中，传输单元还有一个比较隐秘的字段，aSignalExtension。

![img](https://pic1.zhimg.com/80/v2-5279912c4f52ff836741ca38076ab708_720w.jpg)

这个字段在2.4GHz信道下时间就是6us，在5GHz信道上为0us。因为5G信道上没有异构协议，也就是兼容性的问题。这个aSignalExtension补全之后，就没有SIFS的时隙差异了。

那么在2.4GHz信道上，一个兼容模式的帧的发送时间可以计算为：

TXTIME = PreambleLengthCCK + PLCPHeaderTimeCCK + PreambleLengthOFDM + PLCPSignalOFDM + 4 x Ceiling((PLCPServiceBits + 8 x (number-of-octets) + PadBits) / NDBPS) + SignalExtension

## **802.11b/g兼容模式下的Slot**

![img](https://pic4.zhimg.com/80/v2-6f379170040f258b8331b29e82afdb47_720w.jpg)

Slot的时间也是兼容模式下的重要命题，需要被统一，否则会影响DCF的工作机制。如上图，在802.11b/g共存时，Slot时间设置为20us，仅仅只有在802.11g-only的场景下，才可以采取9us的slot时间。

## 802.11b/g的采样校准

在信道带宽上，802.11b和802.11g还有不同。802.11b的信道带宽是22MHz，而802.11g-OFDM模式下，信道带宽是20MHz。信道带宽不同会导致采样点时间上的差异。

如下图所示，802.11b的信道带宽是22MHz，但是其采用的是DSSS的调制模式，所以其采样时钟（对应chip rate）为11MHz。而802.11g-OFDM是基于OFDM调制的，其采用的是复信号，所以采样时钟为20MHz。

![img](https://pic2.zhimg.com/80/v2-15f40d292397ccee7eaf3949c7d2a29d_720w.jpg)

有了上面这个1us的示例，那么就是具体的校准了，这里是OFDM的往Barker码上面校准。

![img](https://pic3.zhimg.com/80/v2-0fad29d8dede6ea46ee52c1e55521946_720w.jpg)

可以看上图，起始的定点时间点是以Baker Chip的开始时间点为准的，然后重复发送11次，在大约1us的边界处，OFDM进行同步发送。这里图上的Pulses Allgned on Zero-Phase Peaks，翻译过来是零相位峰值的校准脉冲，这里零相位我目前理解不是很深，不过基本意思是对准1us的边界进行校准。

![img](https://pic3.zhimg.com/80/v2-13c6caa903258aa0124aab91272dc0c2_720w.jpg)

另外OFDM的相位也是需要校准到Barker码上面的，如上图所示，典型的做法是将最后的Barker的I/Q路相位校准到45°, 135°, -135°和-45°，如上图红色所示。根据不同的Barker相位，OFDM Symbol做不同的处理，比如在第一象限45°时，就按照协议规定的默认发送符号发送，如果是135°，则需要乘以j，即旋转90°。另外这个部分还有一些细节，可以具体参考协议的Transition time alignment一节，基本思想如上。

至此，笔者算是把802.11b/g兼容的细节内容基本都整理了一遍，在后面其他的版本中，制式兼容就不存在了，所以兼容模式会变得简单一些。不过由于引入了多带宽工作模式，所以这里又会变得很复杂，是一个新的兼容问题了，以后再做相应整理。

# 802.11b+，Super-G，Afterburner，Nitro XM

## 序言

在802.11n正式出版前的一段时间内，产品和协议的同步机制还有比较混乱的，同时也是因为协议的制定充满了竞争和合作，所以一直也没有通过。而且在802.11g~802.11n这个时代，可以说是Wi-Fi技术发展最快的世代了，产品更新率很高。所以每一个厂家都迫不及待的推出自己满足部分协议的新产品。

其中最典型的4个产品，即802.11b+，Super-G，AfterBurner，Nitro XM。我们有一点需要注意的是，这一类的Wi-Fi产品虽然超前协议，但是不是脱离协议自己玩，而是超前协议的出版，从现在的眼光而言，这一些产品大体上都还是遵从802.11协议的。

## 802.11b+

802.11b+应该是TI在802.11b世代推出的一个技术，可以将802.11b的物理层提升到22Mbps。这项技术的核心实际上是802.11b世代的PBCC编码，在前一篇讨论802.11g的文章中我们有说明过，该技术实际上是被TI作为802.11g世代的技术推荐给协议组的，最后PBCC编码的扩展，PBCC-22Mbps和PBCC-33Mbps最后也作为可选的技术被写入了802.11g协议。

## Super-G

Super-G算是后802.11g世代最为成熟的技术了，其实际上就是802.11e+802.11n的前瞻版本。Super-G有出过一份技术介绍的白皮书，相关资料整理如下：[Super-G等相关资料](https://link.zhihu.com/?target=https%3A//download.csdn.net/download/fzxy002763/12321132)。

Super-G是由Atheros公司在04年时候推出来的。其实读一读Super-G的白皮书还是有好处的，不过因为过于提前于协议，其名声不是特别好，这里可以参阅下802.11权威指南。

Super-G中一共有4个代表性技术，如下图：

![img](https://pic3.zhimg.com/80/v2-9f3d673d8a9c2fd50526ea345fa955b2_720w.jpg)

**Frame Brusting**：该技术实际上是802.11e的TXOP技术中的一种工作模式，实际上Super-G的时候802.11e已经通过了，由于802.11e能够解决802.11的MAC性能提升，所以厂家也是迫不及待的赶紧上线了。

![img](https://pic2.zhimg.com/80/v2-08b70b311e45100bd73f470af4d0f02d_720w.jpg)

细节内容就不重复提了，实际上就是802.11e里面的TXOP，可以参考前面802.11e的文章。不过在Super-G里面只有逐个ACK反馈这种模式，没有Block ACK反馈的模式。另外，注意这里Frame与Frame之间的间隔是**SIFS**。

**Fast Frames和Frame Compression：**Fast Frames实际上就是802.11n里面开始引入的帧聚合技术，如下图

![img](https://pic3.zhimg.com/80/v2-de4c5bd8ed2acbd5ff413fe7010aa616_720w.jpg)

如上图所示，其实就是TXOP技术的再一次进步，与其一个一个帧单独发，不如一次性帧整个发出去。但是要注意的是，**G+世代的Fast Frames并不完全等价于帧聚合**（包含Afterburner中也是），帧聚合其实更直接一些，虽然是一个聚合帧，但是该聚合帧里面实际上是独立的几个帧，按照连续的形式进行传输，但是都是独立帧，这个也与重传机制和Block ACK的设计有关。

而G+世代里面所考虑的是**Fast Frames和Frame Compression的结合**，通过将多个不同的帧进行聚合，但是也正是因为聚合，所以会增加冗余部分，所以可以对冗余部分进行压缩，减少包体积，进一步提升速率。所以**G+里面的帧聚合，实际上就是一个巨帧，而802.11n里面的帧聚合，则不是一个帧，而是多个帧的集合**。

**Multiple Channels**：这个其实就是对应了802.11n里面的channel bonding，通过在2.4GHz信道上合并连续两个信道，从而有更大的带宽，以提升传输速率。G+的108Mbps就是54Mbps*2，这样计算出来的。不过当时Multiple Channels的时候，多信道带宽接入的算法还不完善，而且channel bonding的时候就是简单的叠加，关于信道资源的分配，比如保护间隔之类的，实则没有做。我们这里需要知道的是channel bonding并不是简单的两个信道叠加，关于子载波的分配也做了改变。

以上几个G+的技术通过下面这张逻辑图可能会更清楚一些：

![img](https://pic1.zhimg.com/80/v2-b40d0fe093ea85eabb981e9df4a96f58_720w.jpg)

关于G+时代的产品价格差异还是有一些的，这是当时06，07年左右的产品售价，可以看出，多一个功能价格也提升不少，所以厂家也热衷于赶紧上线一些新技术：

![img](https://pic4.zhimg.com/80/v2-76a0e954c58d478f25212ae467ade723_720w.jpg)Ref：https://web.archive.org/web/20070401043001/http://www.54g.org/54g_features_quickspecs.php

另外，我们在读802.11权威指南的时候可以看到作者对于前三项技术都是评价正面的，但是关于Multiple Channels的评价比较模糊，实际上有点偏向负面。

![img](https://pic2.zhimg.com/80/v2-144f37546041a065f47fedb05f5d773d_720w.jpg)

简单而言就是Multiple Channels或者权威指南里面的命名 Channel bonding (also called "turbo mode")，在当时是比较受争议的。我们需要知道的是，802.11权威指南出版的时候正是802.11n还在讨论中的时间，作者的观点确实也表达的协议组当时对于channel bonding这一个技术的担忧。虽然这项技术最后取得了成功，而且从802.11n以后一直是协议技术的持续亮点，但是为了多信道兼容，其协议细节设计也着实难度提升不少。

## AfterBurner（Turbo G）

AfterBurner是Broadcom牵头做的，有时候也被称为Turbo G以及125HMS等等，这里有多种它的命名（参考：[AfterBurner](https://link.zhihu.com/?target=https%3A//wiki.dd-wrt.com/wiki/index.php/Afterburner)）。

- SpeedBooster
- SuperSpeed
- Turbo G 125mbps
- 125HSM
- 125* High Speed
- G Plus
- Xpress Technology

现实里面支持它的产品也着实不少，但是技术部分的资料实在比较少，尤其是125Mbps是怎么计算出来的，目前笔者还是没搞明白，就当记录一下吧。目前感觉AfterBurner技术大体上还是和Super-G的思路是一样的，其实都是将802.11e的内容引入。

其中主要两个技术Packet Aggregation和Framebursting。

**Packet Aggregation**：这里直接用了帧聚合的名字，在该技术说明下，可以跑到100Mbps。这里图示上Payload还是一个整体，但是由于技术细节不知道，所以不好确定其有没有整合各个帧体。但是由于其没有和压缩技术合并，所以看起来还是多个子帧的组合，从而形成也给巨帧。

![img](https://pic4.zhimg.com/80/v2-6d790a114ae5e722706f2c2407931d5f_720w.jpg)

**Framebursting：**这个名字和Super-G的相同，但是技术上就存在一点区别了。Super-G的帧突发实际上帧与帧之间的间隔是SIFS，而下图中这个间隔并进一步优化，也就是比SIFS更小，所以下图上画出来就好似紧密的背靠背连接在一起，而且共用了一个Header。这点实际上是802.11n里面的**RIFS**技术的前身。

![img](https://pic2.zhimg.com/80/v2-7207b183222b5b420889a9ab17303399_720w.jpg)

AfterBurner技术最后落到产品上还是比较多的，这个情况应该一直持续到802.11n的正式版本出来。可以说AfterBurner在Super-G的基础上，和802.11n主体就差了一个MIMO技术了，其余就是很多协议细节。

## Nitro XM

Nitro XM实际上更冷门，这个技术实际上没有怎么落到产品上。Nitro XM是由Conexant公司推出的，主打的一个是数据包的压缩技术，另外一个就是802.11e里面的**DLS技术**，技术部分在前面802.11e的文章已经写过了，这里就不重复了。在DLS技术下，其可以跑到140Mbps的速率。但是最后结果我们也知道，DLS实际上因为一些技术问题，并没有成功，而且也被TDLS（802.11z）所更替。而Nitro XM的产品也因为技术不太是市场主流，所以比较冷门。

## 结语

在当时那个世代，关于这几种技术的路由选择还有人做过表格，可以参详下

![img](https://pic3.zhimg.com/80/v2-4ad9b0b82275dfcd009ef9ffe745f676_720w.jpg)

关于802.11b+，Super-G，Afterburner，Nitro XM这几个技术实际上都是产品也协议出版时间不匹配，所产生的时代现象。这些产品虽然并不是严格的遵守802.11协议，但是大体而言都是在协议范畴内的，实际上厂家都不是想去做私有协议，而更多的是希望把自己的技术放入协议中。802.11g到802.11n的世代现在而言，可以说好，也可以说不好。好在于产品优于技术，这个时候技术在进入协议之前是会被参考市场反应的，避免过于技术或者理论化，而不好就是时代产品混乱了。目前协议在新版本发展的时候，这样的问题已经越来越少，还有wave 1和wave 2这样的产品包装方法，已经不会出现以前的混乱情况了。

# 资讯技术类网站整理

## **序言**

这个整理主题一直以来就是纠结放在哪个专题下，主要是关于一些网站的资源，不过一部分可能偏技术一些，一部分可能偏资讯一些，纠结半天还是放在协议精读这个系列下吧。

目前整理的网站是下面这些，有一些好的新发现以后就直接追加在这里，如果有人有推荐的网站资源也可以评论下哈，我追加上来。

## 内容目录

**1. RTL-SDR**（[https://www.rtl-sdr.com/](https://link.zhihu.com/?target=https%3A//www.rtl-sdr.com/)）

![img](https://pic2.zhimg.com/80/v2-7693a23fa7bb732794accaed67ad2841_720w.png)

**2. Sharetechnote**（[http://www.sharetechnote.com/](https://link.zhihu.com/?target=http%3A//www.sharetechnote.com/)）

![img](https://pic2.zhimg.com/80/v2-1b3015aeeb6d074bc99a6d890f403a0d_720w.png)

**3. Wlanpedia**（[https://www.wlanpedia.org/tech/](https://link.zhihu.com/?target=https%3A//www.wlanpedia.org/tech/)）

![img](https://pic3.zhimg.com/80/v2-5d9d119d6cee68c0982f76f398482172_720w.png)

**4. Enterprise Networking**（[http://www.enterprisenetworkingplanet.com/](https://link.zhihu.com/?target=http%3A//www.enterprisenetworkingplanet.com/)）

![img](https://pic4.zhimg.com/80/v2-e403dd193d6e7f739105ff641ef4889f_720w.jpg)

**5. Internet watch**（[https://internet.watch.impress.co.jp/category/hardware/lan/](https://link.zhihu.com/?target=https%3A//internet.watch.impress.co.jp/category/hardware/lan/)）

![img](https://pic3.zhimg.com/80/v2-c6b11dada4564c452a54ea5a2b1d92ba_720w.jpg)

**6. Phoronix**（[https://www.phoronix.com/scan.php?page=home](https://link.zhihu.com/?target=https%3A//www.phoronix.com/scan.php%3Fpage%3Dhome)）

![img](https://pic4.zhimg.com/80/v2-b852d82f7a5b23d2bb261c34e04b2697_720w.png)

**7. LWN**（[https://lwn.net/](https://link.zhihu.com/?target=https%3A//lwn.net/)）

![img](https://pic1.zhimg.com/80/v2-5b25d2425f24d3ac611f1c840504b5bc_720w.png)

**8. CNX Software**（[https://www.cnx-software.com/](https://link.zhihu.com/?target=https%3A//www.cnx-software.com/)）

![img](https://pic1.zhimg.com/80/v2-ddc0bc6d696150ac162b03d3eb74890c_720w.png)

**9. Small Net Builder**（[https://www.smallnetbuilder.com/](https://link.zhihu.com/?target=https%3A//www.smallnetbuilder.com/)）

![img](https://pic2.zhimg.com/80/v2-b719e6c71806bdba9b8b1c467e7ca341_720w.jpg)

**10.Linux Kernel's doc**（[https://www.kernel.org/doc/html/v4.9/index.html](https://link.zhihu.com/?target=https%3A//www.kernel.org/doc/html/v4.9/index.html)）

![img](https://pic4.zhimg.com/80/v2-7708471e9a024be41332a9c458c26dd3_720w.png)

**11. 802.11 TG**（[http://grouper.ieee.org/groups/802/11/](https://link.zhihu.com/?target=http%3A//grouper.ieee.org/groups/802/11/)）

![img](https://pic2.zhimg.com/80/v2-5be99ac9e78e2a3aafd2a666f041a901_720w.jpg)

**12. Wi-Fi Now**（[https://wifinowglobal.com/](https://link.zhihu.com/?target=https%3A//wifinowglobal.com/)）

![img](https://pic4.zhimg.com/80/v2-3caa085979f02e897127c5b8eab526fb_720w.png)

**13. WFA**（[Wi-Fi Alliance](https://link.zhihu.com/?target=https%3A//www.wi-fi.org/)）

![img](https://pic2.zhimg.com/80/v2-5da7c42d4abdeb6ad87df26f5759d4a9_720w.png)

目前总结的就是以上这些，后续有更好的发现我再补上。

###### 持续更新